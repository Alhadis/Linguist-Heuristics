a:864:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:15:"컴퓨터구조";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:10:"table_open";i:1;a:3:{i:0;i:2;i:1;i:13;i:2;i:32;}i:2;i:31;}i:4;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:31;}i:5;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:2;i:1;s:6:"center";i:2;i:1;}i:2;i:31;}i:6;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:"  교과목 정보  ";}i:2;i:33;}i:7;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:53;}i:8;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:55;}i:9;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:55;}i:10;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:55;}i:11;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:14:" 학수번호 ";}i:2;i:57;}i:12;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:71;}i:13;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:71;}i:14;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:" 105672 ";}i:2;i:72;}i:15;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:80;}i:16;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:81;}i:17;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:81;}i:18;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:81;}i:19;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:14:" 교과목명 ";}i:2;i:83;}i:20;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:97;}i:21;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:97;}i:22;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:" 컴퓨터구조 ";}i:2;i:98;}i:23;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:115;}i:24;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:116;}i:25;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:116;}i:26;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:116;}i:27;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:14:" 학점체계 ";}i:2;i:118;}i:28;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:132;}i:29;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:132;}i:30;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:" 3-3-0 ";}i:2;i:133;}i:31;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:140;}i:32;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:141;}i:33;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:141;}i:34;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:141;}i:35;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:14:" 교과구분 ";}i:2;i:143;}i:36;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:157;}i:37;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:157;}i:38;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:14:" 전공필수 ";}i:2;i:158;}i:39;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:172;}i:40;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:173;}i:41;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:173;}i:42;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:173;}i:43;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:14:" 개설학과 ";}i:2;i:175;}i:44;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:189;}i:45;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:189;}i:46;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:190;}i:47;a:3:{i:0;s:12:"internallink";i:1;a:2:{i:0;s:23:"IT융합응용공학과";i:1;N;}i:2;i:191;}i:48;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:218;}i:49;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:219;}i:50;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:220;}i:51;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:220;}i:52;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:220;}i:53;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:14:" 담당교수 ";}i:2;i:222;}i:54;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:236;}i:55;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:236;}i:56;a:3:{i:0;s:12:"internallink";i:1;a:2:{i:0;s:9:"조경연";i:1;N;}i:2;i:237;}i:57;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:250;}i:58;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:251;}i:59;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:251;}i:60;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:2;i:1;s:6:"center";i:2;i:1;}i:2;i:251;}i:61;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:"  수업 정보  ";}i:2;i:253;}i:62;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:270;}i:63;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:272;}i:64;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:272;}i:65;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:272;}i:66;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:14:" 선수과목 ";}i:2;i:274;}i:67;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:288;}i:68;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:288;}i:69;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:71:" 기초전기전자회로, 디지털회로, 어셈블러, 운영체제 ";}i:2;i:289;}i:70;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:360;}i:71;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:361;}i:72;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:361;}i:73;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:361;}i:74;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:14:" 수업방식 ";}i:2;i:363;}i:75;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:377;}i:76;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:377;}i:77;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:70:" 강의 보조자료인 슬라이드를 보면서 교수님이 설명 ";}i:2;i:378;}i:78;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:448;}i:79;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:449;}i:80;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:449;}i:81;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:449;}i:82;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:" 주교재 ";}i:2;i:451;}i:83;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:462;}i:84;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:462;}i:85;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:28:" 컴퓨터 구조 및 설계";}i:2;i:463;}i:86;a:3:{i:0;s:4:"nest";i:1;a:1:{i:0;a:3:{i:0;a:3:{i:0;s:13:"footnote_open";i:1;a:0:{}i:2;i:491;}i:1;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:152:"5판이 번역서가 출간되었으나 4판으로 강의한다고 공지하셨다. 2016년도부터는 5판으로 강의 하실 것을 예고하셨다.";}i:2;i:493;}i:2;a:3:{i:0;s:14:"footnote_close";i:1;a:0:{}i:2;i:645;}}}i:2;i:491;}i:87;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:67:", 데이비드 패터슨, 존 헤네시, 비제이퍼블릭, 2010. ";}i:2;i:647;}i:88;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:714;}i:89;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:715;}i:90;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:715;}i:91;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:2;i:1;s:6:"center";i:2;i:1;}i:2;i:715;}i:92;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"  ";}i:2;i:717;}i:93;a:3:{i:0;s:13:"externalmedia";i:1;a:7:{i:0;s:63:"http://image.aladin.co.kr/product/656/76/cover/8996276537_1.jpg";i:1;N;i:2;N;i:3;N;i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:719;}i:94;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"  ";}i:2;i:786;}i:95;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:788;}i:96;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:790;}i:97;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:790;}i:98;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:790;}i:99;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:" 강의 웹페이지 ";}i:2;i:792;}i:100;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:813;}i:101;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:813;}i:102;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:814;}i:103;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:22:"http://lms.pknu.ac.kr/";i:1;s:19:"부경대학교 LMS";}i:2;i:815;}i:104;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:861;}i:105;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:862;}i:106;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:863;}i:107;a:3:{i:0;s:11:"table_close";i:1;a:1:{i:0;i:863;}i:2;i:863;}i:108;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:864;}i:109;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:26:"개요 (0강 강의소개)";i:1;i:2;i:2;i:864;}i:2;i:864;}i:110;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:864;}i:111;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:864;}i:112;a:3:{i:0;s:12:"internallink";i:1;a:2:{i:0;s:9:"조경연";i:1;N;}i:2;i:903;}i:113;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:73:" 교수님이 가르치시는 컴퓨터구조 과목이다. 주교재는 ";}i:2;i:916;}i:114;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:177:"https://books.google.co.kr/books?id=OhD_RAAACAAJ&dq=%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0%EB%B0%8F%EC%84%A4%EA%B3%84&hl=ko&sa=X&ei=gUL1VNKwM-S9mgWy2YLwDQ&ved=0CC4Q6AEwAA";i:1;s:26:"컴퓨터구조 및 설계";}i:2;i:989;}i:115;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:368:"
2장에 어셈블러 파트가 나온다. 어셈블러만 한 학기 해주면 좋은데, 그냥 함. MIPS란 CPU종류는 명령어가 간단해서 배우기 좋다. 이건 컴퓨터 그래픽스에 주로 활용됨? 미국 실리콘 그래픽스 회사의 워크스테이션을 많이 사용하는데 여기 CPU가 MIPS라고 한다. 닌텐도에도 들어간다는";}i:2;i:1197;}i:116;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:1565;}i:117;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:47:" 중국의 리눅스 사용하기로 하는 썰";}i:2;i:1568;}i:118;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:1615;}i:119;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:302:"과 관련하여 CPU독립으로 MIPS 64비트로 준비 중이다. 3판에서는 MIPS를 중심으로 설명했는데, 3장, 4장(CPU를 설계할 때 MIPS구조를 가지고).
4판부터는 ARM을 중심으로 어셈블러를 설명하고 갑자기 MIPS로 CPU설계하는 것을 설명하고 있다.";}i:2;i:1618;}i:120;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1920;}i:121;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1920;}i:122;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:212:"이번에 나온 5판은 다시 MIPS를 어셈블러 설명한다. 그래서 5판이 좀 더 쉽다고 한다. 하지만 강의 계획서에 4판으로 되있어서 강의도 4판 중심으로 설명하신다는.";}i:2;i:1922;}i:123;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2134;}i:124;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2134;}i:125;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:260:"2장 어셈블러는 너무 열심히 하지 말고, CPU 설계 가능 할 정도만 알고 넘어 가도 된다.
3장은 ALU 설계하는 부분이다. Verilog가 모자라면 힘드니 미리 공부 해 둘 것.
4장은 CPU 설계 들어간다. 어셈블러 ";}i:2;i:2136;}i:126;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"->";}i:2;i:2396;}i:127;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:" 기계어 ";}i:2;i:2398;}i:128;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"->";}i:2;i:2409;}i:129;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:347:" 디지털회로 설계. 스테이트 머신을 설계하는 거랑 같다. 이렇게 CPU 동작을 이해했으면 성능을 높이기 위해 스테이트 머신으로 설계한 CPU를 파이프라인 도입으로 설계하면 성능이 높일 수 있다. 이후에 파이프라인 도입시 발생할 수 있는 문제 해결까지 강의한다.";}i:2;i:2411;}i:130;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2758;}i:131;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2758;}i:132;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:121:"중간고사 끝날 때까지 파이프라인까지 끝낸다. 이후에 나오는 파트도 한 학기 내에 다룬다.";}i:2;i:2760;}i:133;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2881;}i:134;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2881;}i:135;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:167:"4,5판은 스테이트 머신 설계부분을 빼기 시작한다. 그래서 교재엔느 없지만 어쩔 수 없이 다른 자료를 참고하여 강의하시기로.";}i:2;i:2883;}i:136;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3050;}i:137;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3050;}i:138;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:175:"중간고사 이후에는 캐시 구조, 가상메모리를 사용하기 위한 OS의 메모리 관리에서 다루지 않는 하드웨어적인 부분을 다루기로 한다.";}i:2;i:3052;}i:139;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3227;}i:140;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3227;}i:141;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:113:"끝나면 IO(입출력)을 다룬다.5판은 아예 없고, 4판도 불충실해서 보충교재로 보강한다.";}i:2;i:3229;}i:142;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3342;}i:143;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3342;}i:144;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:165:"기타 멀티프로세서, GPU가 있는데 학부에서 하기에는 부담스럽다. 요즘에는 활용도가 늘어나면서 다 학부과정으로 내려왔음.";}i:2;i:3344;}i:145;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3509;}i:146;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3509;}i:147;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:167:"한정된 졸업 학점 내에 다양한 괴목을 다루기 위해 심도 있게 강의해야 할 과목들이 한 학기 내에 가르치기 힘들어 지는 현실?";}i:2;i:3511;}i:148;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3678;}i:149;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3680;}i:150;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:28:"1강 컴퓨터 기본 구성";i:1;i:2;i:2;i:3680;}i:2;i:3680;}i:151;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:3680;}i:152;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3680;}i:153;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:"CPU 모듈";}i:2;i:3721;}i:154;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3731;}i:155;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:3731;}i:156;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:3731;}i:157;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:3731;}i:158;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" ALU";}i:2;i:3735;}i:159;a:3:{i:0;s:4:"nest";i:1;a:1:{i:0;a:3:{i:0;a:3:{i:0;s:13:"footnote_open";i:1;a:0:{}i:2;i:3739;}i:1;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:46:"OP코드와 Operand로 결과를 출력한다.";}i:2;i:3741;}i:2;a:3:{i:0;s:14:"footnote_close";i:1;a:0:{}i:2;i:3787;}}}i:2;i:3739;}i:160;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:3789;}i:161;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:3789;}i:162;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:3789;}i:163;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3789;}i:164;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:81:"메모리 모듈: CPU가 보기에는 I/O와 메모리를 구분하지 않는다.";}i:2;i:3791;}i:165;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3872;}i:166;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3872;}i:167;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:127:"I/O 모듈: 유닉스부터 모든 I/O 종류의 구분이 없어지고 디바이스 드라이버 단계에서 구분해준다.";}i:2;i:3874;}i:168;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4001;}i:169;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4001;}i:170;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:59:"메모리 커넥션(거의 네거티브로직으로 설계)";}i:2;i:4003;}i:171;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4062;}i:172;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:4062;}i:173;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:4062;}i:174;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4062;}i:175;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:297:" 데이터를 주고 받는다. (data bus - 회로상에서 3상태 off상태로 되어있어 물리적으로 회로가 끊어져 있어 브로드캐스팅했어도 원하는 장치에만 전달이 되는 것이다. 컨트롤 버스가 칩셀렉터(?)로 받을 때 동작 여부를 결정한다.)";}i:2;i:4066;}i:176;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4363;}i:177;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4363;}i:178;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:4363;}i:179;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4363;}i:180;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:35:" 주소를 받는다. (address bus)";}i:2;i:4367;}i:181;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4402;}i:182;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4402;}i:183;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:4402;}i:184;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4402;}i:185;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:42:" 제어 신호를 받는다. (control bus)";}i:2;i:4406;}i:186;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4448;}i:187;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:4448;}i:188;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:2;}i:2;i:4448;}i:189;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4448;}i:190;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" Read";}i:2;i:4454;}i:191;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4459;}i:192;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4459;}i:193;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:2;}i:2;i:4459;}i:194;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4459;}i:195;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:" Write";}i:2;i:4465;}i:196;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4471;}i:197;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4471;}i:198;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:2;}i:2;i:4471;}i:199;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4471;}i:200;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:" Timing";}i:2;i:4477;}i:201;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4484;}i:202;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4484;}i:203;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:4484;}i:204;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4484;}i:205;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:4484;}i:206;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4484;}i:207;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:48:" 내부 버스가 필요하다. (I/O도 같다.)";}i:2;i:4488;}i:208;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4536;}i:209;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:4536;}i:210;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:2;}i:2;i:4536;}i:211;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4536;}i:212;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:" data bus";}i:2;i:4542;}i:213;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4551;}i:214;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4551;}i:215;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:2;}i:2;i:4551;}i:216;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4551;}i:217;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:" address bus";}i:2;i:4557;}i:218;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4569;}i:219;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4569;}i:220;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:2;}i:2;i:4569;}i:221;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4569;}i:222;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:" control bus";}i:2;i:4575;}i:223;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4587;}i:224;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4587;}i:225;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:4587;}i:226;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4587;}i:227;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:4587;}i:228;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4587;}i:229;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:"Buses";}i:2;i:4589;}i:230;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4594;}i:231;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:4594;}i:232;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:4594;}i:233;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4594;}i:234;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:54:" 부품들을 연결하는 선이라고 보면 된다.";}i:2;i:4598;}i:235;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4652;}i:236;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4652;}i:237;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:4652;}i:238;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4652;}i:239;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:14:" 싱글 버스";}i:2;i:4656;}i:240;a:3:{i:0;s:4:"nest";i:1;a:1:{i:0;a:3:{i:0;a:3:{i:0;s:13:"footnote_open";i:1;a:0:{}i:2;i:4670;}i:1;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:284:"대표적으로 USB가 있다. 4가닥에 보내고 받는 구조로 되있다. 받을 때는 커먼 노이즈를 줄여주게 설계한다. 싱글 버스는 한 버스로 Control/Address/Data bus를 모두 기능한다. 디프레션으로 보내는 1비트 시리얼한 버스이다.";}i:2;i:4672;}i:2;a:3:{i:0;s:14:"footnote_close";i:1;a:0:{}i:2;i:4956;}}}i:2;i:4670;}i:241;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4958;}i:242;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4958;}i:243;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:4958;}i:244;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4958;}i:245;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:88:" 두 개 그 이상의 장치가 보통 브로드캐스팅으로 통신하는 것이다.";}i:2;i:4962;}i:246;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:5050;}i:247;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:5050;}i:248;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:5050;}i:249;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:5050;}i:250;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:122:" 32비트 데이터 버스는 라인이 32 가닥. 팬티엄 PC 같은 경우는 64비트이다. 이건 버스가 64가닥";}i:2;i:5054;}i:251;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:5176;}i:252;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:5176;}i:253;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:5176;}i:254;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:5176;}i:255;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:61:" 전원 라인은 보통 버스에 포함시키지 않는다.";}i:2;i:5180;}i:256;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:5241;}i:257;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:5241;}i:258;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:5241;}i:259;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:5241;}i:260;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:55:" 메모리는 데이터 버스에서 값을 읽을 때 ";}i:2;i:5245;}i:261;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:5300;}i:262;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"data";}i:2;i:5301;}i:263;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:5305;}i:264;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"인지 ";}i:2;i:5306;}i:265;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:5313;}i:266;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:"instruction";}i:2;i:5314;}i:267;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:5325;}i:268;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:58:"인지 구분하지 않는다. 구분은 CPU에서 한다.";}i:2;i:5326;}i:269;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:5384;}i:270;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:5384;}i:271;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:5384;}i:272;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:5384;}i:273;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:233:" data bus는 bi-direction이라 write할 때는 3상태 게이트가 on되서 쓰고, read할 때는 off되서 읽는다. 그러나 반도체 IC내에서는 3상태 게이트를 쓸 수 없어 write/read data bus를 분리 시킨다.";}i:2;i:5388;}i:274;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:5621;}i:275;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:5621;}i:276;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:5621;}i:277;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:5621;}i:278;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:106:" 캐시 때문에 CPU는 32비트라도 데이터 버스는 64비트를 사용한다. 나중에 더 설명";}i:2;i:5625;}i:279;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:5731;}i:280;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:5731;}i:281;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:5731;}i:282;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:5731;}i:283;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:539:" 소프트웨어 하나만 실행시켜도 해당 소프트웨어를 구성하는 각 프로세스가 우리가 알고 있는 메모리 용량을 차지하게 된다. 실제로 하드웨어적으로는 더 많은 메모리 용량을 필요로 한다. MLU설계에서 더 설명 (중간고시 이후에) 이 메모리를 더 늘려줘야 하는 게임등을 하니 요즘 나오는 것들은 거의 다 64비트 CPU로 간다. PC도 모바일 프로세스도. 한 개 프로세스에서 관리하는 메모리 용량이 커지기 때문에.";}i:2;i:5735;}i:284;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:6274;}i:285;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:6274;}i:286;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:6274;}i:287;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:6274;}i:288;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:270:" Address bus도 bi-direction이다. CPU만 address/control bus로 신호를 출력하는게 아니고 I/O도 CPU를 잠시 멈추고 address/control bus 신호를 보낼 때가 있다. I/O가 마스터가 되는 경우가 있다는 것. 보통은 CPU가 마스터이다.";}i:2;i:6278;}i:289;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:6548;}i:290;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:6548;}i:291;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:6548;}i:292;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:6548;}i:293;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:622:" 컨트롤 버스는 타이밍 제어를 한다. CPU는 시퀀셜 머신이라 전부 플립플롭으로 구성되어 있어 클락으로 동기화 한다. 시퀀셜 머신은 클락 엣지에서만 동작한다. 한 머신 사이클에서 CPU가 한 개 데이터나 주소를 읽고 쓴다. 스테이터스 시그널은 CPU가 뭘 할지를 알려준다. 메모리가 워낙 느려서 stable address를 유지시켜 준다. 그동안 CPU는 다른 일을 한다. 메모리는 스테이터스 시그널로 CPU가 뭘하는지 확인하고, 스테이블 어드레스를 읽어 칩셀렉터를 조합논리로 구성한다.";}i:2;i:6552;}i:294;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:7174;}i:295;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:7174;}i:296;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:7174;}i:297;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7174;}i:298;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:"CPU에는 MAR";}i:2;i:7176;}i:299;a:3:{i:0;s:4:"nest";i:1;a:1:{i:0;a:3:{i:0;a:3:{i:0;s:13:"footnote_open";i:1;a:0:{}i:2;i:7189;}i:1;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:63:"메모리 어드레스 레지스터. D플립플롭으로 설계";}i:2;i:7191;}i:2;a:3:{i:0;s:14:"footnote_close";i:1;a:0:{}i:2;i:7254;}}}i:2;i:7189;}i:300;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:", MBR";}i:2;i:7256;}i:301;a:3:{i:0;s:4:"nest";i:1;a:1:{i:0;a:3:{i:0;a:3:{i:0;s:13:"footnote_open";i:1;a:0:{}i:2;i:7261;}i:1;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:41:"메모리 버퍼 레지스터, 또는 MDR";}i:2;i:7263;}i:2;a:3:{i:0;s:14:"footnote_close";i:1;a:0:{}i:2;i:7304;}}}i:2;i:7261;}i:302;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7306;}i:303;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7306;}i:304;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:129:"여기까지는 이해를 해야 이 책을 들어 갈 수 있다. 저자는 컴퓨터 개론에서 배웠다고 생각하는듯?";}i:2;i:7308;}i:305;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7437;}i:306;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7437;}i:307;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:236:"1953 - IAC 컴퓨터. 위 컴퓨터 구조와 큰 차이는 없다. 너무 커서 국가기관에서만 사용.
1964 - IBM-360 최초의 상업용 대형 컴퓨터. 대량 생산이 가능해져 OS가 필요하게 됨. 그래서 많은 ";}i:2;i:7439;}i:308;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:2:"OS";}i:2;i:7675;}i:309;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:409:" 책이 IBM 360을 기본으로 쓰인다. 도노반이 쓰인 시스템 소프트웨어 책도 IBM 360를 기본으로 쓰였다. 그만큼 영향이 컷다.
1970 - IBM-370. 소프트웨어 호환성 문제를 해결해가며 Z-9000 시리즈까지 나왔다. 소프트웨어 호환성을 유지하였기 때문에 IBM 360 때의 소프트웨어까지 모두 호환 가능하다. 대형컴퓨터(main frame).";}i:2;i:7677;}i:310;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8086;}i:311;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8086;}i:312;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:384:"DEC에서 PDP-11이라는 16비트 미니 컴퓨터를 생산하였다. 일부 대학에 보급되었다. 유닉스나 인터넷이 여기서 개발되었다.
1978 - VAX-11/780 32비트 미니 컴퓨터를 개발하였다. 전세계 대학에 거의 보급되어 히트를 침. 이후 유닉스, 인터넷은 이를 중심으로 개발. 이후 교재도 이를 기준으로 쓰인다.";}i:2;i:8088;}i:313;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8472;}i:314;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8472;}i:315;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:61:"1969 - microprocessor가 개발되기 시작함.
인텔 8086 ";}i:2;i:8474;}i:316;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"->";}i:2;i:8535;}i:317;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" 286 ";}i:2;i:8537;}i:318;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"->";}i:2;i:8542;}i:319;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" 596 ";}i:2;i:8544;}i:320;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"->";}i:2;i:8549;}i:321;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:483:" 팬티엄까지 소프트웨어 호환성이 유지되 과거 소프트웨어까지 돌아간다. 하지만 이를 위해 명령어가 늘어난다. 이렇게 거의 쓰지 않는 명령어문제를 해결하기 위해 RISC가 고안되었다. RISC는 명령어 수가 적지만 프로그램 사이즈가 커진다. 하드웨어 가격이 줄어든다. 동작수도 빨라져 성능도 올라간다. 80년대 중반에는 거의 RISC로 개발되었다. ARM도 RISC의 일종이다.";}i:2;i:8551;}i:322;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9034;}i:323;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9034;}i:324;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"CISC도 있다.";}i:2;i:9036;}i:325;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9051;}i:326;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:9053;}i:327;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:4:"2강";i:1;i:2;i:2;i:9053;}i:2;i:9053;}i:328;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:9053;}i:329;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9053;}i:330;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:58:"RISC와 CISC에 대한 이야기로 강의를 시작하다";}i:2;i:9070;}i:331;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9128;}i:332;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9128;}i:333;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:113:"80년대 중반 RISC 스탠포드 대학과 버클리 대학에서 설계함.
그 이전 것은 CISC라고 부름";}i:2;i:9130;}i:334;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9243;}i:335;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9243;}i:336;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:175:"R? Instruction Set Computer
RISC는 명령어 수가 간단하고 내부구조가 심플한 MIPS와 sun 워크스테이션에 사용되는 SPARC 등으로 발달되어 갔다.";}i:2;i:9245;}i:337;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9420;}i:338;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9420;}i:339;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:90:"2020년도 쯤에는 전세계 생산된 전력의 20%를 서버가 잡아먹을 것이다";}i:2;i:9422;}i:340;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:9512;}i:341;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" 흠좀무";}i:2;i:9515;}i:342;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:9525;}i:343;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:57:"
CO2 사용량을 줄이려면 서버를 없애야 한다";}i:2;i:9528;}i:344;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:9585;}i:345;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:" 라는 생각;";}i:2;i:9588;}i:346;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9603;}i:347;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9603;}i:348;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:793:"60년대 초반의 컴퓨터의 동작 구조는
중앙 CPU가 따로 있고 CRT와 키보드로 구성된 console이 중앙 CPU에 물려져 구성되었다. 당시에는 콘솔이 매우 비쌌다.
당시 컴퓨터 제조의 경쟁력은 콘솔을 얼마나 싸게 만드느냐 였다.
당시에는 콘솔을 모두 디지털 회로로 만들어 가격은 싼데 CDC의 프로토콜과 UNIVAC의 프로토콜이 달라 호환이 안됐다.
그러나 콘솔에서 CPU를 쓰면 소프트웨어만 새로 만들면 되었는데 Intel에서 4비트 마이크로 프로세서 i4004를 개발하여 돌아다녔다.
i4040을 개량하여 Embedded computer에 적용하여 겨우 시장을 형성하여 성공을 거두게 된다. (당시에는 제어쪽에 컴퓨터를 쓸 생각을 못했다고";}i:2;i:9605;}i:349;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:10398;}i:350;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:")
i8008 ";}i:2;i:10401;}i:351;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"->";}i:2;i:10409;}i:352;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:373:" i8080 넘어오면서 8비트 마이크로 프로세서 시장이 열리게 된다.
교수님 한창 때 인천 항만 컨테이너 저울에서 i4040을 쓰는 걸 목격했다 하심.
당시 안기부 소관이었던 김포공항 flip board 제어에 i8080를 사용하는 것도 목격하심.
고장난 걸 고칠 때는 회로도랑 프로그램을 알아야 하는데";}i:2;i:10411;}i:353;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:10784;}i:354;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:" 결국 못고치심";}i:2;i:10787;}i:355;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:10807;}i:356;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10810;}i:357;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10810;}i:358;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1434:"자동차 한 대에 Embedded 컴퓨터 CPU가 50~70개, 100~105 개정도 들억나다. 차종 마다 다름. 앞으로 더 많아질 것.
80년대들어 Soc(System On Chip)가 많이 나오기 시작함.
8비트 MP중 Z80가 많이 씀. 20k 게이트로 SOC의 CPU를 설계할 수 있다.
i8051란 CPU도 Z80보다 성능이 떨어지지만 8비트 MP는 성능이 별로 중요하지 않다. 12K gate로 CPU 설계 가능.
자동차에 8비트 MP를 많이 쓴다.
16비트 MP는 68000: 200k gate로 만들어졌다. 이게 SOC에 넣을 순 없다. SOC 자체가 많은 게이트를 넣을 수 없어서.
SOC의 CPU역할을 할 32비트 MP를 개발된다. 이게 ARM-5 CPU 20k gate로 Z80와 복잡도가 같았다. 물론 전력소모가 컸지만 당시엔 전력소모에 관심 없었음.
ARM은 동급에 비해 게이트 수가 적어 복잡한 계산에는 적절하지 않았다. 그러나 8비트보단 좋고 16비트 복잡한 cpu보단 덜한 성능에서 독자적인 위치를 잡게된다.
지금은 ARM에 계속 추가되어 너무 복잡해져 더 이상 Embedded computers에 쓸 수 없어
가장 간단하게 만들어 Cortex-M0(32비트 ARM) 12k gate를 내놓았다.
보통 IoT 센서 제어에서 8비트 i8051로도 성능이 남아 주로 썼다.
요즘에는 Cortex-M0를 더 쓰는데, 그 이유는 제조사 측에서 부품을 수주할 때 8비트는 안받고 32비트를 받아서 그렇다고";}i:2;i:10812;}i:359;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:12246;}i:360;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:167:"
부산대에서 교수님과 개발한 Juno-S1도 성능이 거의 같고 10k gate로 더 간단하게 나와 Cortex-M0와 한국 시장에서 경쟁 해 볼거라고";}i:2;i:12249;}i:361;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:12416;}i:362;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:61:"
Embedded 시장 중 셀룰러 폰 쪽은 10%도 안된다고";}i:2;i:12419;}i:363;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:12480;}i:364;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:38:" 가격은 싸지만 시장이 넓다.";}i:2;i:12483;}i:365;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12521;}i:366;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12521;}i:367;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:435:"컴퓨터의 성능! Understanding Performance
알고리즘
프로그래밍 언어, 컴파일러, 아키텍처
프로세서와 메모리 시스템
팬티엄이 4GHZ이나
DDR메모리는 데이터를 읽어라고 하면 빠른게 20nsec정도로 사전 작업을 한 뒤 2GHz로 4블럭으로? 데이터를 내줌
여튼 그래서 메모리가 아무리 빨라도 CPU에 비해 느린데 이 문제 해결이 관건
IO는 기타 문제";}i:2;i:12523;}i:368;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12958;}i:369;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12958;}i:370;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:516:"프로그래밍 코드 레벨에서 볼 때
소스 코드가 기계어로 변환되는 과정에서
컴파일 과정과 어셈블과정에 대한 구분을 설명 해 주심.
컴파일러에 어셈블러 기능을 포함하는 것도 있지만
컴파일러, 어셈블러, 로더 각각의 전문 분야고 모두 잘하긴 힘들어
각각 전문가가 붙어 최적화 시키는게 좋을 수 있다고 설명 하심.
한 사람의 천재가 모두 설계할 수 있다면 가능 하겠지만.. 흔치 않은 얘기";}i:2;i:12960;}i:371;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13476;}i:372;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13476;}i:373;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:142:"컴퓨터 내부를 뜯어 보면
CPU는 하나 들어가지만 메모리가 참 많이 들어가 있다. 전력소모의 주범은 메모리!";}i:2;i:13478;}i:374;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13620;}i:375;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13620;}i:376;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:156:"CPU내부를 보면
Register file(여러개~)
ARM: R0~R15
MIPS: R0~R31
pentium: 8ea
로더블 메모리이고 PC같은 건 레지스터 파일 내에 있음";}i:2;i:13622;}i:377;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13778;}i:378;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13778;}i:379;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:28:"ALU: 산술 연산을 수행";}i:2;i:13780;}i:380;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13808;}i:381;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13808;}i:382;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:348:"IR: 읽은 명령어(기계어)가 들어감. 따로 디코더를 붙여줌?
레지스터 파일에 있는 레지스터는 소프트웨어를 작성할 때 명시적으로 다루는 레지스터(소프트웨어맨 입장에서 보는 레지스터)이고, IR은 암시적이라 볼 수 있음.
Cont
IR과 Cont부분을 합쳐 Control Unit라고 함.";}i:2;i:13810;}i:383;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14158;}i:384;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14158;}i:385;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:459:"레지스터 파일과 ALU를 datapath라고 보고
Control Signal에 해당하는 CU같은 경우 스테이트 머신으로 설계해야 하는데 너무 어렵다
해서 설계 가능하도록 바꿔서 설계해볼 것.
이게 이해되면 이걸 성능 높이기 위해 파이프라인으로 어떻게 바꿔 지는지 공부하고
파이프라인으로 설계하면서 생기는 문제점을 하드웨어적으로 어떻게 해결할지 공부할 것임.";}i:2;i:14160;}i:386;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14619;}i:387;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14619;}i:388;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:204:"메모리 관리는 캐시 메모리와 MMU(memory management unit) 두가지를 얘기하는데
MMU는 OS에서 관리한다. 캐시는 전적으로 하드웨어가 해결한다. 이는 챕터 5장에서";}i:2;i:14621;}i:389;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14825;}i:390;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14825;}i:391;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:623:"컴퓨터 성능에 관한 용어들
Response time(응답시간): 어떤 작업을 수행하는데 걸린 시간. 데이터 프로세싱에서 많이 고려.
Throughput: 정해진 시간 내에 얼마나 많은 일을 처리하느냐. 데이터 프로세싱에서 많이 고려. 서버는 이걸 많이 다룸
Latency time(지연시간): 어떤 명령을 지시하고 나서 이 명령어에 대한 수행이 시작하는데까지 걸린 시간. Embeded 시스템에서 상당히 중요함.
예로 자동차 브레이크를 밟을 때 이 시간이 짧아야 한다.
퍼포먼스는 상대적으로도 파악할 수 있다.";}i:2;i:14827;}i:392;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15450;}i:393;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15450;}i:394;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:260:"Execution Time 측정
Elapsed time: 모든 원인을 다 고려한 시간
CPU time: CPU만 고려한 시간
CPU time이 똑같은 PC와 워크스테이션을 예로보면 워크스테이션에 IO처리 시간이 빠르게 설계되어 Elapsed time이 빠르다";}i:2;i:15452;}i:395;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15712;}i:396;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15712;}i:397;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:381:"CPU time
Clock period를 줄이는게 성능을 높이는 것.
CPU Clock Cycles를 Clock Rate로 나누면 CPU time이 구해진다 (뭐 곱하기 뭐는 뭐지..?)
이를 계산하는 예제에서 RISC가 사용할 수 있는 명령어 셋은 줄지만 프로그램에서 명령어가 많이 필요해지나
결과적으로 속도는 더 빨라지는 것을 확인 할 수 있다.";}i:2;i:15714;}i:398;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16095;}i:399;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16095;}i:400;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:300:"각 명령어마다 CPU time이 다르다 (메모리를 중간에 읽어야 하는 것과 없는 명령어가 다름)
CPI(Clock per Instruction)는 각 명령출현 빈도수에 따라 달라진다. 낮을 수록 좋음
펜티엄은 보통 0.4정도 됨. 어떻게 1개 명령어가 아니지? ㅋㅋ";}i:2;i:16097;}i:401;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16397;}i:402;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16397;}i:403;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:100:"컴퓨터의 성능 저해 요소가 첫번째는 메모리였고, 두번째가 파워이다.
Pd= CV";}i:2;i:16399;}i:404;a:3:{i:0;s:16:"superscript_open";i:1;a:0:{}i:2;i:16499;}i:405;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"2";}i:2;i:16504;}i:406;a:3:{i:0;s:17:"superscript_close";i:1;a:0:{}i:2;i:16505;}i:407;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:412:"F
C는 캐패시턴스. 이게 많으면 전력소모가 많아진다.
펜티엄을 줄여서 전력소모를 줄여서 atom을 만들었다. atom은 arm보다 몇배의 전력을 소모한다.
atom에서 5v에서 1.1v로 전압을 낮춤. 지금은 0.7v까지 내리려고 함.
F는 프리퀀시. 이건 낮추면 안됨. 이게 빨라야 성능이 좋아짐.
단, F를 올리는 대신 CPI를 낮추면 된다.";}i:2;i:16511;}i:408;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16923;}i:409;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:16926;}i:410;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:4:"3강";i:1;i:2;i:2;i:16926;}i:2;i:16926;}i:411;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:16926;}i:412;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16926;}i:413;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:68:"Power = Capacitive load * Voltage^2 * Frequency
전에 얘기 한거";}i:2;i:16943;}i:414;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17011;}i:415;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17011;}i:416;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:257:"싱글 코어 CPU의 한계로 멀티프로세서로 성능 향상을 꾀했다.
미소 냉전시절 멀티프로세서 연구에 집중됐는데
많은 연구비를 투입했으나 4코어 이상은 딱히 좋은 점이 없어져 투자가 중단되었다.";}i:2;i:17013;}i:417;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17270;}i:418;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17270;}i:419;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:67:"중간고사 끝나고 멀티프로세서 기술을 살펴보기로";}i:2;i:17272;}i:420;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:17339;}i:421;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17342;}i:422;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17342;}i:423;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:32:"IC의 집적도에 관한 설명";}i:2;i:17344;}i:424;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:17376;}i:425;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:371:"
Design rule은 트랜지스터의 제작 공정 단위를 말하는데
절반으로 줄어들면 넣을 수 있는 트랜지스터의 4배가 들어갈 수 있게 된다.
반도체에는 어떤 경제적인 크기가 있다. 이 크기안에 반도체 회로가 들어간다.
이왕이면 이 크기안에 최대한의 gate를 넣어야 성능개선이 이루어 진다.";}i:2;i:17379;}i:426;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17750;}i:427;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17750;}i:428;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:319:"성능 측정은 드라이 스톤의 올드한 공식으로 성능을 비교함
MIPS: Millions of Instructions Per Second로 비교하는 것도 있다. CPU 종류마다 다른 명령어 개수로 VAX-11/780의 경우로 환산하여 비교하는데 주로 제조사측에서 환산하여 공개하므로 믿을 수 없";}i:2;i:17752;}i:429;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:18071;}i:430;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:153:"?
SPEC값이 크면 클 수록 성능이 좋은 것. 매년 옵티마이즈된 컴파일러에 맞춰 바뀌기 때문에 이것도 유명무실해지는";}i:2;i:18074;}i:431;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:18227;}i:432;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:153:"
스펙파워는 전력소모도 고려한 것.
CPU는 10%만 일하게 하고 90%를 놀게해도 전력소모는 그렇지 않다는 걸 알 수 있음";}i:2;i:18230;}i:433;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18383;}i:434;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18383;}i:435;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:242:"암달의 법칙은 멀티 프로세서의 성능을 분석하기에 좀 더 용이하다
멀티프로세서를 사용하더라도 소스코드에서 병렬처리가 없는 부분도 있기 때문에
기대 성능이 안나온다는게 요지";}i:2;i:18385;}i:436;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18627;}i:437;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18627;}i:438;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:99:"챕터 2장 어셈블러
보충자료와 번갈아가면서 진행 Processor Structure and Function";}i:2;i:18629;}i:439;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18728;}i:440;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18728;}i:441;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:517:"Instruction Set을 먼저 설계
instruction length를 두가지로 설계할 수 있다
fixed length IS - ARM. 프로그램 사이즈가 커져 메모리 버들랙이 늘어나고 전력소모도 증가하는 등 성능 저하 생김. 현재 ARM의 thumb2는 16비트와 32비트 명령어 길이 두가지를 갖는다.
variable lenth IS - Pentium. CPU의 Control Unit 설계가 힘들어 진다. 대신 자주 사용하는 명령어는 줄일 수 있으므로 전체 프로그램 사이즈가 작아질 수 있다.";}i:2;i:18730;}i:442;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:19247;}i:443;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:19247;}i:444;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:196:"명령어 구조를 알기 전에 레지스터 파일이 문젠데
CPU 동작의 중심인 레지스터를 좀 더 알아 두는게 좋다.
레지스터는 가장 비싸고 빠른 메모리이다.";}i:2;i:19249;}i:445;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:19445;}i:446;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:19445;}i:447;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:351:"범용레지스터의 용도~(GPR) 데이터, 주소로 쓸 수 있다.
진짜 범용일 수도 있고 제한적일 수도 있다.
전부 범용이면 컴파일러를 만들기 쉬우나 IS가 복잡해짐
제한을 두면 어셈블러와 하드웨어가 간단해지나 컴파일러 만들기가 괴로워져 효율적인 머신코드가 안나온다";}i:2;i:19447;}i:448;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:19798;}i:449;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:19798;}i:450;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:149:"특수용도 레지스터가 있는데 세그먼트 레지스터 같은거 신경안써도 됨
Status Register는 플래그 레지스터라고도 함";}i:2;i:19800;}i:451;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:19949;}i:452;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:19949;}i:453;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:110:"32비트 펜티엄은 32비트 레지스터가 8개다
64비트 펜티엄은 64비트 레지스터가 16개다";}i:2;i:19951;}i:454;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:20061;}i:455;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:20061;}i:456;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:150:"ARM은 레지스터가 R0~R15 16개 있다. (32비트)
GPR이 13개다 나머진 스페셜. 또 Status Register가 있다
R13 - Stack Pointer
R15 - PC";}i:2;i:20063;}i:457;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:20213;}i:458;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:20213;}i:459;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:91:"MIPS의 레지스터
1. 32비트가 32개 - GPR 제한 없음
2. PC: 32비트
3. CR 이건 ";}i:2;i:20215;}i:460;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:2:"OS";}i:2;i:20306;}i:461;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:" 만들 때만 신경씀";}i:2;i:20308;}i:462;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:20332;}i:463;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:20332;}i:464;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:432:"레지스터의 수가 적으면 메모리 접근이 많아지게 된다.
Juno-S1의 예. 전체 12,000Gate 중 3,000gate가 레지스터임
교수님 의견으로는 16개가 적정하고
32개는 좀 더 성능 개선 이뤄짐
64개를 쓰면 컴파일러가 레지스터를 다 쓰지 못하고 하드웨어가 복잡해지고 전력소모만 늘어나고 해서 시장에서없어짐
RISC는 거의 32개 레지스터를 가짐";}i:2;i:20334;}i:465;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:20766;}i:466;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:20766;}i:467;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:131:"레지스터의 길이는 대충 워드 사이즈와 같다
32비트 CPU는 32비트 레지스터
64비트는 64비트 레지스터";}i:2;i:20768;}i:468;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:20899;}i:469;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:20899;}i:470;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:492:"어셈블러 명령어중 제일 많이 나오는게
1) MOVE reg to reg
mov r5, r7 ; r7을 r5로 옮김
인텔문법은 뒤에서 앞으로 옮김
AT&T(유닉스/리눅스) 문법은 앞에서 뒤로(오른쪽으로) 옮김
MOVE 명령어는 자주 나오니까 가변 길이 명령어라면 32개 레지스터를 사용한다면 이를 구분하기 위해
5비트만 있으면 됨. 두개니까 10비트, 나머지 6비트로 Op code를 할당하면 전체 길이 낭비를 줄일 수 있다";}i:2;i:20901;}i:471;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:21393;}i:472;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:21393;}i:473;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:205:"2) LOAD 어떤 레지스터에 메모리 주소를 넣어라
ld r5, offset[r7]
offset은 MIPS에서 16비트, ARM에서 13비트. 메모리 주소가 32비트라 32비트 명령어 길이로 쓸 수 없음";}i:2;i:21395;}i:474;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:21600;}i:475;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:330:"
index addressing
r7+offset 의 메모리 주소에서 값을 r5로 가져 온다.
OP 6비트 / dst 5비트 / index 5비트 / offset 16비트
다른 address mode가 있으나 컴파일러 만들 때 거의 안쓰므로 RISC로 갈 때 다 없앰
OP 6비트 / dst 5비트 / index1 5비트 / index2 5비트 / 나머지 offset 비트";}i:2;i:21603;}i:476;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:21933;}i:477;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:21933;}i:478;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:27:"STORE
st src, offset[index]";}i:2;i:21935;}i:479;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:21962;}i:480;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:21962;}i:481;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"3) jmp / jcc";}i:2;i:21964;}i:482;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:21976;}i:483;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:21976;}i:484;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:721:"4) ALU
add a, b, c
오퍼랜드가 3개 필요한 연산이 약 20%밖에 안됨. 고정길이 CPU는 그냥 이거 씀
2오퍼랜드는 펜티엄에서 씀. 가변 길이이므로 이거 씀
1오퍼랜드는 Acc레지스터를 씀. 8비트 MP는 이거 씀
0오퍼랜드 TOP(stack.pop)+TOP(stack.pop) 결과를 TOP에 넣는다. 자바에서 이 스택컴퓨터를 쓴다. 레지스터 개수가 다른 CPU 호환성을 위해 씀. 그러나 효율은 떨어짐 스택에 접근하는게 메모리에 접근하는거라 그럼. 이게 자바가 더 느린 이유. 자바는 대책없이 무지하게 느림. 스택을 레지스터에 안 넣음. 이유는 스택이 무한공간을 사용하기 때문. 너무 비싸짐.";}i:2;i:21978;}i:485;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:22699;}i:486;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:22702;}i:487;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:4:"4강";i:1;i:2;i:2;i:22702;}i:2;i:22702;}i:488;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:22702;}i:489;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:22702;}i:490;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:91:"중간 연산 결과는 잘 모르겠으면 거의 스택에 저장된다고 보면 된다.";}i:2;i:22719;}i:491;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:22810;}i:492;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:22810;}i:493;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:25:"a = b + c 를
reg Op reg ";}i:2;i:22812;}i:494;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"=>";}i:2;i:22837;}i:495;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:101:" reg에 저장하는 경우 - RISC는 오직 이 명령어만 씀. CISC는 이것도 씀.
reg OP mem ";}i:2;i:22839;}i:496;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"=>";}i:2;i:22940;}i:497;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:104:" reg에 저장하는 경우 - 파이브라인 설계할 때 힘들어져 CISC에서 만 씀.
mem Op reg ";}i:2;i:22942;}i:498;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"=>";}i:2;i:23046;}i:499;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:209:" mem에 저장하는 경우 - 마찬가지로 CISC에서만 씀. 팬티엄은 파이프라인 설계도 하고 CISC 프로세스여서 전력소모 무지하게 많다. 해서 모바일에 못 씀.
mem Op mem ";}i:2;i:23048;}i:500;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"=>";}i:2;i:23257;}i:501;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:98:" mem에 저장하는 경우 - 너무 복잡해서 거의 이런 명령어는 갖고 있지 않다.";}i:2;i:23259;}i:502;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:23357;}i:503;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:23357;}i:504;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:375:"RISC 프로세서를 로드 스토어 머신이라고 하는 이유가 메모리를 접근할 수 있는 명령어가 로드, 스토어 명령어 밖에 없다.
이는 파이프라인 구조를 간단하게 만들기 위해. 이는 하드웨어 설계를 간단히 하게 해줘서 전력소모 공식에서 캐패시턴스 수를 줄여 줘 전력소모 줄여주기 때문.";}i:2;i:23359;}i:505;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:23734;}i:506;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:23734;}i:507;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:582:"메모리 주소는 워드 단위가 아닌 바이트 단위로 어드레싱함.
빅엔디안(BE) - 대표 어드레스에 큰 숫자가 들어감. 사람이 글 쓰는 방향과 맞음. 모토로라 I/O 칩들은 다 빅엔디안이다.
리틀엔디안(LE) - 대표 어드레스에 작은 숫자가 들어감. 수 연산할 땐 이게 더 적합함. ARM, 인텔 CPU는 리틀엔디안을 씀.
이 엔디안 맞춰 주는건 하드웨어로 맞춰주는게 아니고 소프트웨어로 맞춰줘야 한다.
MIPS는 둘다 쓰는데 이를 구분하는 스위치에 따라 처리함.";}i:2;i:23736;}i:508;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:24318;}i:509;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:24318;}i:510;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:567:"반면 CPU는 워드단위로 어드레싱한다.
어드레스 버스에 A1~A0가 없는 이유는?
어드레스 버스는 A31~A2까지 있고
misaligned(unaligned) 된 데이터는 두 번 읽어와야 함.
데이터 버스는 D31~D0가 있다.
데이터 버스 스티어링 - unaligned data를 두번 읽고 다시 조합하는 것
ARM은 aligned data만 쓰기로 강제해뒀음.
aligned data와 unaligned data를 어떻게 구분? 어드레싱이 워드단위로 안떨어지게 하면 unaligned 되므로 워드단위로 나눠 떨어지는지로 알 수 있군";}i:2;i:24320;}i:511;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:24887;}i:512;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:24890;}i:513;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:24890;}i:514;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:210:"메모리는 레지스터보다 무지하게 느림.
레지스터의 개수는 16개 정도면 괜찮고, 32개 정도면 충분함.
컴파일러에서 레지스터 옵티마이제이션이 되게 중요하다.";}i:2;i:24892;}i:515;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:25102;}i:516;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:25102;}i:517;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:96:"Immediate Operands - Operand를 상수로 쓰는 것.
명령어 종류가 늘어남
reg Op immd ";}i:2;i:25104;}i:518;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"=>";}i:2;i:25200;}i:519;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:62:" reg - RISC는 이거랑 위에 한 개만 가짐
mem Op immd ";}i:2;i:25202;}i:520;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"=>";}i:2;i:25264;}i:521;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:31:" mem - CICS는 이거도 포함";}i:2;i:25266;}i:522;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:25297;}i:523;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:25297;}i:524;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:188:"Unsigned / Signed Number
2의 보수 체계로 표현. 하드웨어는 모름.
leading sign bits가 0이면 양수, 1이면 음수.
부호 확장도 마찬가지로 연장시키면 된다.";}i:2;i:25299;}i:525;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:25487;}i:526;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:25487;}i:527;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:170:"Arithmetic Operations
덧셈으로 뺄셈까지 함.
대부분의 CPU ALU에는 곱셈/나눗셈하는 게이트가 없다. 필요하면 별도 하드웨어를 구성함.";}i:2;i:25489;}i:528;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:25659;}i:529;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:25659;}i:530;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:113:"Logical Operations
XOR, ORR, AND 세 개로 충분.
NOT 명령어는 -1과 XOR 시켜 주면 나타낼 수 있음";}i:2;i:25661;}i:531;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:25774;}i:532;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:25774;}i:533;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:306:"LSL은 곱하기 2한거랑 같음. 뒤에 0만 붙이면 됨.
LSR은 나누기 2한거랑 같음 0을 앞에 붙이 면서 쉬프트.
ASR은 음수인 경우 나누기 2한 것과 같게 하려면 MSB가 제자리를 돈다?
64비트 명령어 길이는 쉬프트 명령어가 7개가 필요하다. (CICS)";}i:2;i:25776;}i:534;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:26082;}i:535;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:26082;}i:536;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:786:"add des_r, src_r, immd
OP / 5비트 / 5비트 / MIPS는 16비트, ARM은 13비트 /
그럼 어떻게 immd를 최대 32비트까지 쓸 수 있을까?
먼저 immd의 상위 비트를 부호 확장하여 레지스터에 읽고 LSL시킨 다음
남은 immd 하위 비트를 읽어 먼저 읽은 레지스터와 ORR 연산 시킨다.
MIPS는 immd 길이가 16비트라 두번이면 됨.
ARM은 PC relative addressing으로 처리한다. [PC + #offset]
fixed length instruction인 RISC 프로세서는 MIPS처럼 여러번에 나눠 읽던가 ARM처럼 PC relative addressing으로 접근하던가 둘 중 하나로 immd 값에 접근한다.
하바드 아키텍처처럼 명령어와 데이터가 분리된 메모리에 저장된다면 PC relative addressing을 설계하기 복잡해진다.";}i:2;i:26084;}i:537;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:26870;}i:538;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:26870;}i:539;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:93:"두 레지스터의 값을 비교하는 명령문
제일 많이 사용하는 컨티션 코드";}i:2;i:26872;}i:540;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:26971;}i:541;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:274:"
add r3, r2, r1 // r1=1110, r2=0010
r3 = 0000
CY = 1 // 캐리 플래그
Z = 1 // 제로 플래그
S = 0 // 부호 플래그
OV = 0 // 오버플로 플래그
64비트 adder를 어떻게 만드냐면
add r4, r0, r2 (CY가 발생)
adc r5, r1, r3 (add with CY. r1+r3+CY => r5)
";i:1;N;i:2;N;}i:2;i:26971;}i:542;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:27255;}i:543;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:41:"5강 2.8 하드웨어 프로시저 지원";i:1;i:2;i:2;i:27255;}i:2;i:27255;}i:544;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:27255;}i:545;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:27255;}i:546;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:76:"27분 지각.
서브루틴을 콜하는 방법 1. 스택 포인터를 활용";}i:2;i:27309;}i:547;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:27385;}i:548;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:113:" 하셨나 보?
메모리 레이아웃부터 하고 계심
CPU에 범용 레지스터 말고 PC, SR, SP를 설명";}i:2;i:27388;}i:549;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:27501;}i:550;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:27501;}i:551;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:62:"스택 포인터 레지스터를 사용하는 명령어 소개";}i:2;i:27503;}i:552;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:27571;}i:553;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:110:"
push r1
     sp <- sp-4; 4를 감소시키는 이유는 4바이트가 1워드라서?
     (sp) <- r1;
pop r1
";i:1;N;i:2;N;}i:2;i:27571;}i:554;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:27571;}i:555;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:91:"서브루틴을 콜하는 방법 중 마지막으로 나오는게 프로시저 콜하는것";}i:2;i:27690;}i:556;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:27787;}i:557;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:62:"
Call xxx     % 메모리 쓰기
     push PC
     :pc -< xxx
";i:1;N;i:2;N;}i:2;i:27787;}i:558;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:51:"
rt               % 메모리 읽기
     : pop pc
";i:1;N;i:2;N;}i:2;i:27863;}i:559;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:27863;}i:560;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:225:"중첩된 프로시저 설명으로 이어짐
중첩된 프로시저에서 다른 프로시저를 호출하지 않는 프로시저를 leaf 노드라하고
다른 프로시저 호출하는 프로시저는 non-leaf node라 함.";}i:2;i:27923;}i:561;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:28148;}i:562;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:28148;}i:563;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:"leaf 노드인 경우";}i:2;i:28150;}i:564;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:28177;}i:565;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:26:"
ral xxx
     : pc -> lr 
";i:1;N;i:2;N;}i:2;i:28177;}i:566;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:28177;}i:567;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:226:": 프로그램 카운터를 링크 레지스터로 보내 메모리 쓰기가 아닌 레지스터 쓰기라 call 보다 속도가 더 빠름. call과 jal을 동시에 쓰는 cpu는 없음. ARM은 jal, 펜티엄은 call을 씀.";}i:2;i:28212;}i:568;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:28444;}i:569;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:18:"
rt
     : pc<-lr
";i:1;N;i:2;N;}i:2;i:28444;}i:570;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:28444;}i:571;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:79:"non-leaf 노드인 경우
컴파일러가 non-leaf 노드인지 판단했다면";}i:2;i:28472;}i:572;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:28557;}i:573;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:65:"
push lr
jal xxx 하고
pop lr 하고 적절히 복귀 한다...
";i:1;N;i:2;N;}i:2;i:28557;}i:574;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:28557;}i:575;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:"이 부분 놓침.";}i:2;i:28631;}i:576;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:28649;}i:577;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:28649;}i:578;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:28:"챕터 복습 Istruction Set";}i:2;i:28651;}i:579;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:28679;}i:580;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:28679;}i:581;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:96:"정통적인 RISC 프로세서는 처음부터 파이프라인을 지원했음
MIPS같은 것들";}i:2;i:28681;}i:582;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:28777;}i:583;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:28780;}i:584;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:28780;}i:585;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:130:"교수님 연구결과중 레지스터 개수에 따른 성능 상승폭에 간한 연구가 있다.
이걸 gcc로 하셨다는데";}i:2;i:28782;}i:586;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:28912;}i:587;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:47:" 논문 데이터베이스에 있을까? ㅋㅋ";}i:2;i:28915;}i:588;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:28962;}i:589;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:28962;}i:590;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:115:"저자가 잘못 설명한 부분 지적해주심
ARM에서 32비트 상수 어쩌고? 피피티 49페이지 내용";}i:2;i:28964;}i:591;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:29079;}i:592;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:29079;}i:593;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:124:"ARM 밖에 안쓰는 아주 잘못만든 명령어 있는데 이건 보지말라 하심. 51페이지 오른쪽 하단 내용";}i:2;i:29081;}i:594;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:29205;}i:595;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:29208;}i:596;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:4:"6강";i:1;i:2;i:2;i:29208;}i:2;i:29208;}i:597;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:29208;}i:598;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:29208;}i:599;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:"ALU 설명";}i:2;i:29225;}i:600;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:29235;}i:601;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:29235;}i:602;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:498:"먼저 덧셈 연산
풀애더 복습 Sum = A XOR B XOR Cin
리플 캐리 복습
캐리 전파 지연이 발생함. (carry propagation, carry generation이 각각 다른 게이트에서 동작함)
carry propagation은 A XOR B
따라서 Sum = cp XOR Cin으로 볼 수 있다.
carry generation은 A AND B
이를 활용하여 Carry Lookahead  adder를 설계할 수 있다.
설명 코드는 1비트 단위 조건을 활용하여 4비트 애더를 만들고 16비트 등 조합할 수 있게 하였다.";}i:2;i:29237;}i:603;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:29735;}i:604;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:759:"
module CLA4(a, b, s, cin, mcg, mcp) ;  /* 4 bit Carry Lookahead adder */
    input [3:0] a, b;
    input cin;
    output [3:0 s;
    output mcg, mcp;
    wire [3:0] cg, cp;
    wire [3:0] c;

    assign c[0] = cin,
              cg = a & b,    // A AND B
              cp = a^b,      // A XOR B
              s = cp ^ c ;

    LCG lcg0 (cg, cp, cin, c[3:1], mcg, mcp) ;
endmodule

module LCG(cg, cp, cin, c, mcg, mcp) ; /* Lookahead Carry Generator */
    input [3:0] cg, cp;
    input cin;
    output [3:1] c;
    output mcg, mcp;

    assign c[1] = cg[0] | (cp[0] & cin),
              c[2] = cg[1] | (cp[1] & cg[0]) | (cp[1] & cp[0] & cin),
              c[3] = cg[2] | (cp[2] & cg[1]) | (cp[2] & cp[1] & cg[0]) | (cp[2] & cp[1] & cp[0] & cin);
endmodule
";i:1;s:7:"verilog";i:2;N;}i:2;i:29742;}i:605;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:29742;}i:606;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:432:"리플 캐리 애더와 룩어해드 캐리 애더의 캐리 전파 지연적인 비교는
리플 캐리를 위한 게이트는 8개가 필요했다면 룩어해드 캐리는 단 두 개면 각 비트에서 필요한 캐리를 구할 수 있다.
여전히 룩어해드 캐리 애더도 가중치가 낮은 캐리가 나올 때까지 기다리긴 함. 하지만 캐리를 구하는 게이트 수가 비약적으로 줄일 수 있다.";}i:2;i:30519;}i:607;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:30951;}i:608;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:30951;}i:609;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:84:"32비트 캐리 룩어해드 애더 코드에서 오버플로 플래그를 설명함";}i:2;i:30953;}i:610;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:31043;}i:611;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:237:"
ov = (cy ^ a[31]) ^ (b[31 ^ s[31]),
/* ov = (~a[31] & ~b[31] & s[31]) || (a[31] & b[31] & ~s[31]); */
// 마이너스 둘을 더했는데 플러스가 나온 경우, 플러스 둘 더해 마이너스 나온 경우
zf = ~|s,
sf = s[31];
";i:1;s:7:"verilog";i:2;N;}i:2;i:31043;}i:612;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:1012:"
module ALU32 (a, b, s, acmd, cin, cy, ov, zf, sf);    /* 32 bit ALU */
    input [31:0] a, b;
    input cin;
    output reg [31:0] s;
    input [2:0] acmd ; /* 000 = ADD, 001 = ADC, 010 = SUB, 011 = SBC */
                               /* 100 = AND, 101 = OR, 110 = XOR, 111 = MOV (a=>s) */
    output cy, ov, zf, sf ;
    wire [31:0] bp, ar ;
    reg icin;
    wire icy;

    assign bp = b ^ {32{acmd[1]}},  // 뺄셈은 a + b의 1의 보수 + 1 한 것과 같다
              cy = acmd[1] ^ icy;          // 이 때 캐리는 인버터 시켜야 함

    always @*
        case(acmd[1:0])
            2'b00 : icin = 0;
            2'b01 : icin = cin;
            2'b10 : icin = 1;
            2'b11 : icin = ~cin;
        endcase

    always @*
        casex(acmd[1:0])
            3'b0xx : s = ar;
            3'b100 : s = a & b;
            3'b101 : s = a | b;
            3'b110 : s = a ^ b;
            3'b111 : s = a;
        endcase

    CLA32F cla32f_1 (a, bp, ar, icin, icy, ov, zf, sf);

endmodule
";i:1;s:7:"verilog";i:2;N;}i:2;i:31303;}i:613;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:32333;}i:614;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:15:"7강 Multiplier";i:1;i:2;i:2;i:32333;}i:2;i:32333;}i:615;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:32333;}i:616;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:32333;}i:617;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:40:"partial product 방식으로 곱셈 함.";}i:2;i:32361;}i:618;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:32401;}i:619;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:32401;}i:620;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:133:"하드웨어적으로는
입력: start, rst#, CLK, A[31:0], B[31:0]
출력: done, S[63:0]
Control Unit와 주고 받는 것은 A,B, S";}i:2;i:32403;}i:621;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:32536;}i:622;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:32536;}i:623;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:357:"각 비트씩 곱셈하여 쉬프트 해 가므로 32번 반복하기 위한 카운터가 필요.
이 카운터는 외부에 SM이 있어서 모든 시그널을 제어함.
SM(상태 머신)
S0 : 대기 상태
S1: start signal 입력. 초기화 상태
S2: 곱셈. 수행 상태(32번)
S3: S2에서 cnt_rp가 들어오면 done을 출력하고 S0로 돌아감.";}i:2;i:32538;}i:624;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:32895;}i:625;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:1287:"
// unsigned 32 X 32 = 64 bit serial multiplier

module SMUL32 (S, A, B, clk, rst, start, done);
    output reg [63:0] S;
    input [31:0] A, B;
    input clk, rst, start;
    output done;

    

    // mod 32 counter
    assign cnt_rst = (state == S1),
              cnt_cen = (state == S2),
              cnt_rp = &cnt_q;    // 모든 카운터 값이 1인 경우
    always @(posedge clk, posedge cnt_rst)
        if (cnt_rst) cnt_q <=0;
        else if(cnt_cne) cnt_q <= cnt_q +1;

    // shift right register (B)
    assign sft)ld = (state == S1),
              stf_en = (state == S2),
    always @(posedge clk)
        if(sft_ld) sft_q <= B;
        else if (sft_end) sft_q <= {1'b0, sft_q[31:1]};

    // partial product
    assign z = sft_q[0] ? (A+S[63:32]):{1'b0, S[63:32]};
    always @(posedge clk)
        if (state == S1) S<= 0;
        else if (state == S2) S<= {z, S[31:1]};

    // main state machine
    assign done = (state == S3);
    always @*
        case (state)
            S0 : nstate = start ? S1: S0;
            S1 : nstate = S2;
            S2 : nstate = cnt_rp ? S3: S2;
            S3 : nstate = S0;
        endcase
    always @(posedeg clk, negedeg rst)    // 플립플롭 설계
        if(!rst) state <= S0;
            else state <= nstate;

endmodule
";i:1;s:7:"verilog";i:2;N;}i:2;i:32902;}i:626;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:32902;}i:627;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:238:"곱셈기의 두 가지 문제점
1. signed number의 곱셈을 어떻게 할 것인가? Booth mod-2 32 X 32 = 64 bit serial multiplier
2. partial product를 ADD하는데 propagation delay가 발생하면 치명적이다. carry save adder";}i:2;i:34207;}i:628;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:34445;}i:629;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:34447;}i:630;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:13:"8강 Division";i:1;i:2;i:2;i:34447;}i:2;i:34447;}i:631;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:34447;}i:632;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:34447;}i:633;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:"전시간 마무리";}i:2;i:34473;}i:634;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:34492;}i:635;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:171:"
arith.hwp
signed multiplier를 위한
캐리 세이브 애더를 만들 때 부호를 표현하기 위한 리딩 사인들을 간소화 하는 부분을 설명해 주심.";}i:2;i:34495;}i:636;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:34666;}i:637;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:34666;}i:638;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:93:"faster multiplier에 저자의 설명 부분이 뭔가 착오가 있는 거 같다고 하심.";}i:2;i:34668;}i:639;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:34761;}i:640;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:34761;}i:641;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:"Division (나눗셈)";}i:2;i:34763;}i:642;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:34783;}i:643;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:34783;}i:644;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:"non-storing divide";}i:2;i:34785;}i:645;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:34803;}i:646;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:34803;}i:647;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:201:"Redundant Number Systems
각 웨이트를 꼭 양수가 아니라 일부를 음수로 표현해도 된다.
15725 = 24'3'25 = 24'3'35
이렇게 하면 캐리 지연없이 애더를 만들 수도 있다.";}i:2;i:34805;}i:648;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:35006;}i:649;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:35006;}i:650;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:261:"SRT division : non restoring division과 redundant number system을 결합하여 빠른 나눗셈을 할 수 있다.
430/12 = 430 * (1/12)로 하는데
1/12는 대략 계산한 값이다. 앞 12비트 정도만 계산한 값을 미리 구해둔 값임. (ROM에)";}i:2;i:35008;}i:651;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:35269;}i:652;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:35269;}i:653;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:228:"Floating Point 부동 소수점 연산
IEEE Std 754-1985을 기본으로 표준화 됨.
임베디드 시스템은 Single precision (C언어의 float)를 많이 사용함. 32비트
Double precision이 C언어의 double. 64비트.";}i:2;i:35271;}i:654;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:35499;}i:655;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:35499;}i:656;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:314:"Sign(부호) 1비트
Exponent: 싱글 8비트 / 더블 11비트
significand(Fraction, Mentisa): 싱글 23비트 / 더블 52비트
싱글 바이어스: 127/ 더블 바이어스: 1023
Exp와 Frac이 모두 0이면 0
Exp가 0이고 Frac이 0이 아니면 작은 수?
Exp가 0이 아니고 Frac이 0이면 무한? NaN?";}i:2;i:35501;}i:657;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:35815;}i:658;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:35815;}i:659;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:79:"학국형 프로세서 동향
EISC / 에이디칩스
SPARC / ETRI
CoreA / KAIST";}i:2;i:35817;}i:660;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:35896;}i:661;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:35896;}i:662;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:336:"수업 마치고 부채널 공격에 관해 살짝 여쭤보았다.
CPU 내부적으로 처리하는 3GHz의 파형은 외부에서 측정이 불가능하다.
이유는 CPU 외부에서 입력하려면 신호 파장 상 사라지는 길이가 되어서
항상 내부적으로 처리하므로 외부에서 볼 방법이 없다고 하심.";}i:2;i:35898;}i:663;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:36234;}i:664;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:36236;}i:665;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:51:"9강 스테이트 머신 설계로 CPU 설계하기";i:1;i:2;i:2;i:36236;}i:2;i:36236;}i:666;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:36236;}i:667;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:36236;}i:668;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:133:"마노 계열 컴퓨터구조 책들에서 다루는 CPU 설계하는 내용을 해주심. 다음 시간부터는 교재 내용대로";}i:2;i:36300;}i:669;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:36433;}i:670;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:36436;}i:671;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:36436;}i:672;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:72:"마이크로 스택이란 것도 얘기 하심.
ROM(PLA). PLA는 뭐지?";}i:2;i:36438;}i:673;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:36510;}i:674;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:36510;}i:675;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:44:"컨트롤 시그널 설명을 하고 계심.";}i:2;i:36512;}i:676;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:36556;}i:677;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:36556;}i:678;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:163:"Control Unit 만드는 두가지 방법
1. Hardwired Logic(조합회로를 이용해서)
2. Microprogramming Logic(복잡한 명령어셋을 위해, ROM에 내장)";}i:2;i:36558;}i:679;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:36721;}i:680;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:36721;}i:681;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:254:"2.1 마이크로롬이 컨트롤 시그날 되는게 수평 머신: 속도는 빠르나 롬 사이즈가 커짐.
2.2 마이크로롬이 디코딩되어 컨트롤 시그날 되는게 수직 머신: 속도는 떨어지지만 롬 사이즈가 간단해 짐.";}i:2;i:36723;}i:682;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:36977;}i:683;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:36977;}i:684;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:83:"원래 펌웨어가 마이크로롬이었다. 요즘에는 다른 뜻으로 쓰임.";}i:2;i:36979;}i:685;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:37062;}i:686;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:37064;}i:687;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:17:"10강 4장 시작";i:1;i:2;i:2;i:37064;}i:2;i:37064;}i:688;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:37064;}i:689;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:37064;}i:690;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:37:"CPU의 핵심 파트가 4~5장이다.";}i:2;i:37094;}i:691;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:37131;}i:692;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:37131;}i:693;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:118:"MIPS로 구현(32비트 레지스터가 32개)
Instruction 구조는 강의자료 23페이지 참조.
R-type 명령어";}i:2;i:37133;}i:694;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:37251;}i:695;a:3:{i:0;s:10:"listo_open";i:1;a:0:{}i:2;i:37251;}i:696;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:37251;}i:697;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37251;}i:698;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:" add rd,rs,rt : rd ";}i:2;i:37258;}i:699;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"<-";}i:2;i:37277;}i:700;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:" rs + rt";}i:2;i:37279;}i:701;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:37287;}i:702;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:37287;}i:703;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:2;}i:2;i:37287;}i:704;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37287;}i:705;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:107:" 스테이터스 플래그가 특이하게 없어 set-on-less-than 명령문이 있어 대신 작동한다.";}i:2;i:37294;}i:706;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:37401;}i:707;a:3:{i:0;s:10:"listo_open";i:1;a:0:{}i:2;i:37401;}i:708;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:5;}i:2;i:37401;}i:709;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37401;}i:710;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:" if rs<rt, rd";}i:2;i:37413;}i:711;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"<-";}i:2;i:37426;}i:712;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"올 F. else rd ";}i:2;i:37428;}i:713;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"<-";}i:2;i:37443;}i:714;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:" 올 0";}i:2;i:37445;}i:715;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:37451;}i:716;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:37451;}i:717;a:3:{i:0;s:11:"listo_close";i:1;a:0:{}i:2;i:37451;}i:718;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:37451;}i:719;a:3:{i:0;s:11:"listo_close";i:1;a:0:{}i:2;i:37451;}i:720;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:37451;}i:721;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:"Load/Store 명령어";}i:2;i:37452;}i:722;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:37472;}i:723;a:3:{i:0;s:10:"listo_open";i:1;a:0:{}i:2;i:37472;}i:724;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:37472;}i:725;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37472;}i:726;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:98:" ld rt, (rs, offset): index + (sign extention offset)에서 읽어 rt에 저장. offset이 address";}i:2;i:37479;}i:727;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:37577;}i:728;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:37577;}i:729;a:3:{i:0;s:11:"listo_close";i:1;a:0:{}i:2;i:37577;}i:730;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:37577;}i:731;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"Branch 명령어";}i:2;i:37578;}i:732;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:37594;}i:733;a:3:{i:0;s:10:"listo_open";i:1;a:0:{}i:2;i:37594;}i:734;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:37594;}i:735;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37594;}i:736;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:36:" beq rs, rt, offset : if rs==rt, pc ";}i:2;i:37601;}i:737;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"<=";}i:2;i:37637;}i:738;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:31:" pc+{ (sign extention + offset)";}i:2;i:37639;}i:739;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"<<";}i:2;i:37670;}i:740;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"2 }";}i:2;i:37672;}i:741;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:37675;}i:742;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:37675;}i:743;a:3:{i:0;s:11:"listo_close";i:1;a:0:{}i:2;i:37675;}i:744;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:37675;}i:745;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:71:"Jump 명령어: 이 명령어의 address는 절대 주소 번지이다.";}i:2;i:37676;}i:746;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:37747;}i:747;a:3:{i:0;s:10:"listo_open";i:1;a:0:{}i:2;i:37747;}i:748;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:37747;}i:749;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37747;}i:750;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:37:" 상위 4비트는 PC에서 가져옮";}i:2;i:37754;}i:751;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:37791;}i:752;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:37791;}i:753;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:2;}i:2;i:37791;}i:754;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37791;}i:755;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:54:" 26비트는 왼쪽으로 두 비트 쉬프트 시킴.";}i:2;i:37798;}i:756;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:37852;}i:757;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:37852;}i:758;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:2;}i:2;i:37852;}i:759;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37852;}i:760;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:" 밑에 00 붙여 줌.";}i:2;i:37859;}i:761;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:37881;}i:762;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:37881;}i:763;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:2;}i:2;i:37881;}i:764;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37881;}i:765;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:37:" 토탈 32비트 주소를 표현함.";}i:2;i:37888;}i:766;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:37925;}i:767;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:37925;}i:768;a:3:{i:0;s:11:"listo_close";i:1;a:0:{}i:2;i:37925;}i:769;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:37925;}i:770;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:869:"ALU는 이미 설계 해봤고, (언제?? ㄷㄷ?)
레지스터 파일을 설계하는 것을 봄.
이번에도 학생들의 verilog 이해를 위해 verilog로 설계를 해 주심.
32비트 레지스터는 로더블 플립플롭으로 설계.
이 레지스터가 32개 있으면 레지스터 파일.
wirte address, write data, write enable로 어느 레지스터에 쓸지 결정함. 해당 시그널 해당 레지스터에 연결됨.
5 to 32 디코더가 필요.
5 to 32 디코더는 2 to 4 디코더를 먼저 만들어 조합하여 사용.
read 레지스터 결정은 32 to 1 멀티플렉서가 들어감. 이게 32개 들어가야 함.
이 때 필요한 시그널이 뭐뭐 필요한지 감이 안온다면 디지털회로를 복습할 것.
MIPS는 read 레지스터가 한 명령어에 두 개씩 필요하므로 two port를 처리할 수 있게 설계해야함.";}i:2;i:37927;}i:771;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:38796;}i:772;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:38796;}i:773;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:289:"ALU는 입력포트 2개, 출력 포트 1개, function 입력 한 개가 필요.
fucntion은 어떻게 정의 되는가?
ALU operation은 add, substract, and, or, set-on-less-than를 4비트로 표현됨.
set-on-less-than 명령의 zero 출력을 위한 별도 포트가 하나 더 필요.";}i:2;i:38798;}i:774;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39087;}i:775;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39087;}i:776;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:153:"PC는 4를 더하는 로더블 어카운터룰 두거나
외부에 단순 4를 더하는 애더를 둬서 로더블 디플롭으로 설계할 수 있다.";}i:2;i:39089;}i:777;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39242;}i:778;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39242;}i:779;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:50:"Control Unit는 지난시간에 한 식으로 함.";}i:2;i:39244;}i:780;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39294;}i:781;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39294;}i:782;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:218:"브런치 명령어를 수행하는 MIPS 만의 특이한 구현이 별도의 Adder가 필요한 것.
다른 프로세서는 점프 명령문을 수행할 때 PC relative 수행이므로 ALU에서 처리를 다 해줌.";}i:2;i:39296;}i:783;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39514;}i:784;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39514;}i:785;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:432:"ALU를 제어하는 control unit는 Opcode를 읽을 6비트 입력, funct를 6비트를 읽어 ALU control 시그널 4비트를 출력한다.
ALU Opcode는 6비트를 읽어 디코드하여 ALU OP 2비트를 출력(이건 Control Unit에서 처리해줌), ALU control unit에서 이 2비트와 funct 6비트를 처리하여 4비트 컨트롤 시그널을 출력해주는 식으로 설계할 수 있다.
다르게도 할 수 있음.";}i:2;i:39516;}i:786;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39948;}i:787;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:39951;}i:788;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:35:"11강 4.5 파이브라이닝 개관";i:1;i:2;i:2;i:39951;}i:2;i:39951;}i:789;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:39951;}i:790;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39951;}i:791;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:90:"4.5 파이프라이닝 개관
초기 MIPS 파이프라인 3단계
1. IF
2. ID~EX
3. MEM~WB";}i:2;i:39999;}i:792;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:40089;}i:793;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:40089;}i:794;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:328:"요즘은 5단계가 표준처럼 잡힘
1. IF: Instruction fetch from memory (1클락 소요)
2. ID: Instruction decode & register read(RISK라 간단하므로 1클락만에 두가지 가능)
3. EX: Exceute operation or calculate address
4. MEM: Access memory operand (놀고 있으면 됨)
5. WB: Write result back to register";}i:2;i:40091;}i:795;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:40419;}i:796;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:40419;}i:797;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:658:"한 개 명령어 수행한는데 평균 600ps/inst라 가정하면 파이프라인 한 스테이지는 가장 긴 스테이지를 기준으로 해야 함. 예에서는 IF 단계가 200ps여서 한 스테이지를 200ps로 잡음. 이렇게 하면 다섯 단계 스테이지 파이프라이닝을 구현하고 성능을 테스트해보면, 열 명령어를 테스트, 첫 명령어는 1000ps, 두번째부터 200ps씩 추가되어 1000ps+9*200ps = 2,800ps걸리고 파이프라이닝을 하지 않은 6,000ps와 비교했을 때 성능 개선을 확인할 수 있다. 테스트하는 명령어의 개수가 늘어날 수록 성능 개선 효과가 커진다.";}i:2;i:40421;}i:798;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:41079;}i:799;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:41079;}i:800;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:256:"그렇다면 파이프라인 스테이지를 늘리면 더 나은 성능 개선을 볼 수 있을까? 개선 효과는 증가하지만 5 스테이지 파이프라이닝과 비교했을 때 효율이 그렇게 크지 않아 가성비가 나쁘다고 하심.";}i:2;i:41081;}i:801;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:41337;}i:802;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:41337;}i:803;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:273:"브런치 명령어에서 파이프라인 효과가 없어지는 것을 보여주시면서 브런치 명령문의 수행 확률이 10개중 6~7개 등장 한다고 하면서 이것 때문에 파이프라이닝의 효과가 생각한 것 만큼 안나온다고 설명하심.";}i:2;i:41339;}i:804;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:41612;}i:805;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:41612;}i:806;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:176:"파이프라이닝은 한 개 명령문 수행 시간(Latency)면에서는 변화가 없으나 같은 시간 동안 수행한 명령어 수는 차이가 난다.(throuwoutfoot?)";}i:2;i:41614;}i:807;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:41790;}i:808;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:41790;}i:809;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:173:"교수님 예상은 4단계가 많이 걸릴 줄 알았는데 3단계에서 오래 걸렸음. 펜티엄은 명령어 셋이 복잡하여 2단계가 두 클럭에 수행 됨.";}i:2;i:41792;}i:810;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:41965;}i:811;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:41965;}i:812;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:76:"MIPS ISA 디자인을 설명. 이렇게 설계하면 편하다하는 내용.";}i:2;i:41967;}i:813;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:42043;}i:814;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:42043;}i:815;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:388:"해저드: 파이프라이닝이 예쁘게 안 끝나게 만드는 요소들
Structure Hazard: 자원 공유 문제. oprand 메모리와 instruction 메모리를 따로 만들어야 함(하버드 아키텍처. 실제로는 물리적 메모리를 분리시키면 비용 증가로 캐시를 분리시킴). 아니면 해당 해저드를 발생시킨 명령만 정지시킴(버블 넣는다?)";}i:2;i:42045;}i:816;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:42433;}i:817;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:42433;}i:818;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:799:"Data hazard: 같은 레지스터를 참조한는 명령문이 수행될 때 이전 명령문이 마치지 않았을 때 다음 명령문이 수행 완료 되지 않은 레지스터를 참조하는 문제. 이 문제를 해결하는 가장 쉬운 방법은 컴파일러 설계 단계에서 이런 명령어가 연달아 수행되지 않도록 코드 스케쥴링을 한다. 컴파일러도 해결 할 수 없는 문제는 하드웨어에서 버블을 둠. 일반적으로는 data forwarding으로 해결 할 수 있다. 앞 명령 수행 결과(EX 뒤)를 바로 다음 명령어 단계로(EX 전) 동시에 넘겨 줄 수 있게 설계함. data forwarding으로도 해결 할 수 없는 명령어가 있는데 pipeline stoll로 일부 pipeline을 기다렸다 수행함. 
세가지 종류가 있음.";}i:2;i:42435;}i:819;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:43234;}i:820;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:43234;}i:821;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:43234;}i:822;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:43234;}i:823;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:" read after write(add ";}i:2;i:43238;}i:824;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"->";}i:2;i:43260;}i:825;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:" sub): true dependency";}i:2;i:43262;}i:826;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:43284;}i:827;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:43284;}i:828;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:43284;}i:829;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:43284;}i:830;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:62:" write after read: anti dependency - super scalar에서 발생";}i:2;i:43288;}i:831;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:43350;}i:832;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:43350;}i:833;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:43350;}i:834;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:43350;}i:835;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:65:" write after write: output dependency - super scalar에서 발생";}i:2;i:43354;}i:836;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:43419;}i:837;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:43419;}i:838;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:43419;}i:839;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:43419;}i:840;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:92:"score boarding, register renaming은 너무 어려움 나중에 super scalar 할 때 다룸.";}i:2;i:43420;}i:841;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:43512;}i:842;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:43512;}i:843;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:146:"Control hazard: 브런치 프러블럼. 제일 어려움. 파이프라인 성능 저하의 제일 원흉. 파이프라이닝의 가장 큰 이슈.";}i:2;i:43514;}i:844;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:43660;}i:845;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:43660;}i:846;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:43660;}i:847;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:43660;}i:848;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:437:" Loop buffer: 반복문에서 필요한 instruction을 fetch가 끝나고 일종의 큐에 저장해 둠. 그러다 브런치 명령문이 음수의 PC로 수행되면 그 차이와 큐 크기 조건(예를들어 16워드로 고정인듯)이 반복문이라고 판단되면 메모리에서 패치하지 않고 큐에서 패치하는 기법. 이렇게 하면 브런치 명령문 수행될 때 2단계(DI)에서 바로 수행 가능해짐.";}i:2;i:43664;}i:849;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:44101;}i:850;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:44101;}i:851;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:44101;}i:852;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:44101;}i:853;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:450:" Delayed branching: 브런치 명령문가 수행되면 DI 단계까지 읽어야 판단 가능하므로 브런치 명령문의 다음 명령문은 무조건 FI단계까지 수행하는데 이걸 버리긴 너무 아깝다. 해서 브런치 명령문 다음 명령문은 무조건 실행하는 걸로. 프로그래머가 이걸 알고 프로그래밍 하면 아무 문제 없다 하심. super scalar에서는 이게 별로 도움이 안된다 하심.";}i:2;i:44105;}i:854;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:44555;}i:855;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:44555;}i:856;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:44555;}i:857;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:44555;}i:858;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:693:" Branch prediction: DI 단계에서 브런치 명령문인지 아닌지 예측하여 미리 목적 주소를 패치하여 수행했다가 원 브런치 명령문이 끝나서 확실하게 브런치인지 알 수 있을 때 최소할지 말지 결정함. backward branches taken할 가능성이 높음. forward branches, jump overflow 이라면 non taken할 가능성이 높아 그렇게 예측함. 좀더 좋은 것은 Dynamic branch prediction은 실제로 branch가 일어나는지 봐서 결정하는 것. Branch Prediction State Diagram을 참고. 브런치 상태정보 유지는 branch history table(캐시)을 활용. non taken일 때 취소하는 것은 register renaming으로 해결.";}i:2;i:44559;}i:859;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:45252;}i:860;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:45252;}i:861;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:45252;}i:862;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:45255;}i:863;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:45255;}}