# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/activerecord/all/activerecord.rbi
#
# activerecord-2.3.18
module ActiveRecord
  def self.load_all!; end
end
module ActiveRecord::Locking
end
module ActiveRecord::ConnectionAdapters
end
class ActiveRecord::QueryCache
  def call(env); end
  def initialize(app); end
end
module ActiveRecord::QueryCache::ClassMethods
  def cache(&block); end
  def uncached(&block); end
end
class ActiveRecord::RecordInvalid < ActiveRecord::ActiveRecordError
  def initialize(record); end
  def record; end
end
class ActiveRecord::Error
  def attribute; end
  def attribute=(arg0); end
  def base; end
  def base=(arg0); end
  def default_options; end
  def full_message; end
  def generate_full_message(options = nil); end
  def generate_message(options = nil); end
  def initialize(base, attribute, type = nil, options = nil); end
  def message; end
  def message=(arg0); end
  def options; end
  def options=(arg0); end
  def to_s; end
  def type; end
  def type=(arg0); end
  def value; end
end
class ActiveRecord::Errors
  def [](attribute); end
  def add(attribute, message = nil, options = nil); end
  def add_on_blank(attributes, custom_message = nil); end
  def add_on_empty(attributes, custom_message = nil); end
  def add_to_base(msg); end
  def clear; end
  def count; end
  def each; end
  def each_error; end
  def each_full; end
  def empty?; end
  def full_messages(options = nil); end
  def generate_message(attribute, message = nil, options = nil); end
  def initialize(base); end
  def invalid?(attribute); end
  def length; end
  def on(attribute); end
  def on_base; end
  def self.default_error_messages; end
  def size; end
  def to_xml(options = nil); end
  include Enumerable
end
module ActiveRecord::Validations
  def errors; end
  def invalid?; end
  def save_with_validation!; end
  def save_with_validation(perform_validation = nil); end
  def self.included(base); end
  def valid?; end
  def validate; end
  def validate_on_create; end
  def validate_on_update; end
end
module ActiveRecord::Validations::ClassMethods
  def create!(attributes = nil, &block); end
  def validates_acceptance_of(*attr_names); end
  def validates_associated(*attr_names); end
  def validates_confirmation_of(*attr_names); end
  def validates_each(*attrs); end
  def validates_exclusion_of(*attr_names); end
  def validates_format_of(*attr_names); end
  def validates_inclusion_of(*attr_names); end
  def validates_length_of(*attrs); end
  def validates_numericality_of(*attr_names); end
  def validates_presence_of(*attr_names); end
  def validates_size_of(*attrs); end
  def validates_uniqueness_of(*attr_names); end
  def validation_method(on); end
end
module ActiveRecord::Locking::Optimistic
  def attributes_from_column_definition_with_lock; end
  def destroy_with_lock; end
  def locking_enabled?; end
  def self.included(base); end
  def update_with_lock(attribute_names = nil); end
end
module ActiveRecord::Locking::Optimistic::ClassMethods
  def locking_column; end
  def locking_enabled?; end
  def quoted_locking_column; end
  def reset_locking_column; end
  def self.extended(base); end
  def set_locking_column(value = nil, &block); end
  def update_counters_with_lock(id, counters); end
end
module ActiveRecord::Locking::Pessimistic
  def lock!(lock = nil); end
end
module ActiveRecord::AttributeMethods
  def attribute=(attribute_name, value); end
  def attribute?(attribute_name); end
  def attribute_before_type_cast(attribute_name); end
  def method_missing(method_id, *args, &block); end
  def missing_attribute(attr_name, stack); end
  def query_attribute(attr_name); end
  def read_attribute(attr_name); end
  def read_attribute_before_type_cast(attr_name); end
  def respond_to?(method, include_private_methods = nil); end
  def respond_to_without_attributes?(*arg0); end
  def self.included(base); end
  def unserializable_attribute?(attr_name, column); end
  def unserialize_attribute(attr_name); end
  def write_attribute(attr_name, value); end
end
module ActiveRecord::AttributeMethods::ClassMethods
  def attribute_method_suffix(*suffixes); end
  def attribute_method_suffixes; end
  def cache_attribute?(attr_name); end
  def cache_attributes(*attribute_names); end
  def cached_attributes; end
  def create_time_zone_conversion_attribute?(name, column); end
  def define_attribute_methods; end
  def define_question_method(attr_name); end
  def define_read_method(symbol, attr_name, column); end
  def define_read_method_for_serialized_attribute(attr_name); end
  def define_read_method_for_time_zone_conversion(attr_name); end
  def define_read_methods; end
  def define_write_method(attr_name); end
  def define_write_method_for_serialized_attribute(attr_name); end
  def define_write_method_for_time_zone_conversion(attr_name); end
  def evaluate_attribute_method(attr_name, method_definition, method_name = nil); end
  def generated_methods; end
  def generated_methods?; end
  def instance_method_already_implemented?(method_name); end
  def match_attribute_method?(method_name); end
  def rebuild_attribute_method_regexp; end
end
module ActiveRecord::Dirty
  def attribute_change(attr); end
  def attribute_changed?(attr); end
  def attribute_was(attr); end
  def attribute_will_change!(attr); end
  def changed; end
  def changed?; end
  def changed_attributes; end
  def changes; end
  def field_changed?(attr, old, value); end
  def reload_with_dirty(*args); end
  def save_with_dirty!(*args); end
  def save_with_dirty(*args); end
  def self.included(base); end
  def update_with_dirty; end
  def write_attribute_with_dirty(attr, value); end
end
module ActiveRecord::Dirty::ClassMethods
  def alias_attribute_with_dirty(new_name, old_name); end
  def self.extended(base); end
end
module ActiveRecord::Callbacks
  def after_create; end
  def after_destroy; end
  def after_save; end
  def after_update; end
  def after_validation; end
  def after_validation_on_create; end
  def after_validation_on_update; end
  def before_create; end
  def before_destroy; end
  def before_save; end
  def before_update; end
  def before_validation; end
  def before_validation_on_create; end
  def before_validation_on_update; end
  def callback(method); end
  def create_or_update_with_callbacks; end
  def create_with_callbacks; end
  def destroy_with_callbacks; end
  def notify(method); end
  def self.included(base); end
  def update_with_callbacks(*args); end
  def valid_with_callbacks?; end
end
module ActiveRecord::Observing
  def self.included(base); end
end
module ActiveRecord::Observing::ClassMethods
  def inherited(subclass); end
  def instantiate_observers; end
  def observers; end
  def observers=(*observers); end
end
class ActiveRecord::Observer
  def add_observer!(klass); end
  def initialize; end
  def observed_class_inherited(subclass); end
  def observed_classes; end
  def observed_subclasses; end
  def self.allocate; end
  def self.instance; end
  def self.new(*arg0); end
  def self.observe(*models); end
  def self.observed_class; end
  def update(observed_method, object); end
  extend Singleton::SingletonClassMethods
  include Singleton
end
module ActiveRecord::Timestamp
  def create_with_timestamps; end
  def current_time_from_proper_timezone; end
  def self.included(base); end
  def touch(attribute = nil); end
  def update_with_timestamps(*args); end
end
class ActiveRecord::InverseOfAssociationNotFoundError < ActiveRecord::ActiveRecordError
  def initialize(reflection, associated_class = nil); end
end
class ActiveRecord::HasManyThroughAssociationNotFoundError < ActiveRecord::ActiveRecordError
  def initialize(owner_class_name, reflection); end
end
class ActiveRecord::HasManyThroughAssociationPolymorphicError < ActiveRecord::ActiveRecordError
  def initialize(owner_class_name, reflection, source_reflection); end
end
class ActiveRecord::HasManyThroughAssociationPointlessSourceTypeError < ActiveRecord::ActiveRecordError
  def initialize(owner_class_name, reflection, source_reflection); end
end
class ActiveRecord::HasManyThroughSourceAssociationNotFoundError < ActiveRecord::ActiveRecordError
  def initialize(reflection); end
end
class ActiveRecord::HasManyThroughSourceAssociationMacroError < ActiveRecord::ActiveRecordError
  def initialize(reflection); end
end
class ActiveRecord::HasManyThroughCantAssociateThroughHasOneOrManyReflection < ActiveRecord::ActiveRecordError
  def initialize(owner, reflection); end
end
class ActiveRecord::HasManyThroughCantAssociateNewRecords < ActiveRecord::ActiveRecordError
  def initialize(owner, reflection); end
end
class ActiveRecord::HasManyThroughCantDissociateNewRecords < ActiveRecord::ActiveRecordError
  def initialize(owner, reflection); end
end
class ActiveRecord::HasAndBelongsToManyAssociationForeignKeyNeeded < ActiveRecord::ActiveRecordError
  def initialize(reflection); end
end
class ActiveRecord::EagerLoadPolymorphicError < ActiveRecord::ActiveRecordError
  def initialize(reflection); end
end
class ActiveRecord::ReadOnlyAssociation < ActiveRecord::ActiveRecordError
  def initialize(reflection); end
end
module ActiveRecord::Associations
  def association_instance_get(name); end
  def association_instance_set(name, association); end
  def clear_association_cache; end
  def self.included(base); end
end
module ActiveRecord::Associations::ClassMethods
  def add_association_callbacks(association_name, options); end
  def add_counter_cache_callbacks(reflection); end
  def add_limited_ids_condition!(sql, options, join_dependency); end
  def add_touch_callbacks(reflection, touch_attribute); end
  def association_accessor_methods(reflection, association_proxy_class); end
  def association_constructor_method(constructor, reflection, association_proxy_class); end
  def belongs_to(association_id, options = nil); end
  def collection_accessor_methods(reflection, association_proxy_class, writer = nil); end
  def collection_reader_method(reflection, association_proxy_class); end
  def column_aliases(join_dependency); end
  def condition_word(sql); end
  def conditions_tables(options); end
  def configure_dependency_for_belongs_to(reflection); end
  def configure_dependency_for_has_many(reflection, extra_conditions = nil); end
  def configure_dependency_for_has_one(reflection); end
  def construct_finder_sql_for_association_limiting(options, join_dependency); end
  def construct_finder_sql_with_included_associations(options, join_dependency); end
  def create_belongs_to_reflection(association_id, options); end
  def create_extension_modules(association_id, block_extension, extensions); end
  def create_has_and_belongs_to_many_reflection(association_id, options, &extension); end
  def create_has_many_reflection(association_id, options, &extension); end
  def create_has_one_reflection(association_id, options); end
  def create_has_one_through_reflection(association_id, options); end
  def delete_all_has_many_dependencies(record, reflection_name, association_class, dependent_conditions); end
  def find_with_associations(options = nil); end
  def guard_against_unlimitable_reflections(reflections, options); end
  def has_and_belongs_to_many(association_id, options = nil, &extension); end
  def has_many(association_id, options = nil, &extension); end
  def has_one(association_id, options = nil); end
  def include_eager_conditions?(options, tables = nil, joined_tables = nil); end
  def include_eager_order?(options, tables = nil, joined_tables = nil); end
  def include_eager_select?(options, joined_tables = nil); end
  def join_table_name(first_table_name, second_table_name); end
  def joined_tables(options); end
  def nullify_has_many_dependencies(record, reflection_name, association_class, primary_key_name, dependent_conditions); end
  def order_tables(options); end
  def references_eager_loaded_tables?(options); end
  def reflect_on_included_associations(associations); end
  def select_all_rows(options, join_dependency); end
  def select_limited_ids_list(options, join_dependency); end
  def selects_tables(options); end
  def self.valid_keys_for_belongs_to_association; end
  def self.valid_keys_for_belongs_to_association=(obj); end
  def self.valid_keys_for_has_and_belongs_to_many_association; end
  def self.valid_keys_for_has_and_belongs_to_many_association=(obj); end
  def self.valid_keys_for_has_many_association; end
  def self.valid_keys_for_has_many_association=(obj); end
  def self.valid_keys_for_has_one_association; end
  def self.valid_keys_for_has_one_association=(obj); end
  def tables_in_hash(hash); end
  def tables_in_string(string); end
  def using_limitable_reflections?(reflections); end
  def valid_keys_for_belongs_to_association; end
  def valid_keys_for_belongs_to_association=(obj); end
  def valid_keys_for_has_and_belongs_to_many_association; end
  def valid_keys_for_has_and_belongs_to_many_association=(obj); end
  def valid_keys_for_has_many_association; end
  def valid_keys_for_has_many_association=(obj); end
  def valid_keys_for_has_one_association; end
  def valid_keys_for_has_one_association=(obj); end
end
class ActiveRecord::Associations::ClassMethods::JoinDependency
  def build(associations, parent = nil); end
  def build_join_association(reflection, parent); end
  def construct(parent, associations, joins, row); end
  def construct_association(record, join, row); end
  def initialize(base, associations, joins); end
  def instantiate(rows); end
  def join_associations; end
  def join_base; end
  def join_for_table_name(table_name); end
  def joins; end
  def joins_for_table_name(table_name); end
  def reflections; end
  def remove_duplicate_results!(base, records, associations); end
  def set_target_and_inverse(join, association, record); end
  def table_aliases; end
end
class ActiveRecord::Associations::ClassMethods::JoinDependency::JoinBase
  def active_record; end
  def aliased_prefix; end
  def aliased_primary_key; end
  def aliased_table_name; end
  def column_names(*args, &block); end
  def column_names_with_alias; end
  def extract_record(row); end
  def initialize(active_record, joins = nil); end
  def instantiate(row); end
  def primary_key(*args, &block); end
  def record_id(row); end
  def reflections(*args, &block); end
  def sanitize_sql(*args, &block); end
  def table_joins; end
  def table_name(*args, &block); end
end
class ActiveRecord::Associations::ClassMethods::JoinDependency::JoinAssociation < ActiveRecord::Associations::ClassMethods::JoinDependency::JoinBase
  def aliased_join_table_name; end
  def aliased_prefix; end
  def aliased_table_name; end
  def aliased_table_name_for(name, suffix = nil); end
  def association_join; end
  def initialize(reflection, join_dependency, parent = nil); end
  def interpolate_sql(sql); end
  def join_type; end
  def klass(*args, &block); end
  def options(*args, &block); end
  def parent; end
  def parent_table_name; end
  def pluralize(table_name); end
  def reflection; end
  def source_reflection(*args, &block); end
  def table_alias_for(table_name, table_alias); end
  def table_name_and_alias; end
  def through_reflection(*args, &block); end
end
class ActiveRecord::Associations::ClassMethods::InnerJoinDependency < ActiveRecord::Associations::ClassMethods::JoinDependency
  def build_join_association(reflection, parent); end
end
class ActiveRecord::Associations::ClassMethods::InnerJoinDependency::InnerJoinAssociation < ActiveRecord::Associations::ClassMethods::JoinDependency::JoinAssociation
  def join_type; end
end
module ActiveRecord::AssociationPreload
  def self.included(base); end
end
module ActiveRecord::AssociationPreload::ClassMethods
  def add_preloaded_record_to_collection(parent_records, reflection_name, associated_record); end
  def add_preloaded_records_to_collection(parent_records, reflection_name, associated_record); end
  def append_conditions(reflection, preload_options); end
  def construct_id_map(records, primary_key = nil); end
  def find_associated_records(ids, reflection, preload_options); end
  def in_or_equals_for_ids(ids); end
  def interpolate_sql_for_preload(sql); end
  def preload_associations(records, associations, preload_options = nil); end
  def preload_belongs_to_association(records, reflection, preload_options = nil); end
  def preload_has_and_belongs_to_many_association(records, reflection, preload_options = nil); end
  def preload_has_many_association(records, reflection, preload_options = nil); end
  def preload_has_one_association(records, reflection, preload_options = nil); end
  def preload_one_association(records, association, preload_options = nil); end
  def preload_through_records(records, reflection, through_association); end
  def set_association_collection_records(id_to_record_map, reflection_name, associated_records, key); end
  def set_association_single_records(id_to_record_map, reflection_name, associated_records, key); end
end
module ActiveRecord::NamedScope
  def self.included(base); end
end
module ActiveRecord::NamedScope::ClassMethods
  def named_scope(name, options = nil, &block); end
  def scoped(scope, &block); end
  def scopes; end
end
class ActiveRecord::NamedScope::Scope
  def !(*args, &block); end
  def !=(*args, &block); end
  def !~(*args, &block); end
  def &(*args, &block); end
  def *(*args, &block); end
  def +(*args, &block); end
  def -(*args, &block); end
  def <<(*args, &block); end
  def <=>(*args, &block); end
  def ==(*args, &block); end
  def ===(*args, &block); end
  def =~(*args, &block); end
  def [](*args, &block); end
  def []=(*args, &block); end
  def `(*args, &block); end
  def acts_like?(*args, &block); end
  def all?(*args, &block); end
  def any?; end
  def as_json(*args, &block); end
  def assoc(*args, &block); end
  def at(*args, &block); end
  def at_exit(*args, &block); end
  def blank?(*args, &block); end
  def breakpoint(*args, &block); end
  def bsearch(*args, &block); end
  def bsearch_index(*args, &block); end
  def chunk(*args, &block); end
  def chunk_while(*args, &block); end
  def class_eval(*args, &block); end
  def clear(*args, &block); end
  def clone(*args, &block); end
  def collect!(*args, &block); end
  def collect(*args, &block); end
  def collect_concat(*args, &block); end
  def combination(*args, &block); end
  def compact!(*args, &block); end
  def compact(*args, &block); end
  def concat(*args, &block); end
  def copy_instance_variables_from(*args, &block); end
  def current_scoped_methods_when_defined; end
  def cycle(*args, &block); end
  def daemonize(*args, &block); end
  def debugger(*args, &block); end
  def define_singleton_method(*args, &block); end
  def delete(*args, &block); end
  def delete_at(*args, &block); end
  def delete_if(*args, &block); end
  def detect(*args, &block); end
  def dig(*args, &block); end
  def display(*args, &block); end
  def drop(*args, &block); end
  def drop_while(*args, &block); end
  def dup(*args, &block); end
  def duplicable?(*args, &block); end
  def each(*args, &block); end
  def each_cons(*args, &block); end
  def each_entry(*args, &block); end
  def each_index(*args, &block); end
  def each_slice(*args, &block); end
  def each_with_index(*args, &block); end
  def each_with_object(*args, &block); end
  def empty?; end
  def enable_warnings(*args, &block); end
  def entries(*args, &block); end
  def enum_for(*args, &block); end
  def eql?(*args, &block); end
  def equal?(*args, &block); end
  def exclude?(*args, &block); end
  def exit(*args, &block); end
  def extend_with_included_modules_from(*args, &block); end
  def extended_by(*args, &block); end
  def extract_options!(*args, &block); end
  def fetch(*args, &block); end
  def fifth(*args, &block); end
  def fill(*args, &block); end
  def find_all(*args, &block); end
  def find_index(*args, &block); end
  def first(*args); end
  def flat_map(*args, &block); end
  def flatten!(*args, &block); end
  def flatten(*args, &block); end
  def forty_two(*args, &block); end
  def fourth(*args, &block); end
  def freeze(*args, &block); end
  def from(*args, &block); end
  def frozen?(*args, &block); end
  def gem(*args, &block); end
  def grep(*args, &block); end
  def grep_v(*args, &block); end
  def group_by(*args, &block); end
  def hash(*args, &block); end
  def html_safe?(*args, &block); end
  def in_groups(*args, &block); end
  def in_groups_of(*args, &block); end
  def include?(*args, &block); end
  def include_method?(*args, &block); end
  def index(*args, &block); end
  def index_by(*args, &block); end
  def initialize(proxy_scope, options, &block); end
  def inject(*args, &block); end
  def insert(*args, &block); end
  def inspect(*args, &block); end
  def instance_eval(*args, &block); end
  def instance_exec(*args, &block); end
  def instance_of?(*args, &block); end
  def instance_values(*args, &block); end
  def instance_variable_defined?(*args, &block); end
  def instance_variable_get(*args, &block); end
  def instance_variable_names(*args, &block); end
  def instance_variable_set(*args, &block); end
  def instance_variables(*args, &block); end
  def is_a?(*args, &block); end
  def itself(*args, &block); end
  def join(*args, &block); end
  def keep_if(*args, &block); end
  def kind_of?(*args, &block); end
  def last(*args); end
  def lazy(*args, &block); end
  def length(*args, &block); end
  def load_found; end
  def load_with_new_constant_marking(*args, &block); end
  def many?(*args, &block); end
  def map!(*args, &block); end
  def map(*args, &block); end
  def max(*args, &block); end
  def max_by(*args, &block); end
  def member?(*args, &block); end
  def metaclass(*args, &block); end
  def metaclass_with_deprecation(*args, &block); end
  def metaclass_without_deprecation(*args, &block); end
  def method(*args, &block); end
  def method_missing(method, *args, &block); end
  def methods(*args, &block); end
  def min(*args, &block); end
  def min_by(*args, &block); end
  def minmax(*args, &block); end
  def minmax_by(*args, &block); end
  def none?(*args, &block); end
  def one?(*args, &block); end
  def pack(*args, &block); end
  def partition(*args, &block); end
  def permutation(*args, &block); end
  def pop(*args, &block); end
  def presence(*args, &block); end
  def present?(*args, &block); end
  def private_methods(*args, &block); end
  def product(*args, &block); end
  def protected_methods(*args, &block); end
  def proxy_found; end
  def proxy_options; end
  def proxy_scope; end
  def psych_to_yaml(*args, &block); end
  def public_method(*args, &block); end
  def public_methods(*args, &block); end
  def public_send(*args, &block); end
  def push(*args, &block); end
  def rand(*args, &block); end
  def random_element(*args, &block); end
  def rassoc(*args, &block); end
  def reduce(*args, &block); end
  def reject!(*args, &block); end
  def reject(*args, &block); end
  def reload; end
  def remove_instance_variable(*args, &block); end
  def remove_subclasses_of(*args, &block); end
  def repeated_combination(*args, &block); end
  def repeated_permutation(*args, &block); end
  def replace(*args, &block); end
  def require(*args, &block); end
  def require_association(*args, &block); end
  def require_dependency(*args, &block); end
  def require_library_or_gem(*args, &block); end
  def require_or_load(*args, &block); end
  def respond_to?(method, include_private = nil); end
  def returning(*args, &block); end
  def reverse!(*args, &block); end
  def reverse(*args, &block); end
  def reverse_each(*args, &block); end
  def rindex(*args, &block); end
  def rotate!(*args, &block); end
  def rotate(*args, &block); end
  def sample(*args, &block); end
  def scoped_methods(*args, &block); end
  def scopes(*args, &block); end
  def second(*args, &block); end
  def select!(*args, &block); end
  def select(*args, &block); end
  def shelljoin(*args, &block); end
  def shift(*args, &block); end
  def shuffle!(*args, &block); end
  def shuffle(*args, &block); end
  def silence_stderr(*args, &block); end
  def silence_stream(*args, &block); end
  def silence_warnings(*args, &block); end
  def singleton_class(*args, &block); end
  def singleton_method(*args, &block); end
  def singleton_methods(*args, &block); end
  def size; end
  def slice!(*args, &block); end
  def slice(*args, &block); end
  def slice_after(*args, &block); end
  def slice_before(*args, &block); end
  def slice_when(*args, &block); end
  def sort!(*args, &block); end
  def sort(*args, &block); end
  def sort_by!(*args, &block); end
  def sort_by(*args, &block); end
  def split(*args, &block); end
  def subclasses_of(*args, &block); end
  def suppress(*args, &block); end
  def taint(*args, &block); end
  def tainted?(*args, &block); end
  def take(*args, &block); end
  def take_while(*args, &block); end
  def tap(*args, &block); end
  def third(*args, &block); end
  def to(*args, &block); end
  def to_a(*args, &block); end
  def to_ary(*args, &block); end
  def to_default_s(*args, &block); end
  def to_enum(*args, &block); end
  def to_formatted_s(*args, &block); end
  def to_h(*args, &block); end
  def to_json(*args, &block); end
  def to_param(*args, &block); end
  def to_query(*args, &block); end
  def to_s(*args, &block); end
  def to_sentence(*args, &block); end
  def to_set(*args, &block); end
  def to_xml(*args, &block); end
  def to_yaml(*args, &block); end
  def to_yaml_properties(*args, &block); end
  def transpose(*args, &block); end
  def trust(*args, &block); end
  def try(*args, &block); end
  def uniq!(*args, &block); end
  def uniq(*args, &block); end
  def unloadable(*args, &block); end
  def unshift(*args, &block); end
  def untaint(*args, &block); end
  def untrust(*args, &block); end
  def untrusted?(*args, &block); end
  def values_at(*args, &block); end
  def with_options(*args, &block); end
  def with_scope(*args, &block); end
  def zip(*args, &block); end
  def |(*args, &block); end
end
module ActiveRecord::AutosaveAssociation
  def associated_records_to_validate_or_save(association, new_record, autosave); end
  def association_valid?(reflection, association); end
  def before_save_collection_association; end
  def changed_for_autosave?; end
  def mark_for_destruction; end
  def marked_for_destruction?; end
  def nested_records_changed_for_autosave?; end
  def reload_with_autosave_associations(options = nil); end
  def save_belongs_to_association(reflection); end
  def save_collection_association(reflection); end
  def save_has_one_association(reflection); end
  def self.included(base); end
  def validate_collection_association(reflection); end
  def validate_single_association(reflection); end
end
module ActiveRecord::AutosaveAssociation::ClassMethods
  def add_autosave_association_callbacks(reflection); end
  def belongs_to(name, options = nil); end
  def has_and_belongs_to_many(name, options = nil); end
  def has_many(name, options = nil); end
  def has_one(name, options = nil); end
end
module ActiveRecord::NestedAttributes
  def _destroy; end
  def assign_nested_attributes_for_collection_association(association_name, attributes_collection); end
  def assign_nested_attributes_for_one_to_one_association(association_name, attributes); end
  def assign_to_or_mark_for_destruction(record, attributes, allow_destroy); end
  def call_reject_if(association_name, attributes); end
  def has_destroy_flag?(hash); end
  def raise_nested_attributes_record_not_found(association_name, record_id); end
  def reject_new_record?(association_name, attributes); end
  def self.included(base); end
end
class ActiveRecord::NestedAttributes::TooManyRecords < ActiveRecord::ActiveRecordError
end
module ActiveRecord::NestedAttributes::ClassMethods
  def accepts_nested_attributes_for(*attr_names); end
end
module ActiveRecord::Aggregations
  def clear_aggregation_cache; end
  def self.included(base); end
end
module ActiveRecord::Aggregations::ClassMethods
  def composed_of(part_id, options = nil, &block); end
  def reader_method(name, class_name, mapping, allow_nil, constructor); end
  def writer_method(name, class_name, mapping, allow_nil, converter); end
end
module ActiveRecord::Transactions
  def destroy_with_transactions; end
  def rollback_active_record_state!; end
  def save_with_transactions!; end
  def save_with_transactions(perform_validation = nil); end
  def self.included(base); end
  def transaction(&block); end
  def with_transaction_returning_status(method, *args); end
end
class ActiveRecord::Transactions::TransactionError < ActiveRecord::ActiveRecordError
end
module ActiveRecord::Transactions::ClassMethods
  def transaction(options = nil, &block); end
end
module ActiveRecord::Reflection
  def self.included(base); end
end
module ActiveRecord::Reflection::ClassMethods
  def create_reflection(macro, name, options, active_record); end
  def reflect_on_aggregation(aggregation); end
  def reflect_on_all_aggregations; end
  def reflect_on_all_associations(macro = nil); end
  def reflect_on_all_autosave_associations; end
  def reflect_on_association(association); end
  def reflections; end
end
class ActiveRecord::Reflection::MacroReflection
  def ==(other_aggregation); end
  def active_record; end
  def belongs_to?; end
  def class_name; end
  def derive_class_name; end
  def initialize(macro, name, options, active_record); end
  def klass; end
  def macro; end
  def name; end
  def options; end
  def sanitized_conditions; end
end
class ActiveRecord::Reflection::AggregateReflection < ActiveRecord::Reflection::MacroReflection
end
class ActiveRecord::Reflection::AssociationReflection < ActiveRecord::Reflection::MacroReflection
  def association_foreign_key; end
  def build_association(*options); end
  def check_validity!; end
  def check_validity_of_inverse!; end
  def collection?; end
  def columns(tbl_name, log_msg); end
  def counter_cache_column; end
  def create_association!(*options); end
  def create_association(*options); end
  def dependent_conditions(record, base_class, extra_conditions); end
  def derive_class_name; end
  def derive_primary_key_name; end
  def has_inverse?; end
  def inverse_of; end
  def klass; end
  def polymorphic_inverse_of(associated_class); end
  def primary_key_name; end
  def quoted_table_name; end
  def reset_column_information; end
  def source_reflection; end
  def table_name; end
  def through_reflection; end
  def through_reflection_primary_key_name; end
  def validate?; end
end
class ActiveRecord::Reflection::ThroughReflection < ActiveRecord::Reflection::AssociationReflection
  def check_validity!; end
  def derive_class_name; end
  def source_reflection; end
  def source_reflection_names; end
  def through_reflection; end
  def through_reflection_primary_key; end
  def through_reflection_primary_key_name; end
end
module ActiveRecord::Batches
  def self.included(base); end
end
module ActiveRecord::Batches::ClassMethods
  def batch_order; end
  def find_each(options = nil); end
  def find_in_batches(options = nil); end
end
module ActiveRecord::Calculations
  def self.included(base); end
end
module ActiveRecord::Calculations::ClassMethods
  def average(column_name, options = nil); end
  def calculate(operation, column_name, options = nil); end
  def column_alias_for(*keys); end
  def column_for(field); end
  def construct_calculation_sql(operation, column_name, options); end
  def construct_count_options_from_args(*args); end
  def count(*args); end
  def execute_grouped_calculation(operation, column_name, column, options); end
  def execute_simple_calculation(operation, column_name, column, options); end
  def maximum(column_name, options = nil); end
  def minimum(column_name, options = nil); end
  def sum(column_name, options = nil); end
  def type_cast_calculated_value(value, column, operation = nil); end
  def type_cast_using_column(value, column); end
  def validate_calculation_options(operation, options = nil); end
end
module ActiveRecord::Serialization
  def as_json(options = nil); end
  def from_json(json); end
  def from_xml(xml); end
  def self.included(base); end
  def to_json(options = nil); end
  def to_xml(options = nil, &block); end
end
class ActiveRecord::XmlSerializer < ActiveRecord::Serialization::Serializer
  def add_associations(association, records, opts); end
  def add_attributes; end
  def add_procs; end
  def add_tag(attribute); end
  def builder; end
  def camelize?; end
  def dasherize?; end
  def reformat_name(name); end
  def root; end
  def serializable_attributes; end
  def serializable_method_attributes; end
  def serialize; end
end
class ActiveRecord::XmlSerializer::Attribute
  def compute_type; end
  def compute_value; end
  def decorations(include_types = nil); end
  def initialize(name, record); end
  def name; end
  def needs_encoding?; end
  def type; end
  def value; end
end
class ActiveRecord::XmlSerializer::MethodAttribute < ActiveRecord::XmlSerializer::Attribute
  def compute_type; end
end
class ActiveRecord::Serialization::Serializer
  def add_includes(&block); end
  def initialize(record, options = nil); end
  def options; end
  def serializable_attribute_names; end
  def serializable_method_names; end
  def serializable_names; end
  def serializable_record; end
  def serialize; end
  def to_s(&block); end
end
class ActiveRecord::ConnectionAdapters::Column
  def default; end
  def extract_default(default); end
  def extract_limit(sql_type); end
  def extract_precision(sql_type); end
  def extract_scale(sql_type); end
  def has_default?; end
  def human_name; end
  def initialize(name, default, sql_type = nil, null = nil); end
  def klass; end
  def limit; end
  def name; end
  def null; end
  def number?; end
  def precision; end
  def primary; end
  def primary=(arg0); end
  def scale; end
  def self.binary_to_string(value); end
  def self.fallback_string_to_date(string); end
  def self.fallback_string_to_time(string); end
  def self.fast_string_to_date(string); end
  def self.fast_string_to_time(string); end
  def self.microseconds(time); end
  def self.new_date(year, mon, mday); end
  def self.new_time(year, mon, mday, hour, min, sec, microsec); end
  def self.string_to_binary(value); end
  def self.string_to_date(string); end
  def self.string_to_dummy_time(string); end
  def self.string_to_time(string); end
  def self.value_to_boolean(value); end
  def self.value_to_decimal(value); end
  def simplified_type(field_type); end
  def sql_type; end
  def text?; end
  def type; end
  def type_cast(value); end
  def type_cast_code(var_name); end
end
module ActiveRecord::ConnectionAdapters::Column::Format
end
class Anonymous_Struct_1 < Struct
  def columns; end
  def columns=(_); end
  def lengths; end
  def lengths=(_); end
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.members; end
  def self.new(*arg0); end
  def table; end
  def table=(_); end
  def unique; end
  def unique=(_); end
end
class ActiveRecord::ConnectionAdapters::IndexDefinition < Anonymous_Struct_1
end
class Anonymous_Struct_2 < Struct
  def base; end
  def base=(_); end
  def default; end
  def default=(_); end
  def limit; end
  def limit=(_); end
  def name; end
  def name=(_); end
  def null; end
  def null=(_); end
  def precision; end
  def precision=(_); end
  def scale; end
  def scale=(_); end
  def self.[](*arg0); end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
end
class ActiveRecord::ConnectionAdapters::ColumnDefinition < Anonymous_Struct_2
  def add_column_options!(sql, options); end
  def sql_type; end
  def to_sql; end
end
class ActiveRecord::ConnectionAdapters::TableDefinition
  def [](name); end
  def belongs_to(*args); end
  def binary(*args); end
  def boolean(*args); end
  def column(name, type, options = nil); end
  def columns; end
  def columns=(arg0); end
  def date(*args); end
  def datetime(*args); end
  def decimal(*args); end
  def float(*args); end
  def initialize(base); end
  def integer(*args); end
  def method_missing(symbol, *args); end
  def native; end
  def primary_key(name); end
  def references(*args); end
  def string(*args); end
  def text(*args); end
  def time(*args); end
  def timestamp(*args); end
  def timestamps(*args); end
  def to_sql; end
  def xml_column_fallback(*args); end
end
class ActiveRecord::ConnectionAdapters::Table
  def belongs_to(*args); end
  def binary(*args); end
  def boolean(*args); end
  def change(column_name, type, options = nil); end
  def change_default(column_name, default); end
  def column(column_name, type, options = nil); end
  def date(*args); end
  def datetime(*args); end
  def decimal(*args); end
  def float(*args); end
  def index(column_name, options = nil); end
  def initialize(table_name, base); end
  def integer(*args); end
  def native; end
  def references(*args); end
  def remove(*column_names); end
  def remove_belongs_to(*args); end
  def remove_index(options = nil); end
  def remove_references(*args); end
  def remove_timestamps; end
  def rename(column_name, new_column_name); end
  def string(*args); end
  def text(*args); end
  def time(*args); end
  def timestamp(*args); end
  def timestamps; end
end
module ActiveRecord::ConnectionAdapters::SchemaStatements
  def add_column(table_name, column_name, type, options = nil); end
  def add_column_options!(sql, options); end
  def add_index(table_name, column_name, options = nil); end
  def add_order_by_for_association_limiting!(sql, options); end
  def add_timestamps(table_name); end
  def assume_migrated_upto_version(version, migrations_path = nil); end
  def change_column(table_name, column_name, type, options = nil); end
  def change_column_default(table_name, column_name, default); end
  def change_table(table_name); end
  def columns(table_name, name = nil); end
  def create_table(table_name, options = nil); end
  def distinct(columns, order_by); end
  def drop_table(table_name, options = nil); end
  def dump_schema_information; end
  def index_exists?(table_name, index_name, default); end
  def index_name(table_name, options); end
  def initialize_schema_migrations_table; end
  def native_database_types; end
  def options_include_default?(options); end
  def quoted_columns_for_index(column_names, options = nil); end
  def remove_column(table_name, *column_names); end
  def remove_columns(table_name, *column_names); end
  def remove_index!(table_name, index_name); end
  def remove_index(table_name, options = nil); end
  def remove_timestamps(table_name); end
  def rename_column(table_name, column_name, new_column_name); end
  def rename_index(table_name, old_name, new_name); end
  def rename_table(table_name, new_name); end
  def structure_dump; end
  def table_alias_for(table_name); end
  def table_exists?(table_name); end
  def type_to_sql(type, limit = nil, precision = nil, scale = nil); end
end
module ActiveRecord::ConnectionAdapters::DatabaseStatements
  def add_limit!(sql, options); end
  def add_limit_offset!(sql, options); end
  def add_lock!(sql, options); end
  def begin_db_transaction; end
  def case_sensitive_equality_operator; end
  def commit_db_transaction; end
  def default_sequence_name(table, column); end
  def delete(sql, name = nil); end
  def delete_sql(sql, name = nil); end
  def empty_insert_statement(table_name); end
  def insert(sql, name = nil, pk = nil, id_value = nil, sequence_name = nil); end
  def insert_fixture(fixture, table_name); end
  def insert_sql(sql, name = nil, pk = nil, id_value = nil, sequence_name = nil); end
  def limited_update_conditions(where_sql, quoted_table_name, quoted_primary_key); end
  def outside_transaction?; end
  def reset_sequence!(table, column, sequence = nil); end
  def rollback_db_transaction; end
  def sanitize_limit(limit); end
  def select_all(sql, name = nil); end
  def select_one(sql, name = nil); end
  def select_value(sql, name = nil); end
  def select_values(sql, name = nil); end
  def transaction(options = nil); end
  def update(sql, name = nil); end
  def update_sql(sql, name = nil); end
end
module ActiveRecord::ConnectionAdapters::Quoting
  def quote(value, column = nil); end
  def quote_column_name(column_name); end
  def quote_string(s); end
  def quote_table_name(table_name); end
  def quoted_date(value); end
  def quoted_false; end
  def quoted_true; end
end
class ActiveRecord::ConnectionTimeoutError < ActiveRecord::ConnectionNotEstablished
end
class ActiveRecord::ConnectionAdapters::ConnectionPool
  def checkin(conn); end
  def checkout; end
  def checkout_and_verify(c); end
  def checkout_existing_connection; end
  def checkout_new_connection; end
  def clear_reloadable_connections!(*args, &block); end
  def clear_reloadable_connections_with_synchronization!(*args, &block); end
  def clear_reloadable_connections_without_synchronization!; end
  def clear_stale_cached_connections!; end
  def connected?(*args, &block); end
  def connected_with_synchronization?(*args, &block); end
  def connected_without_synchronization?; end
  def connection; end
  def current_connection_id; end
  def disconnect!(*args, &block); end
  def disconnect_with_synchronization!(*args, &block); end
  def disconnect_without_synchronization!; end
  def initialize(spec); end
  def new_connection; end
  def release_connection; end
  def remove_stale_cached_threads!(cache, &block); end
  def spec; end
  def verify_active_connections!(*args, &block); end
  def verify_active_connections_with_synchronization!(*args, &block); end
  def verify_active_connections_without_synchronization!; end
  def with_connection; end
end
class ActiveRecord::ConnectionAdapters::ConnectionHandler
  def clear_active_connections!; end
  def clear_all_connections!; end
  def clear_reloadable_connections!; end
  def connected?(klass); end
  def connection_pools; end
  def establish_connection(name, spec); end
  def initialize(pools = nil); end
  def remove_connection(klass); end
  def retrieve_connection(klass); end
  def retrieve_connection_pool(klass); end
  def verify_active_connections!; end
end
class ActiveRecord::ConnectionAdapters::ConnectionManagement
  def call(env); end
  def initialize(app); end
end
class ActiveRecord::Base
  def ==(comparison_object); end
  def [](attr_name); end
  def []=(attr_name, value); end
  def assign_attributes(attributes = nil); end
  def assign_multiparameter_attributes(pairs); end
  def attribute_for_inspect(attr_name); end
  def attribute_names; end
  def attribute_present?(attribute); end
  def attribute_types_cached_by_default; end
  def attributes; end
  def attributes=(new_attributes, guard_protected_attributes = nil); end
  def attributes_before_type_cast; end
  def attributes_from_column_definition; end
  def attributes_from_column_definition_without_lock; end
  def attributes_protected_by_default; end
  def attributes_with_quotes(include_primary_key = nil, include_readonly_attributes = nil, attribute_names = nil); end
  def becomes(klass); end
  def cache_key; end
  def clone; end
  def clone_attribute_value(reader_method, attribute_name); end
  def clone_attributes(reader_method = nil, attributes = nil); end
  def colorize_logging; end
  def column_for_attribute(name); end
  def comma_pair_list(hash); end
  def configurations; end
  def connection; end
  def connection_handler; end
  def connection_handler=(arg0); end
  def connection_handler?; end
  def convert_number_column_value(value); end
  def create; end
  def create_or_update; end
  def create_or_update_without_callbacks; end
  def create_without_callbacks; end
  def create_without_timestamps; end
  def decrement!(attribute, by = nil); end
  def decrement(attribute, by = nil); end
  def default_scoping; end
  def default_timezone; end
  def delete; end
  def destroy; end
  def destroy_without_callbacks; end
  def destroy_without_lock; end
  def destroy_without_transactions; end
  def destroyed?; end
  def ensure_proper_type; end
  def eql?(comparison_object); end
  def execute_callstack_for_multiparameter_attributes(callstack); end
  def extract_callstack_for_multiparameter_attributes(pairs); end
  def find_parameter_position(multiparameter_name); end
  def freeze; end
  def frozen?; end
  def has_attribute?(attr_name); end
  def hash; end
  def id; end
  def id=(value); end
  def id_before_type_cast; end
  def include_root_in_json; end
  def increment!(attribute, by = nil); end
  def increment(attribute, by = nil); end
  def initialize(attributes = nil); end
  def inspect; end
  def instantiate_time_object(name, values); end
  def interpolate_sql(sql, record = nil); end
  def lock_optimistically; end
  def log_protected_attribute_removal(*attributes); end
  def logger; end
  def nested_attributes_options; end
  def new_record?; end
  def object_from_yaml(string); end
  def partial_updates; end
  def partial_updates=(arg0); end
  def partial_updates?; end
  def pluralize_table_names; end
  def primary_key_prefix_type; end
  def quote_columns(quoter, hash); end
  def quote_value(value, column = nil); end
  def quoted_column_names(attributes = nil); end
  def quoted_comma_pair_list(quoter, hash); end
  def quoted_id; end
  def readonly!; end
  def readonly?; end
  def record_timestamps; end
  def reload(options = nil); end
  def reload_without_autosave_associations(*args); end
  def reload_without_dirty(options = nil); end
  def remove_attributes_protected_from_mass_assignment(attributes); end
  def remove_readonly_attributes(attributes); end
  def save!; end
  def save(perform_validation = nil); end
  def save_without_dirty!; end
  def save_without_dirty(perform_validation = nil); end
  def save_without_transactions!(*args); end
  def save_without_transactions(*args); end
  def save_without_validation!; end
  def save_without_validation; end
  def schema_format; end
  def self.===(object); end
  def self.abstract_class; end
  def self.abstract_class=(arg0); end
  def self.abstract_class?; end
  def self.accessible_attributes; end
  def self.add_conditions!(sql, conditions, scope = nil); end
  def self.add_group!(sql, group, having, scope = nil); end
  def self.add_joins!(sql, joins, scope = nil); end
  def self.add_limit!(sql, options, scope = nil); end
  def self.add_lock!(sql, options, scope = nil); end
  def self.add_order!(sql, order, scope = nil); end
  def self.after_create(*methods, &block); end
  def self.after_create_callback_chain; end
  def self.after_destroy(*methods, &block); end
  def self.after_destroy_callback_chain; end
  def self.after_find(*methods, &block); end
  def self.after_find_callback_chain; end
  def self.after_initialize(*methods, &block); end
  def self.after_initialize_callback_chain; end
  def self.after_save(*methods, &block); end
  def self.after_save_callback_chain; end
  def self.after_update(*methods, &block); end
  def self.after_update_callback_chain; end
  def self.after_validation(*methods, &block); end
  def self.after_validation_callback_chain; end
  def self.after_validation_on_create(*methods, &block); end
  def self.after_validation_on_create_callback_chain; end
  def self.after_validation_on_update(*methods, &block); end
  def self.after_validation_on_update_callback_chain; end
  def self.aggregate_mapping(reflection); end
  def self.alias_attribute(new_name, old_name); end
  def self.alias_attribute_without_dirty(new_name, old_name); end
  def self.all(*args); end
  def self.all_attributes_exists?(attribute_names); end
  def self.allow_concurrency; end
  def self.allow_concurrency=(flag); end
  def self.array_of_strings?(o); end
  def self.attr_accessible(*attributes); end
  def self.attr_protected(*attributes); end
  def self.attr_readonly(*attributes); end
  def self.attribute_condition(quoted_column_name, argument); end
  def self.attribute_types_cached_by_default; end
  def self.attribute_types_cached_by_default=(obj); end
  def self.base_class; end
  def self.before_create(*methods, &block); end
  def self.before_create_callback_chain; end
  def self.before_destroy(*methods, &block); end
  def self.before_destroy_callback_chain; end
  def self.before_save(*methods, &block); end
  def self.before_save_callback_chain; end
  def self.before_update(*methods, &block); end
  def self.before_update_callback_chain; end
  def self.before_validation(*methods, &block); end
  def self.before_validation_callback_chain; end
  def self.before_validation_on_create(*methods, &block); end
  def self.before_validation_on_create_callback_chain; end
  def self.before_validation_on_update(*methods, &block); end
  def self.before_validation_on_update_callback_chain; end
  def self.benchmark(title, log_level = nil, use_silence = nil); end
  def self.class_name(table_name = nil); end
  def self.class_name_of_active_record_descendant(klass); end
  def self.class_of_active_record_descendant(klass); end
  def self.clear_active_connections!(*args, &block); end
  def self.clear_all_connections!(*args, &block); end
  def self.clear_reloadable_connections!(*args, &block); end
  def self.colorize_logging; end
  def self.colorize_logging=(obj); end
  def self.column_methods_hash; end
  def self.column_names; end
  def self.columns; end
  def self.columns_hash; end
  def self.compute_type(type_name); end
  def self.configurations; end
  def self.configurations=(obj); end
  def self.connected?; end
  def self.connection; end
  def self.connection_handler; end
  def self.connection_handler=(val); end
  def self.connection_handler?; end
  def self.connection_pool; end
  def self.construct_attributes_from_arguments(attribute_names, arguments); end
  def self.construct_finder_sql(options); end
  def self.content_columns; end
  def self.count_by_sql(sql); end
  def self.create(attributes = nil, &block); end
  def self.current_scoped_methods; end
  def self.decrement_counter(counter_name, id); end
  def self.default_scope(options = nil); end
  def self.default_scoping; end
  def self.default_scoping=(obj); end
  def self.default_select(qualified); end
  def self.default_timezone; end
  def self.default_timezone=(obj); end
  def self.define_attr_method(name, value = nil, &block); end
  def self.delete(id); end
  def self.delete_all(conditions = nil); end
  def self.descends_from_active_record?; end
  def self.destroy(id); end
  def self.destroy_all(conditions = nil); end
  def self.encode_quoted_value(value); end
  def self.establish_connection(spec = nil); end
  def self.exists?(id_or_conditions = nil); end
  def self.expand_attribute_names_for_aggregates(attribute_names); end
  def self.expand_hash_conditions_for_aggregates(attrs); end
  def self.expand_id_conditions(id_or_conditions); end
  def self.expand_range_bind_variables(bind_vars); end
  def self.find(*args); end
  def self.find_by_sql(sql); end
  def self.find_every(options); end
  def self.find_from_ids(ids, options); end
  def self.find_initial(options); end
  def self.find_last(options); end
  def self.find_one(id, options); end
  def self.find_some(ids, options); end
  def self.finder_needs_type_condition?; end
  def self.first(*args); end
  def self.full_table_name_prefix; end
  def self.get_primary_key(base_name); end
  def self.human_attribute_name(attribute_key_name, options = nil); end
  def self.human_name(options = nil); end
  def self.include_root_in_json; end
  def self.include_root_in_json=(obj); end
  def self.increment_counter(counter_name, id); end
  def self.inheritance_column; end
  def self.inheritance_column=(value = nil, &block); end
  def self.inherited(child); end
  def self.inspect; end
  def self.instantiate(record); end
  def self.last(*args); end
  def self.lock_optimistically; end
  def self.lock_optimistically=(obj); end
  def self.locking_column=(value = nil, &block); end
  def self.logger; end
  def self.logger=(obj); end
  def self.merge_conditions(*conditions); end
  def self.merge_includes(first, second); end
  def self.merge_joins(*joins); end
  def self.method_missing(method_id, *arguments, &block); end
  def self.nested_attributes_options; end
  def self.nested_attributes_options=(obj); end
  def self.parse_sqlite_config!(config); end
  def self.partial_updates; end
  def self.partial_updates=(val); end
  def self.partial_updates?; end
  def self.pluralize_table_names; end
  def self.pluralize_table_names=(obj); end
  def self.primary_key; end
  def self.primary_key=(value = nil, &block); end
  def self.primary_key_prefix_type; end
  def self.primary_key_prefix_type=(obj); end
  def self.protected_attributes; end
  def self.quote_bound_value(value); end
  def self.quote_value(value, column = nil); end
  def self.quoted_table_name; end
  def self.raise_if_bind_arity_mismatch(statement, expected, provided); end
  def self.readonly_attributes; end
  def self.record_timestamps; end
  def self.record_timestamps=(obj); end
  def self.remove_connection(klass = nil); end
  def self.replace_bind_variables(statement, values); end
  def self.replace_named_bind_variables(statement, bind_vars); end
  def self.reset_column_information; end
  def self.reset_column_information_and_inheritable_attributes_for_all_subclasses; end
  def self.reset_counters(id, *counters); end
  def self.reset_primary_key; end
  def self.reset_sequence_name; end
  def self.reset_subclasses; end
  def self.reset_table_name; end
  def self.respond_to?(method_id, include_private = nil); end
  def self.retrieve_connection; end
  def self.reverse_sql_order(order_query); end
  def self.safe_to_array(o); end
  def self.sanitize(object); end
  def self.sanitize_conditions(condition, table_name = nil); end
  def self.sanitize_sql(condition, table_name = nil); end
  def self.sanitize_sql_array(ary); end
  def self.sanitize_sql_for_assignment(assignments); end
  def self.sanitize_sql_for_conditions(condition, table_name = nil); end
  def self.sanitize_sql_hash(attrs, default_table_name = nil, top_level = nil); end
  def self.sanitize_sql_hash_for_assignment(attrs); end
  def self.sanitize_sql_hash_for_conditions(attrs, default_table_name = nil, top_level = nil); end
  def self.schema_format; end
  def self.schema_format=(obj); end
  def self.scope(method, key = nil); end
  def self.scoped?(method, key = nil); end
  def self.scoped_methods; end
  def self.self_and_descendants_from_active_record; end
  def self.sequence_name; end
  def self.sequence_name=(value = nil, &block); end
  def self.serialize(attr_name, class_name = nil); end
  def self.serialized_attributes; end
  def self.set_inheritance_column(value = nil, &block); end
  def self.set_primary_key(value = nil, &block); end
  def self.set_readonly_option!(options); end
  def self.set_sequence_name(value = nil, &block); end
  def self.set_table_name(value = nil, &block); end
  def self.silence; end
  def self.skip_time_zone_conversion_for_attributes; end
  def self.skip_time_zone_conversion_for_attributes=(obj); end
  def self.sqlite3_connection(config); end
  def self.sqlite_connection(config); end
  def self.sti_name; end
  def self.store_full_sti_class; end
  def self.store_full_sti_class=(val); end
  def self.store_full_sti_class?; end
  def self.subclasses; end
  def self.table_exists?; end
  def self.table_name; end
  def self.table_name=(value = nil, &block); end
  def self.table_name_prefix; end
  def self.table_name_prefix=(obj); end
  def self.table_name_suffix; end
  def self.table_name_suffix=(obj); end
  def self.time_zone_aware_attributes; end
  def self.time_zone_aware_attributes=(obj); end
  def self.timestamped_migrations; end
  def self.timestamped_migrations=(obj); end
  def self.type_condition(table_alias = nil); end
  def self.type_name_with_module(type_name); end
  def self.undecorated_table_name(class_name = nil); end
  def self.update(id, attributes); end
  def self.update_all(updates, conditions = nil, options = nil); end
  def self.update_counters(id, counters); end
  def self.update_counters_without_lock(id, counters); end
  def self.validate(*methods, &block); end
  def self.validate_callback_chain; end
  def self.validate_find_options(options); end
  def self.validate_on_create(*methods, &block); end
  def self.validate_on_create_callback_chain; end
  def self.validate_on_update(*methods, &block); end
  def self.validate_on_update_callback_chain; end
  def self.verification_timeout; end
  def self.verification_timeout=(flag); end
  def self.verify_active_connections!(*args, &block); end
  def self.with_exclusive_scope(method_scoping = nil, &block); end
  def self.with_scope(method_scoping = nil, action = nil, &block); end
  def skip_time_zone_conversion_for_attributes; end
  def store_full_sti_class; end
  def store_full_sti_class=(arg0); end
  def store_full_sti_class?; end
  def table_name_prefix; end
  def table_name_suffix; end
  def time_zone_aware_attributes; end
  def timestamped_migrations; end
  def to_param; end
  def toggle!(attribute); end
  def toggle(attribute); end
  def type_cast_attribute_value(multiparameter_name, value); end
  def update(*args); end
  def update_attribute(name, value); end
  def update_attributes!(attributes); end
  def update_attributes(attributes); end
  def update_attributes_inside_transaction!(attributes); end
  def update_attributes_inside_transaction(attributes); end
  def update_without_callbacks(*args); end
  def update_without_dirty(attribute_names = nil); end
  def update_without_lock(attribute_names = nil); end
  def update_without_timestamps; end
  def valid?; end
  def valid_without_callbacks?; end
  def write_attribute(attr, value); end
  def write_attribute_without_dirty(attr_name, value); end
  extend ActiveRecord::Aggregations::ClassMethods
  extend ActiveRecord::AssociationPreload::ClassMethods
  extend ActiveRecord::Associations::ClassMethods
  extend ActiveRecord::AttributeMethods::ClassMethods
  extend ActiveRecord::AutosaveAssociation::ClassMethods
  extend ActiveRecord::Batches::ClassMethods
  extend ActiveRecord::Calculations::ClassMethods
  extend ActiveRecord::Dirty::ClassMethods
  extend ActiveRecord::Locking::Optimistic::ClassMethods
  extend ActiveRecord::NamedScope::ClassMethods
  extend ActiveRecord::NestedAttributes::ClassMethods
  extend ActiveRecord::Observing::ClassMethods
  extend ActiveRecord::QueryCache::ClassMethods
  extend ActiveRecord::Reflection::ClassMethods
  extend ActiveRecord::Transactions::ClassMethods
  extend ActiveRecord::Validations::ClassMethods
  extend ActiveSupport::Callbacks::ClassMethods
  extend ActiveSupport::Callbacks::ClassMethods
  extend Observable
  include ActiveRecord::Aggregations
  include ActiveRecord::Associations
  include ActiveRecord::AttributeMethods
  include ActiveRecord::AutosaveAssociation
  include ActiveRecord::Callbacks
  include ActiveRecord::Dirty
  include ActiveRecord::Locking::Optimistic
  include ActiveRecord::Validations
  include ActiveSupport::Callbacks
  include ActiveSupport::Callbacks
end
class ActiveRecord::Base::ConnectionSpecification
  def adapter_method; end
  def config; end
  def initialize(config, adapter_method); end
end
module ActiveRecord::ConnectionAdapters::QueryCache
  def cache; end
  def cache_sql(sql); end
  def clear_query_cache; end
  def columns_with_query_cache(*args); end
  def query_cache; end
  def query_cache_enabled; end
  def select_all_with_query_cache(*args); end
  def self.dirties_query_cache(base, *method_names); end
  def self.included(base); end
  def uncached; end
end
module ActiveRecord::ConnectionAdapters::DatabaseLimits
  def column_name_length; end
  def columns_per_multicolumn_index; end
  def columns_per_table; end
  def in_clause_length; end
  def index_name_length; end
  def indexes_per_table; end
  def joins_per_query; end
  def sql_query_length; end
  def table_alias_length; end
  def table_name_length; end
end
class ActiveRecord::ConnectionAdapters::AbstractAdapter
  def active?; end
  def adapter_name; end
  def columns(*args); end
  def columns_without_query_cache(table_name, name = nil); end
  def create_savepoint; end
  def current_savepoint_name; end
  def decrement_open_transactions; end
  def delete(*args); end
  def delete_with_query_dirty(*args); end
  def delete_without_query_dirty(sql, name = nil); end
  def disable_referential_integrity(&block); end
  def disconnect!; end
  def format_log_entry(message, dump = nil); end
  def increment_open_transactions; end
  def initialize(connection, logger = nil); end
  def insert(*args); end
  def insert_with_query_dirty(*args); end
  def insert_without_query_dirty(sql, name = nil, pk = nil, id_value = nil, sequence_name = nil); end
  def log(sql, name); end
  def log_info(sql, name, ms); end
  def open_transactions; end
  def prefetch_primary_key?(table_name = nil); end
  def quote_table_name(name); end
  def raw_connection; end
  def reconnect!; end
  def release_savepoint; end
  def requires_reloading?; end
  def reset!; end
  def reset_runtime; end
  def rollback_to_savepoint; end
  def select_all(*args); end
  def select_all_without_query_cache(sql, name = nil); end
  def self.checkin(*methods, &block); end
  def self.checkin_callback_chain; end
  def self.checkout(*methods, &block); end
  def self.checkout_callback_chain; end
  def supports_count_distinct?; end
  def supports_ddl_transactions?; end
  def supports_migrations?; end
  def supports_primary_key?; end
  def supports_savepoints?; end
  def transaction_joinable=(joinable); end
  def update(*args); end
  def update_with_query_dirty(*args); end
  def update_without_query_dirty(sql, name = nil); end
  def verify!(*ignored); end
  extend ActiveSupport::Callbacks::ClassMethods
  include ActiveRecord::ConnectionAdapters::DatabaseLimits
  include ActiveRecord::ConnectionAdapters::QueryCache
  include ActiveRecord::ConnectionAdapters::Quoting
  include ActiveSupport::Callbacks
end
class ActiveRecord::ActiveRecordError < StandardError
end
class ActiveRecord::SubclassNotFound < ActiveRecord::ActiveRecordError
end
class ActiveRecord::AssociationTypeMismatch < ActiveRecord::ActiveRecordError
end
class ActiveRecord::SerializationTypeMismatch < ActiveRecord::ActiveRecordError
end
class ActiveRecord::AdapterNotSpecified < ActiveRecord::ActiveRecordError
end
class ActiveRecord::AdapterNotFound < ActiveRecord::ActiveRecordError
end
class ActiveRecord::ConnectionNotEstablished < ActiveRecord::ActiveRecordError
end
class ActiveRecord::RecordNotFound < ActiveRecord::ActiveRecordError
end
class ActiveRecord::RecordNotSaved < ActiveRecord::ActiveRecordError
end
class ActiveRecord::StatementInvalid < ActiveRecord::ActiveRecordError
end
class ActiveRecord::PreparedStatementInvalid < ActiveRecord::ActiveRecordError
end
class ActiveRecord::StaleObjectError < ActiveRecord::ActiveRecordError
end
class ActiveRecord::ConfigurationError < ActiveRecord::ActiveRecordError
end
class ActiveRecord::ReadOnlyRecord < ActiveRecord::ActiveRecordError
end
class ActiveRecord::Rollback < ActiveRecord::ActiveRecordError
end
class ActiveRecord::DangerousAttributeError < ActiveRecord::ActiveRecordError
end
class ActiveRecord::MissingAttributeError < NoMethodError
end
class ActiveRecord::UnknownAttributeError < NoMethodError
end
class ActiveRecord::AttributeAssignmentError < ActiveRecord::ActiveRecordError
  def attribute; end
  def exception; end
  def initialize(message, exception, attribute); end
end
class ActiveRecord::MultiparameterAssignmentErrors < ActiveRecord::ActiveRecordError
  def errors; end
  def initialize(errors); end
end
class ActiveRecord::ConnectionAdapters::SQLiteColumn < ActiveRecord::ConnectionAdapters::Column
  def self.binary_to_string(value); end
  def self.string_to_binary(value); end
end
class ActiveRecord::ConnectionAdapters::SQLiteAdapter < ActiveRecord::ConnectionAdapters::AbstractAdapter
  def adapter_name; end
  def add_column(table_name, column_name, type, options = nil); end
  def add_lock!(sql, options); end
  def alter_table(table_name, options = nil); end
  def begin_db_transaction; end
  def catch_schema_changes; end
  def change_column(table_name, column_name, type, options = nil); end
  def change_column_default(table_name, column_name, default); end
  def change_column_null(table_name, column_name, null, default = nil); end
  def columns(table_name, name = nil); end
  def commit_db_transaction; end
  def copy_table(from, to, options = nil); end
  def copy_table_contents(from, to, columns, rename = nil); end
  def copy_table_indexes(from, to, rename = nil); end
  def default_primary_key_type; end
  def delete_sql(sql, name = nil); end
  def disconnect!; end
  def empty_insert_statement(table_name); end
  def execute(sql, name = nil); end
  def indexes(table_name, name = nil); end
  def initialize(connection, logger, config); end
  def insert_sql(sql, name = nil, pk = nil, id_value = nil, sequence_name = nil); end
  def move_table(from, to, options = nil, &block); end
  def native_database_types; end
  def primary_key(table_name); end
  def quote_column_name(name); end
  def quote_string(s); end
  def remove_column(table_name, *column_names); end
  def remove_columns(table_name, *column_names); end
  def remove_index!(table_name, index_name); end
  def rename_column(table_name, column_name, new_column_name); end
  def rename_table(name, new_name); end
  def requires_reloading?; end
  def rollback_db_transaction; end
  def select(sql, name = nil); end
  def select_rows(sql, name = nil); end
  def sqlite_version; end
  def supports_add_column?; end
  def supports_autoincrement?; end
  def supports_count_distinct?; end
  def supports_ddl_transactions?; end
  def supports_migrations?; end
  def supports_primary_key?; end
  def table_structure(table_name); end
  def tables(name = nil); end
  def update_sql(sql, name = nil); end
  def valid_alter_table_options(type, options); end
end
class ActiveRecord::ConnectionAdapters::SQLiteAdapter::Version
  def <=>(version_string); end
  def initialize(version_string); end
  include Comparable
end
class ActiveRecord::ConnectionAdapters::SQLite2Adapter < ActiveRecord::ConnectionAdapters::SQLiteAdapter
  def rename_table(name, new_name); end
end
class ActiveRecord::ConnectionAdapters::DeprecatedSQLiteAdapter < ActiveRecord::ConnectionAdapters::SQLite2Adapter
  def insert(sql, name = nil, pk = nil, id_value = nil); end
end
class ActiveRecord::ConnectionAdapters::SQLite3Adapter < ActiveRecord::ConnectionAdapters::SQLiteAdapter
  def table_structure(table_name); end
end
class ActiveRecord::DynamicFinderMatch
  def attribute_names; end
  def bang?; end
  def finder; end
  def finder?; end
  def initialize(method); end
  def instantiator; end
  def instantiator?; end
  def self.match(method); end
end
class ActiveRecord::DynamicScopeMatch
  def attribute_names; end
  def initialize(method); end
  def scope; end
  def scope?; end
  def self.match(method); end
end
class ActiveRecord::IrreversibleMigration < ActiveRecord::ActiveRecordError
end
class ActiveRecord::DuplicateMigrationVersionError < ActiveRecord::ActiveRecordError
  def initialize(version); end
end
class ActiveRecord::DuplicateMigrationNameError < ActiveRecord::ActiveRecordError
  def initialize(name); end
end
class ActiveRecord::UnknownMigrationVersionError < ActiveRecord::ActiveRecordError
  def initialize(version); end
end
class ActiveRecord::IllegalMigrationNameError < ActiveRecord::ActiveRecordError
  def initialize(name); end
end
class ActiveRecord::Migration
  def self.down_with_benchmarks; end
  def self.migrate(direction); end
  def self.up_with_benchmarks; end
  def self.verbose; end
  def self.verbose=(obj); end
  def verbose; end
  def verbose=(obj); end
end
class ActiveRecord::MigrationProxy
  def announce(*args, &block); end
  def filename; end
  def filename=(arg0); end
  def load_migration; end
  def migrate(*args, &block); end
  def migration; end
  def name; end
  def name=(arg0); end
  def version; end
  def version=(arg0); end
  def write(*args, &block); end
end
class ActiveRecord::Migrator
  def current_migration; end
  def current_version; end
  def ddl_transaction(&block); end
  def down?; end
  def initialize(direction, migrations_path, target_version = nil); end
  def migrate; end
  def migrated; end
  def migrations; end
  def pending_migrations; end
  def record_version_state_after_migrating(version); end
  def run; end
  def self.current_version; end
  def self.down(migrations_path, target_version = nil); end
  def self.get_all_versions; end
  def self.migrate(migrations_path, target_version = nil); end
  def self.migrations_path; end
  def self.proper_table_name(name); end
  def self.rollback(migrations_path, steps = nil); end
  def self.run(direction, migrations_path, target_version); end
  def self.schema_migrations_table_name; end
  def self.up(migrations_path, target_version = nil); end
  def up?; end
end
