# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module ActionController::Assertions
  NO_STRIP = ::T.let(nil, ::T.untyped)
end

module ActionController::Assertions::DomAssertions
  def assert_dom_equal(expected, actual, message=T.unsafe(nil)); end

  def assert_dom_not_equal(expected, actual, message=T.unsafe(nil)); end
end

module ActionController::Assertions::DomAssertions
  def self.strip_whitespace!(nodes); end
end

module ActionController::Assertions::ModelAssertions
  def assert_valid(record); end
end

module ActionController::Assertions::ModelAssertions
end

module ActionController::Assertions::ResponseAssertions
  def assert_redirected_to(options=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_response(type, message=T.unsafe(nil)); end

  def assert_template(options=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::Assertions::ResponseAssertions
end

module ActionController::Assertions::RoutingAssertions
  def assert_generates(expected_path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_recognizes(expected_options, path, extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_routing(path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::Assertions::RoutingAssertions
end

module ActionController::Assertions::SelectorAssertions
  def assert_select(*args, &block); end

  def assert_select_email(&block); end

  def assert_select_encoded(element=T.unsafe(nil), &block); end

  def assert_select_rjs(*args, &block); end

  def count_description(min, max); end

  def css_select(*args); end

  def initialize(*args); end

  def response_from_page_or_rjs(); end

  def unescape_rjs(rjs_string); end
  RJS_ANY_ID = ::T.let(nil, ::T.untyped)
  RJS_INSERTIONS = ::T.let(nil, ::T.untyped)
  RJS_PATTERN_HTML = ::T.let(nil, ::T.untyped)
  RJS_PATTERN_UNICODE_ESCAPED_CHAR = ::T.let(nil, ::T.untyped)
  RJS_STATEMENTS = ::T.let(nil, ::T.untyped)
end

module ActionController::Assertions::SelectorAssertions
end

module ActionController::Assertions::TagAssertions
  def assert_no_tag(*opts); end

  def assert_tag(*opts); end
end

module ActionController::Assertions::TagAssertions
end

class ActionController::Base
  include ::ActionController::Caching::Fragments
  include ::ActionController::Caching::Actions
  include ::ActionController::Routing::Helpers
  include ::ActionController::PolymorphicRoutes
  DEFAULT_RENDER_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

class ActionController::CGIHandler
end

module ActionController::CGIHandler::ProperStream
  def each(&blk); end

  def read(*args); end
end

module ActionController::CGIHandler::ProperStream
end

class ActionController::CGIHandler
  def self.dispatch_cgi(app, cgi, out=T.unsafe(nil)); end
end

class ActionController::Caching::Sweeper
  def action_path_for(options); end

  def after(controller); end

  def assigns(key); end

  def before(controller); end

  def controller(); end

  def controller=(controller); end
end

class ActionController::Caching::Sweeper
end

class ActionController::CgiRequest
  DEFAULT_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionController::CgiRequest
end

class ActionController::DoubleRenderError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::Http::Headers
  include ::ActiveSupport::Memoizable::InstanceMethods
  def [](header_name); end

  def freeze_without_memoizable(); end

  def initialize(*args); end
end

class ActionController::Http::Headers
  extend ::ActiveSupport::Memoizable
end

module ActionController::RecordIdentifier
  JOIN = ::T.let(nil, ::T.untyped)
  NEW = ::T.let(nil, ::T.untyped)
end

class ActionController::RedirectBackError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::Reloader
  def default_lock(); end

  def default_lock=(obj); end
end

class ActionController::Reloader::BodyWrapper
  def close(); end

  def initialize(body, lock); end

  def method_missing(*args, &block); end

  def respond_to?(symbol, include_private=T.unsafe(nil)); end
end

class ActionController::Reloader::BodyWrapper
end

class ActionController::Reloader
  def self.default_lock(); end

  def self.default_lock=(obj); end

  def self.run(lock=T.unsafe(nil)); end
end

class ActionController::Request
  def accept(); end

  def accept_charset(); end

  def accept_language(); end

  def accepts(); end

  def auth_type(); end

  def body_stream(); end

  def cache_control(); end

  def cache_format(); end

  def deep_munge(hash); end

  def domain(tld_length=T.unsafe(nil)); end

  def etag_matches?(etag); end

  def format(); end

  def format=(extension); end

  def fresh?(response); end

  def from(); end

  def gateway_interface(); end

  def headers(); end

  def if_modified_since(); end

  def if_none_match(); end

  def key?(key); end

  def method(); end

  def negotiate(); end

  def not_modified?(modified_at); end

  def parameters(); end

  def path_parameters(); end

  def path_parameters=(parameters); end

  def path_translated(); end

  def port_string(); end

  def pragma(); end

  def protocol(); end

  def query_parameters(); end

  def raw_host_with_port(); end

  def raw_post(); end

  def remote_addr(); end

  def remote_host(); end

  def remote_ident(); end

  def remote_ip(); end

  def remote_user(); end

  def request_parameters(); end

  def request_uri(); end

  def reset_session(); end

  def server_name(); end

  def server_port(); end

  def server_protocol(); end

  def server_software(); end

  def session=(session); end

  def session_options=(options); end

  def ssl?(); end

  def standard_port(); end

  def subdomains(tld_length=T.unsafe(nil)); end

  def symbolized_path_parameters(); end

  def template_format(); end

  def xml_http_request?(); end
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_LOOKUP = ::T.let(nil, ::T.untyped)
  TRUSTED_PROXIES = ::T.let(nil, ::T.untyped)
end

class ActionController::Request
end

module ActionController::Rescue
  DEFAULT_RESCUE_RESPONSE = ::T.let(nil, ::T.untyped)
  DEFAULT_RESCUE_RESPONSES = ::T.let(nil, ::T.untyped)
  DEFAULT_RESCUE_TEMPLATE = ::T.let(nil, ::T.untyped)
  DEFAULT_RESCUE_TEMPLATES = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  RESCUES_TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

module ActionController::Resources
  INHERITABLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionController::Resources::Resource
  DEFAULT_ACTIONS = ::T.let(nil, ::T.untyped)
end

class ActionController::Response
  def assign_default_content_type_and_charset!(); end

  def assigns(); end

  def assigns=(assigns); end

  def charset(); end

  def charset=(charset); end

  def content_type=(mime_type); end

  def default_charset(*args, &block); end

  def etag(); end

  def etag=(etag); end

  def etag?(); end

  def flush(); end

  def initialize(); end

  def last_modified(); end

  def last_modified=(utc_time); end

  def last_modified?(); end

  def layout(); end

  def layout=(layout); end

  def location=(url); end

  def prepare!(); end

  def redirect(url, status); end

  def redirected_to(); end

  def redirected_to=(redirected_to); end

  def redirected_to_method_params(); end

  def redirected_to_method_params=(redirected_to_method_params); end

  def request(); end

  def request=(request); end

  def sending_file?(); end

  def session(); end

  def session=(session); end

  def template(); end

  def template=(template); end
  DEFAULT_HEADERS = ::T.let(nil, ::T.untyped)
end

class ActionController::Response
end

module ActionController::Routing
  ALLOWED_REQUIREMENTS_FOR_OPTIMISATION = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  Routes = ::T.let(nil, ::T.untyped)
  SEPARATORS = ::T.let(nil, ::T.untyped)
end

module ActionController::Routing::Optimisation
  OPTIMISERS = ::T.let(nil, ::T.untyped)
end

class ActionController::Routing::Optimisation::Optimiser
  GLOBAL_GUARD_CONDITIONS = ::T.let(nil, ::T.untyped)
end

class ActionController::Routing::Segment
  RESERVED_PCHAR = ::T.let(nil, ::T.untyped)
  SAFE_PCHAR = ::T.let(nil, ::T.untyped)
  UNSAFE_PCHAR = ::T.let(nil, ::T.untyped)
end

class ActionController::Session::AbstractStore
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  ENV_SESSION_KEY = ::T.let(nil, ::T.untyped)
  ENV_SESSION_OPTIONS_KEY = ::T.let(nil, ::T.untyped)
  HTTP_COOKIE = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
end

class ActionController::Session::CookieStore
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  ENV_SESSION_KEY = ::T.let(nil, ::T.untyped)
  ENV_SESSION_OPTIONS_KEY = ::T.let(nil, ::T.untyped)
  MAX = ::T.let(nil, ::T.untyped)
  SECRET_MIN_LENGTH = ::T.let(nil, ::T.untyped)
end

class ActionController::Session::MemCacheStore
end

class ActionController::Session::MemCacheStore
end

class ActionController::SessionOverflowError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

module ActionController::StatusCodes
  STATUS_CODES = ::T.let(nil, ::T.untyped)
  SYMBOL_TO_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

module ActionController::Streaming
  DEFAULT_SEND_FILE_OPTIONS = ::T.let(nil, ::T.untyped)
  X_SENDFILE_HEADER = ::T.let(nil, ::T.untyped)
end

class ActionController::StringCoercion
  def call(env); end

  def initialize(app); end
end

class ActionController::StringCoercion::UglyBody
  def each(&blk); end

  def initialize(body); end
end

class ActionController::StringCoercion::UglyBody
end

class ActionController::StringCoercion
end

module ActionController::TestProcess
  def assigns(key=T.unsafe(nil)); end

  def build_request_uri(action, parameters); end

  def cookies(); end

  def find_all_tag(conditions); end

  def find_tag(conditions); end

  def fixture_file_upload(path, mime_type=T.unsafe(nil), binary=T.unsafe(nil)); end

  def flash(); end

  def html_document(); end

  def method_missing(selector, *args, &block); end

  def process(action, parameters=T.unsafe(nil), session=T.unsafe(nil), flash=T.unsafe(nil), http_method=T.unsafe(nil)); end

  def redirect_to_url(); end

  def session(); end

  def with_routing(); end

  def xhr(request_method, action, parameters=T.unsafe(nil), session=T.unsafe(nil), flash=T.unsafe(nil)); end

  def xml_http_request(request_method, action, parameters=T.unsafe(nil), session=T.unsafe(nil), flash=T.unsafe(nil)); end
end

module ActionController::TestProcess
  def self.included(base); end
end

module ActionController::UploadedFile
  def original_filename(); end
end

module ActionController::UploadedFile
  def self.extended(object); end

  def self.included(base); end
end

class ActionController::UploadedStringIO
  include ::ActionController::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def original_path(); end

  def original_path=(original_path); end
end

class ActionController::UploadedStringIO
end

class ActionController::UploadedTempfile
  include ::ActionController::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def local_path(); end

  def original_path(); end

  def original_path=(original_path); end
end

class ActionController::UploadedTempfile
end

class ActionController::UrlRewriter
  RESERVED_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionController::UrlWriter
  RESERVED_PCHAR = ::T.let(nil, ::T.untyped)
  SAFE_PCHAR = ::T.let(nil, ::T.untyped)
  UNSAFE_PCHAR = ::T.let(nil, ::T.untyped)
end

class ActionMailer::Base
  include ::ActionMailer::Utils
  include ::ActionMailer::Quoting
  include ::ActionMailer::PartContainer
end

class ActionMailer::Part
  include ::ActionMailer::Utils
  include ::ActionMailer::PartContainer
  include ::ActionMailer::AdvAttrAccessor
  def body(*parameters); end

  def body=(value); end

  def charset(*parameters); end

  def charset=(value); end

  def content_disposition(*parameters); end

  def content_disposition=(value); end

  def content_type(*parameters); end

  def content_type=(value); end

  def filename(*parameters); end

  def filename=(value); end

  def headers(*parameters); end

  def headers=(value); end

  def initialize(params); end

  def to_mail(defaults); end

  def transfer_encoding(*parameters); end

  def transfer_encoding=(value); end
end

class ActionMailer::Part
  extend ::ActionMailer::AdvAttrAccessor::ClassMethods
end

module ActionMailer::Quoting
  CHARS_NEEDING_QUOTING = ::T.let(nil, ::T.untyped)
end

module ActionMailer::TestHelper
  def assert_emails(number); end

  def assert_no_emails(&block); end
end

module ActionMailer::TestHelper
end

module ActionView
  SafeBuffer = ::T.let(nil, ::T.untyped)
end

class ActionView::Base
  include ::ActionView::Partials
  include ::ActiveSupport::Memoizable::InstanceMethods
  include ::ActionController::Routing::Helpers
  include ::ActionController::PolymorphicRoutes
end

module ActionView::Helpers::AssetTagHelper
  ASSETS_DIR = ::T.let(nil, ::T.untyped)
  JAVASCRIPTS_DIR = ::T.let(nil, ::T.untyped)
  JAVASCRIPT_DEFAULT_SOURCES = ::T.let(nil, ::T.untyped)
  STYLESHEETS_DIR = ::T.let(nil, ::T.untyped)
end

class ActionView::Helpers::DateTimeSelector
  DEFAULT_PREFIX = ::T.let(nil, ::T.untyped)
  POSITION = ::T.let(nil, ::T.untyped)
end

class ActionView::Helpers::InstanceTag
  include ::ActionView::Helpers::FormTagHelper
  DEFAULT_FIELD_OPTIONS = ::T.let(nil, ::T.untyped)
  DEFAULT_RADIO_OPTIONS = ::T.let(nil, ::T.untyped)
  DEFAULT_TEXT_AREA_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionView::Helpers::JavaScriptCollectionProxy
  ENUMERABLE_METHODS = ::T.let(nil, ::T.untyped)
  ENUMERABLE_METHODS_WITH_RETURN = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::JavaScriptHelper
  JAVASCRIPT_PATH = ::T.let(nil, ::T.untyped)
  JS_ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::NumberHelper
  STORAGE_UNITS = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::PrototypeHelper
  AJAX_OPTIONS = ::T.let(nil, ::T.untyped)
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::ScriptaculousHelper
  TOGGLE_EFFECTS = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::TagHelper
  BLOCK_CALLED_FROM_ERB = ::T.let(nil, ::T.untyped)
  BOOLEAN_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::TextHelper
  AUTO_EMAIL_RE = ::T.let(nil, ::T.untyped)
  AUTO_LINK_CRE = ::T.let(nil, ::T.untyped)
  AUTO_LINK_RE = ::T.let(nil, ::T.untyped)
  BRACKETS = ::T.let(nil, ::T.untyped)
end

class ActionView::InlineTemplate
  include ::ActionView::Renderable
  include ::ActiveSupport::Memoizable::InstanceMethods
  def extension(); end

  def initialize(source, type=T.unsafe(nil)); end

  def method_segment(); end

  def source(); end
end

class ActionView::InlineTemplate
end

class ActionView::TemplateError
  def file_name(); end

  def initialize(template, assigns, original_exception); end

  def line_number(); end

  def original_exception(); end

  def source_extract(indentation=T.unsafe(nil)); end

  def sub_template_message(); end

  def sub_template_of(template_path); end
  SOURCE_CODE_RADIUS = ::T.let(nil, ::T.untyped)
end

class ActionView::TemplateError
end

module ActiveRecord
  HasManyThroughCantAssociateThroughHasManyReflection = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Associations::AssociationCollection
  def <<(*records); end

  def add_record_to_target_with_callbacks(record); end

  def any?(); end

  def build(attributes=T.unsafe(nil), &block); end

  def clear(); end

  def concat(*records); end

  def construct_find_options!(options); end

  def construct_scope(); end

  def count(*args); end

  def create(attrs=T.unsafe(nil)); end

  def create!(attrs=T.unsafe(nil)); end

  def delete(*records); end

  def delete_all(); end

  def destroy(*records); end

  def destroy_all(); end

  def empty?(); end

  def find(*args); end

  def find_target(); end

  def first(*args); end

  def include?(record); end

  def last(*args); end

  def length(); end

  def proxy_respond_to?(method, include_private=T.unsafe(nil)); end

  def push(*records); end

  def replace(other_array); end

  def reset_target!(); end

  def size(); end

  def sum(*args); end

  def to_ary(); end

  def transaction(*args); end

  def uniq(collection=T.unsafe(nil)); end
end

class ActiveRecord::Associations::AssociationCollection
end

class ActiveRecord::Associations::AssociationProxy
  def ===(other); end

  def aliased_table_name(); end

  def conditions(); end

  def dependent?(); end

  def initialize(owner, reflection); end

  def interpolate_sql(sql, record=T.unsafe(nil)); end

  def loaded(); end

  def loaded?(); end

  def merge_options_from_reflection!(options); end

  def proxy_extend(mod, *args); end

  def proxy_owner(); end

  def proxy_reflection(); end

  def proxy_respond_to?(*_); end

  def proxy_target(); end

  def quoted_record_ids(records); end

  def reload(); end

  def reset(); end

  def respond_to?(*args); end

  def sanitize_sql(sql, table_name=T.unsafe(nil)); end

  def send(method, *args); end

  def set_belongs_to_association_for(record); end

  def sql_conditions(); end

  def target(); end

  def target=(target); end

  def with_scope(*args, &block); end
end

class ActiveRecord::Associations::AssociationProxy
end

class ActiveRecord::Associations::BelongsToAssociation
  def build(attributes=T.unsafe(nil)); end

  def create(attributes=T.unsafe(nil)); end

  def replace(record); end

  def updated?(); end
end

class ActiveRecord::Associations::BelongsToAssociation
end

class ActiveRecord::Associations::BelongsToPolymorphicAssociation
  def replace(record); end

  def updated?(); end
end

class ActiveRecord::Associations::BelongsToPolymorphicAssociation
end

class ActiveRecord::Associations::HasAndBelongsToManyAssociation
  def columns(); end

  def construct_sql(); end

  def count_records(); end

  def create(attributes=T.unsafe(nil)); end

  def create!(attributes=T.unsafe(nil)); end

  def delete_records(records); end

  def finding_with_ambiguous_select?(select_clause); end

  def has_primary_key?(); end

  def insert_record(record, force=T.unsafe(nil), validate=T.unsafe(nil)); end

  def reset_column_information(); end
end

class ActiveRecord::Associations::HasAndBelongsToManyAssociation
end

class ActiveRecord::Associations::HasManyAssociation
  def cached_counter_attribute_name(); end

  def construct_sql(); end

  def count_records(); end

  def delete_records(records); end

  def has_cached_counter?(); end

  def insert_record(record, force=T.unsafe(nil), validate=T.unsafe(nil)); end

  def target_obsolete?(); end
end

class ActiveRecord::Associations::HasManyAssociation
end

class ActiveRecord::Associations::HasManyThroughAssociation
  def build_conditions(); end

  def build_sti_condition(); end

  def build_through_conditions(); end

  def construct_conditions(); end

  def construct_from(); end

  def construct_join_attributes(associate); end

  def construct_joins(custom_joins=T.unsafe(nil)); end

  def construct_owner_attributes(reflection); end

  def construct_quoted_owner_attributes(reflection); end

  def construct_select(custom_select=T.unsafe(nil)); end

  def new(attributes=T.unsafe(nil), &block); end

  def target_reflection_has_associated_record?(); end
end

class ActiveRecord::Associations::HasManyThroughAssociation
end

class ActiveRecord::Associations::HasOneAssociation
  def build(attrs=T.unsafe(nil), replace_existing=T.unsafe(nil)); end

  def create(attrs=T.unsafe(nil), replace_existing=T.unsafe(nil)); end

  def create!(attrs=T.unsafe(nil), replace_existing=T.unsafe(nil)); end

  def replace(obj, dont_save=T.unsafe(nil)); end
end

class ActiveRecord::Associations::HasOneAssociation
end

class ActiveRecord::Associations::HasOneThroughAssociation
  def create_through_record(new_value); end
end

class ActiveRecord::Associations::HasOneThroughAssociation
end

module ActiveRecord::AttributeMethods
  ATTRIBUTE_TYPES_CACHED_BY_DEFAULT = ::T.let(nil, ::T.untyped)
  DEFAULT_SUFFIXES = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::AutosaveAssociation
  ASSOCIATION_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Base
  include ::ActiveRecord::Observing
  include ::ActiveRecord::NamedScope
  include ::ActiveRecord::AssociationPreload
  include ::ActiveRecord::Calculations
  include ::ActiveRecord::Batches
end

class ActiveRecord::Base
  extend ::Observable
end

module ActiveRecord::Calculations
  CALCULATIONS_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Callbacks
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::ConnectionAdapters::DatabaseStatements
end

class ActiveRecord::ConnectionAdapters::Column
  FALSE_VALUES = ::T.let(nil, ::T.untyped)
  TRUE_VALUES = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::ConnectionAdapters::Column::Format
  ISO_DATE = ::T.let(nil, ::T.untyped)
  ISO_DATETIME = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Dirty
  DIRTY_SUFFIXES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Migration
  def self.announce(message); end

  def self.connection(); end

  def self.method_missing(method, *arguments, &block); end

  def self.say(message, subitem=T.unsafe(nil)); end

  def self.say_with_time(message); end

  def self.singleton_method_added(sym); end

  def self.suppress_messages(); end

  def self.write(text=T.unsafe(nil)); end
end

class ActiveRecord::NamedScope::Scope
  NON_DELEGATE_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::NestedAttributes
  UNASSIGNABLE_KEYS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::NestedAttributes::ClassMethods
  REJECT_ALL_BLANK_PROC = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Schema
  def self.migrations_path(); end
end

class ActiveRecord::SchemaDumper
  def dump(stream); end

  def ignore_tables(); end

  def ignore_tables=(obj); end

  def initialize(connection); end
end

class ActiveRecord::SchemaDumper
  def self.dump(connection=T.unsafe(nil), stream=T.unsafe(nil)); end

  def self.ignore_tables(); end

  def self.ignore_tables=(obj); end
end

class ActiveRecord::SessionStore
  def session_class(); end

  def session_class=(obj); end
  SESSION_RECORD_KEY = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::SessionStore::Session
  def data(); end

  def data=(data); end

  def data_column_name(); end

  def data_column_name=(obj); end

  def loaded?(); end
end

class ActiveRecord::SessionStore::Session
  def self.create_table!(); end

  def self.data_column_name(); end

  def self.data_column_name=(obj); end

  def self.data_column_size_limit(); end

  def self.drop_table!(); end

  def self.find_by_session_id(session_id); end

  def self.marshal(data); end

  def self.unmarshal(data); end
end

class ActiveRecord::SessionStore::SqlBypass
  def connection(); end

  def connection=(obj); end

  def data(); end

  def data=(data); end

  def data_column(); end

  def data_column=(obj); end

  def destroy(); end

  def initialize(attributes); end

  def loaded?(); end

  def new_record?(); end

  def save(); end

  def session_id(); end

  def session_id_column(); end

  def session_id_column=(obj); end

  def table_name(); end

  def table_name=(obj); end
end

class ActiveRecord::SessionStore::SqlBypass
  def self.connection(); end

  def self.connection=(obj); end

  def self.create_table!(); end

  def self.data_column(); end

  def self.data_column=(obj); end

  def self.drop_table!(); end

  def self.find_by_session_id(session_id); end

  def self.marshal(data); end

  def self.session_id_column(); end

  def self.session_id_column=(obj); end

  def self.table_name(); end

  def self.table_name=(obj); end

  def self.unmarshal(data); end
end

class ActiveRecord::SessionStore
  def self.session_class(); end

  def self.session_class=(obj); end
end

module ActiveRecord::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::VERSION
end

module ActiveRecord::Validations
  VALIDATIONS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Validations::ClassMethods
  ALL_NUMERICALITY_CHECKS = ::T.let(nil, ::T.untyped)
  ALL_RANGE_OPTIONS = ::T.let(nil, ::T.untyped)
  DEFAULT_VALIDATION_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveResource::Connection
  HTTP_FORMAT_HEADER_NAMES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::BacktraceCleaner
  def add_filter(&block); end

  def add_silencer(&block); end

  def clean(backtrace); end

  def remove_silencers!(); end
end

class ActiveSupport::BacktraceCleaner
end

ActiveSupport::Base64 = Base64

class ActiveSupport::BufferedLogger
  MAX_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::BufferedLogger::Severity
  DEBUG = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  FATAL = ::T.let(nil, ::T.untyped)
  INFO = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  WARN = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::CompressedMemCacheStore
  def read(name, options=T.unsafe(nil)); end

  def write(name, value, options=T.unsafe(nil)); end
end

class ActiveSupport::Cache::CompressedMemCacheStore
end

class ActiveSupport::Cache::DRbStore
  def address(); end

  def initialize(address=T.unsafe(nil)); end
end

class ActiveSupport::Cache::DRbStore
end

class ActiveSupport::Cache::FileStore
  def cache_path(); end

  def delete(name, options=T.unsafe(nil)); end

  def exist?(name, options=T.unsafe(nil)); end

  def initialize(cache_path); end

  def read(name, options=T.unsafe(nil)); end

  def write(name, value, options=T.unsafe(nil)); end
end

class ActiveSupport::Cache::FileStore
end

class ActiveSupport::Cache::MemCacheStore
  def clear(); end

  def initialize(*addresses); end

  def read_multi(*keys); end

  def stats(); end
end

module ActiveSupport::Cache::MemCacheStore::Response
  DELETED = ::T.let(nil, ::T.untyped)
  EXISTS = ::T.let(nil, ::T.untyped)
  NOT_FOUND = ::T.let(nil, ::T.untyped)
  NOT_STORED = ::T.let(nil, ::T.untyped)
  STORED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::MemCacheStore::Response
end

class ActiveSupport::Cache::MemCacheStore
  def self.build_mem_cache(*addresses); end
end

module ActiveSupport::Cache::Strategy::LocalCache
  def clear(); end

  def decrement(key, amount=T.unsafe(nil)); end

  def delete(key, options=T.unsafe(nil)); end

  def exist(key, options=T.unsafe(nil)); end

  def increment(key, amount=T.unsafe(nil)); end

  def middleware(); end

  def read(key, options=T.unsafe(nil)); end

  def with_local_cache(); end

  def write(key, value, options=T.unsafe(nil)); end
  NULL = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::Strategy::LocalCache
end

class ActiveSupport::Cache::SynchronizedMemoryStore
end

class ActiveSupport::Cache::SynchronizedMemoryStore
end

module ActiveSupport::CoreExtensions::BigDecimal::Conversions
  DEFAULT_STRING_FORMAT = ::T.let(nil, ::T.untyped)
  YAML_MAPPING = ::T.let(nil, ::T.untyped)
  YAML_TAG = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::CoreExtensions::Date::Conversions
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::CoreExtensions::Hash::Conversions
  DISALLOWED_XML_TYPES = ::T.let(nil, ::T.untyped)
  XML_FORMATTING = ::T.let(nil, ::T.untyped)
  XML_PARSING = ::T.let(nil, ::T.untyped)
  XML_TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::CoreExtensions::Numeric::Bytes
  EXABYTE = ::T.let(nil, ::T.untyped)
  GIGABYTE = ::T.let(nil, ::T.untyped)
  KILOBYTE = ::T.let(nil, ::T.untyped)
  MEGABYTE = ::T.let(nil, ::T.untyped)
  PETABYTE = ::T.let(nil, ::T.untyped)
  TERABYTE = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::CoreExtensions::Range::Conversions
  RANGE_FORMATS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::CoreExtensions::Time::Calculations
  COMMON_YEAR_DAYS_IN_MONTH = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::CoreExtensions::Time::Conversions
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Deprecation
  DEFAULT_BEHAVIORS = ::T.let(nil, ::T.untyped)
end

ActiveSupport::FrozenObjectError = RuntimeError

module ActiveSupport::Gzip
end

class ActiveSupport::Gzip::Stream
end

class ActiveSupport::Gzip::Stream
end

module ActiveSupport::Gzip
  def self.compress(source); end

  def self.decompress(source); end
end

module ActiveSupport::JSON
  CircularReferenceError = ::T.let(nil, ::T.untyped)
  DATE_REGEX = ::T.let(nil, ::T.untyped)
  DECODERS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::JSON::Encoding
  ESCAPED_CHARS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::MessageEncryptor
  def decrypt(encrypted_message); end

  def decrypt_and_verify(value); end

  def encrypt(value); end

  def encrypt_and_sign(value); end

  def initialize(secret, cipher=T.unsafe(nil)); end
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

ActiveSupport::MessageEncryptor::OpenSSLCipherError = OpenSSL::Cipher::CipherError

class ActiveSupport::MessageEncryptor
end

class ActiveSupport::MessageVerifier
  def generate(value); end

  def initialize(secret, digest=T.unsafe(nil)); end

  def verify(signed_message); end
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier
end

module ActiveSupport::Multibyte
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  UCD = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VALID_CHARACTER = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Multibyte::Chars
  HANGUL_JAMO_FIRST = ::T.let(nil, ::T.untyped)
  HANGUL_JAMO_LAST = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SLAST = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  UNICODE_LEADERS_AND_TRAILERS = ::T.let(nil, ::T.untyped)
  UNICODE_LEADERS_PAT = ::T.let(nil, ::T.untyped)
  UNICODE_TRAILERS_PAT = ::T.let(nil, ::T.untyped)
  UNICODE_WHITESPACE = ::T.let(nil, ::T.untyped)
  UTF8_PAT = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Multibyte::UnicodeDatabase
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::OrderedOptions
  def [](key); end

  def []=(key, value); end

  def method_missing(name, *args); end
end

class ActiveSupport::OrderedOptions
end

ActiveSupport::SecureRandom = SecureRandom

class ActiveSupport::TimeWithZone
  include ::Comparable
  def +(other); end

  def -(other); end

  def acts_like_time?(); end

  def advance(options); end

  def ago(other); end

  def between?(min, max); end

  def comparable_time(); end

  def day(); end

  def dst?(); end

  def eql?(other); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def future?(); end

  def getgm(); end

  def getlocal(); end

  def getutc(); end

  def gmt?(); end

  def gmt_offset(); end

  def gmtime(); end

  def gmtoff(); end

  def hour(); end

  def httpdate(); end

  def in_time_zone(new_zone=T.unsafe(nil)); end

  def initialize(utc_time, time_zone, local_time=T.unsafe(nil), period=T.unsafe(nil)); end

  def is_a?(klass); end

  def isdst(); end

  def iso8601(fraction_digits=T.unsafe(nil)); end

  def kind_of?(klass); end

  def localtime(); end

  def marshal_dump(); end

  def marshal_load(variables); end

  def mday(); end

  def method_missing(sym, *args, &block); end

  def min(); end

  def mon(); end

  def month(); end

  def past?(); end

  def period(); end

  def respond_to?(sym, include_priv=T.unsafe(nil)); end

  def rfc2822(); end

  def rfc822(); end

  def sec(); end

  def since(other); end

  def strftime(format); end

  def time(); end

  def time_zone(); end

  def to_a(); end

  def to_date(); end

  def to_datetime(); end

  def to_f(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  def to_i(); end

  def to_s(format=T.unsafe(nil)); end

  def to_time(); end

  def today?(); end

  def tv_sec(); end

  def usec(); end

  def utc(); end

  def utc?(); end

  def utc_offset(); end

  def wday(); end

  def xmlschema(fraction_digits=T.unsafe(nil)); end

  def yday(); end

  def year(); end

  def zone(); end
end

class ActiveSupport::TimeWithZone
end

class ActiveSupport::TimeZone
  MAPPING = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini
  def backend(); end

  def backend=(name); end

  def parse(*args, &block); end

  def with_backend(name); end
end

module ActiveSupport::XmlMini
  extend ::ActiveSupport::XmlMini
end

class AddAdminToUsers
  def self.down_without_benchmarks(); end

  def self.up_without_benchmarks(); end
end

class AddEmailUniquenessIndex
  def self.down_without_benchmarks(); end

  def self.up_without_benchmarks(); end
end

class AddPasswordToUsers
  def self.down_without_benchmarks(); end

  def self.up_without_benchmarks(); end
end

class AddRememberTokenToUsers
  def self.down_without_benchmarks(); end

  def self.up_without_benchmarks(); end
end

class AddSaltToUsers
  def self.down_without_benchmarks(); end

  def self.up_without_benchmarks(); end
end

class ApplicationController
  def filter_parameters(unfiltered_parameters); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def bsearch(); end

  def bsearch_index(); end

  def collect!(); end

  def dig(*_); end

  def flatten!(*_); end

  def pack(*_); end

  def replace(_); end

  def shelljoin(); end

  def to_h(); end

end

class Array
  def self.try_convert(_); end
end

BasicObject::BasicObject = BasicObject

class BasicObject
  extend ::ActiveSupport::Dependencies::ClassConstMissing
end

class Benchmark::Job
  def initialize(width); end

  def item(label=T.unsafe(nil), &blk); end

  def list(); end

  def report(label=T.unsafe(nil), &blk); end

  def width(); end
end

class Benchmark::Report
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end

  def item(label=T.unsafe(nil), *format, &blk); end

  def list(); end

  def report(label=T.unsafe(nil), *format, &blk); end
end

class Benchmark::Tms
  def *(x); end

  def +(other); end

  def -(other); end

  def /(x); end

  def add(&blk); end

  def add!(&blk); end

  def cstime(); end

  def cutime(); end

  def format(format=T.unsafe(nil), *args); end

  def initialize(utime=T.unsafe(nil), stime=T.unsafe(nil), cutime=T.unsafe(nil), cstime=T.unsafe(nil), real=T.unsafe(nil), label=T.unsafe(nil)); end

  def label(); end

  def memberwise(op, x); end

  def real(); end

  def stime(); end

  def to_a(); end

  def total(); end

  def utime(); end
end

class BigDecimal
  def to_d(); end

  def to_digits(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  SIGN_NaN = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.ver(); end
end

class Binding
  def clone(); end

  def local_variable_defined?(_); end

  def local_variable_get(_); end

  def local_variable_set(_, _1); end

  def receiver(); end
end

Builder::BlankSlate = BlankSlate

module Builder::XChar
  CP1252 = ::T.let(nil, ::T.untyped)
  PREDEFINED = ::T.let(nil, ::T.untyped)
  VALID = ::T.let(nil, ::T.untyped)
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::FeatureFlag
  def github_https?(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::AuthenticationRequiredError
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CertificateFailureError
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::FallbackError
end

class Bundler::Fetcher::FallbackError
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::NetworkDownError
end

class Bundler::Fetcher::NetworkDownError
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::SSLError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_code(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

class Bundler::Plugin::DSL
  def _gem(name, *args); end

  def inferred_plugins(); end

  def plugin(name, *args); end
end

class Bundler::Plugin::DSL::PluginGemfileError
end

class Bundler::Plugin::DSL::PluginGemfileError
end

class Bundler::Plugin::DSL
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

module Bundler::Plugin::Events
  def self.defined_event?(event); end
end

class Bundler::Plugin::Index
  def command_plugin(command); end

  def commands(); end

  def global_index_file(); end

  def hook_plugins(event); end

  def index_file(); end

  def installed?(name); end

  def load_paths(name); end

  def local_index_file(); end

  def plugin_path(name); end

  def register_plugin(name, path, load_paths, commands, sources, hooks); end

  def source?(source); end

  def source_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Index
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
  def initialize(gem, options=T.unsafe(nil)); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

class CGI
  def stdinput(); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

module CGI::QueryExtension
  def initialize_query(); end
end

module CharDet
  ACO = ::T.let(nil, ::T.untyped)
  ACV = ::T.let(nil, ::T.untyped)
  ASC = ::T.let(nil, ::T.untyped)
  ASO = ::T.let(nil, ::T.untyped)
  ASS = ::T.let(nil, ::T.untyped)
  ASV = ::T.let(nil, ::T.untyped)
  BIG5_TABLE_SIZE = ::T.let(nil, ::T.untyped)
  BIG5_TYPICAL_DISTRIBUTION_RATIO = ::T.let(nil, ::T.untyped)
  BIG5_cls = ::T.let(nil, ::T.untyped)
  BIG5_st = ::T.let(nil, ::T.untyped)
  Big5CharLenTable = ::T.let(nil, ::T.untyped)
  Big5CharToFreqOrder = ::T.let(nil, ::T.untyped)
  Big5SMModel = ::T.let(nil, ::T.untyped)
  BulgarianLangModel = ::T.let(nil, ::T.untyped)
  CLASS_NUM = ::T.let(nil, ::T.untyped)
  DONT_KNOW = ::T.let(nil, ::T.untyped)
  EDetecting = ::T.let(nil, ::T.untyped)
  EError = ::T.let(nil, ::T.untyped)
  EEscAscii = ::T.let(nil, ::T.untyped)
  EFoundIt = ::T.let(nil, ::T.untyped)
  EHighbyte = ::T.let(nil, ::T.untyped)
  EItsMe = ::T.let(nil, ::T.untyped)
  ENOUGH_DATA_THRESHOLD = ::T.let(nil, ::T.untyped)
  ENOUGH_REL_THRESHOLD = ::T.let(nil, ::T.untyped)
  ENotMe = ::T.let(nil, ::T.untyped)
  EPureAscii = ::T.let(nil, ::T.untyped)
  EStart = ::T.let(nil, ::T.untyped)
  EUCJPCharLenTable = ::T.let(nil, ::T.untyped)
  EUCJPSMModel = ::T.let(nil, ::T.untyped)
  EUCJP_cls = ::T.let(nil, ::T.untyped)
  EUCJP_st = ::T.let(nil, ::T.untyped)
  EUCKRCharLenTable = ::T.let(nil, ::T.untyped)
  EUCKRCharToFreqOrder = ::T.let(nil, ::T.untyped)
  EUCKRSMModel = ::T.let(nil, ::T.untyped)
  EUCKR_TABLE_SIZE = ::T.let(nil, ::T.untyped)
  EUCKR_TYPICAL_DISTRIBUTION_RATIO = ::T.let(nil, ::T.untyped)
  EUCKR_cls = ::T.let(nil, ::T.untyped)
  EUCKR_st = ::T.let(nil, ::T.untyped)
  EUCTWCharLenTable = ::T.let(nil, ::T.untyped)
  EUCTWCharToFreqOrder = ::T.let(nil, ::T.untyped)
  EUCTWSMModel = ::T.let(nil, ::T.untyped)
  EUCTW_TABLE_SIZE = ::T.let(nil, ::T.untyped)
  EUCTW_TYPICAL_DISTRIBUTION_RATIO = ::T.let(nil, ::T.untyped)
  EUCTW_cls = ::T.let(nil, ::T.untyped)
  EUCTW_st = ::T.let(nil, ::T.untyped)
  FINAL_KAF = ::T.let(nil, ::T.untyped)
  FINAL_MEM = ::T.let(nil, ::T.untyped)
  FINAL_NUN = ::T.let(nil, ::T.untyped)
  FINAL_PE = ::T.let(nil, ::T.untyped)
  FINAL_TSADI = ::T.let(nil, ::T.untyped)
  FREQ_CAT_NUM = ::T.let(nil, ::T.untyped)
  GB2312CharLenTable = ::T.let(nil, ::T.untyped)
  GB2312CharToFreqOrder = ::T.let(nil, ::T.untyped)
  GB2312SMModel = ::T.let(nil, ::T.untyped)
  GB2312_TABLE_SIZE = ::T.let(nil, ::T.untyped)
  GB2312_TYPICAL_DISTRIBUTION_RATIO = ::T.let(nil, ::T.untyped)
  GB2312_cls = ::T.let(nil, ::T.untyped)
  GB2312_st = ::T.let(nil, ::T.untyped)
  GreekLangModel = ::T.let(nil, ::T.untyped)
  HZCharLenTable = ::T.let(nil, ::T.untyped)
  HZSMModel = ::T.let(nil, ::T.untyped)
  HZ_cls = ::T.let(nil, ::T.untyped)
  HZ_st = ::T.let(nil, ::T.untyped)
  HebrewLangModel = ::T.let(nil, ::T.untyped)
  HungarianLangModel = ::T.let(nil, ::T.untyped)
  IBM855_CharToOrderMap = ::T.let(nil, ::T.untyped)
  IBM866_CharToOrderMap = ::T.let(nil, ::T.untyped)
  ISO2022CNCharLenTable = ::T.let(nil, ::T.untyped)
  ISO2022CNSMModel = ::T.let(nil, ::T.untyped)
  ISO2022CN_cls = ::T.let(nil, ::T.untyped)
  ISO2022CN_st = ::T.let(nil, ::T.untyped)
  ISO2022JPCharLenTable = ::T.let(nil, ::T.untyped)
  ISO2022JPSMModel = ::T.let(nil, ::T.untyped)
  ISO2022JP_cls = ::T.let(nil, ::T.untyped)
  ISO2022JP_st = ::T.let(nil, ::T.untyped)
  ISO2022KRCharLenTable = ::T.let(nil, ::T.untyped)
  ISO2022KRSMModel = ::T.let(nil, ::T.untyped)
  ISO2022KR_cls = ::T.let(nil, ::T.untyped)
  ISO2022KR_st = ::T.let(nil, ::T.untyped)
  Ibm855Model = ::T.let(nil, ::T.untyped)
  Ibm866Model = ::T.let(nil, ::T.untyped)
  JISCharToFreqOrder = ::T.let(nil, ::T.untyped)
  JIS_TABLE_SIZE = ::T.let(nil, ::T.untyped)
  JIS_TYPICAL_DISTRIBUTION_RATIO = ::T.let(nil, ::T.untyped)
  KOI8R_CharToOrderMap = ::T.let(nil, ::T.untyped)
  Koi8rModel = ::T.let(nil, ::T.untyped)
  LOGICAL_HEBREW_NAME = ::T.let(nil, ::T.untyped)
  Latin1ClassModel = ::T.let(nil, ::T.untyped)
  Latin1_CharToClass = ::T.let(nil, ::T.untyped)
  Latin2HungarianModel = ::T.let(nil, ::T.untyped)
  Latin2_HungarianCharToOrderMap = ::T.let(nil, ::T.untyped)
  Latin5BulgarianModel = ::T.let(nil, ::T.untyped)
  Latin5CyrillicModel = ::T.let(nil, ::T.untyped)
  Latin5_BulgarianCharToOrderMap = ::T.let(nil, ::T.untyped)
  Latin7GreekModel = ::T.let(nil, ::T.untyped)
  Latin7_CharToOrderMap = ::T.let(nil, ::T.untyped)
  MAX_REL_THRESHOLD = ::T.let(nil, ::T.untyped)
  MINIMUM_DATA_THRESHOLD = ::T.let(nil, ::T.untyped)
  MINIMUM_THRESHOLD = ::T.let(nil, ::T.untyped)
  MIN_FINAL_CHAR_DISTANCE = ::T.let(nil, ::T.untyped)
  MIN_MODEL_DISTANCE = ::T.let(nil, ::T.untyped)
  MacCyrillicModel = ::T.let(nil, ::T.untyped)
  NEGATIVE_SHORTCUT_THRESHOLD = ::T.let(nil, ::T.untyped)
  NORMAL_KAF = ::T.let(nil, ::T.untyped)
  NORMAL_MEM = ::T.let(nil, ::T.untyped)
  NORMAL_NUN = ::T.let(nil, ::T.untyped)
  NORMAL_PE = ::T.let(nil, ::T.untyped)
  NORMAL_TSADI = ::T.let(nil, ::T.untyped)
  NUMBER_OF_SEQ_CAT = ::T.let(nil, ::T.untyped)
  NUM_OF_CATEGORY = ::T.let(nil, ::T.untyped)
  ONE_CHAR_PROB = ::T.let(nil, ::T.untyped)
  OTH = ::T.let(nil, ::T.untyped)
  POSITIVE_CAT = ::T.let(nil, ::T.untyped)
  POSITIVE_SHORTCUT_THRESHOLD = ::T.let(nil, ::T.untyped)
  RussianLangModel = ::T.let(nil, ::T.untyped)
  SAMPLE_SIZE = ::T.let(nil, ::T.untyped)
  SB_ENOUGH_REL_THRESHOLD = ::T.let(nil, ::T.untyped)
  SHORTCUT_THRESHOLD = ::T.let(nil, ::T.untyped)
  SJISCharLenTable = ::T.let(nil, ::T.untyped)
  SJISSMModel = ::T.let(nil, ::T.untyped)
  SJIS_cls = ::T.let(nil, ::T.untyped)
  SJIS_st = ::T.let(nil, ::T.untyped)
  SURE_NO = ::T.let(nil, ::T.untyped)
  SURE_YES = ::T.let(nil, ::T.untyped)
  SYMBOL_CAT_ORDER = ::T.let(nil, ::T.untyped)
  TIS620CharToOrderMap = ::T.let(nil, ::T.untyped)
  TIS620ThaiModel = ::T.let(nil, ::T.untyped)
  ThaiLangModel = ::T.let(nil, ::T.untyped)
  UCS2BECharLenTable = ::T.let(nil, ::T.untyped)
  UCS2BESMModel = ::T.let(nil, ::T.untyped)
  UCS2BE_cls = ::T.let(nil, ::T.untyped)
  UCS2BE_st = ::T.let(nil, ::T.untyped)
  UCS2LECharLenTable = ::T.let(nil, ::T.untyped)
  UCS2LESMModel = ::T.let(nil, ::T.untyped)
  UCS2LE_cls = ::T.let(nil, ::T.untyped)
  UCS2LE_st = ::T.let(nil, ::T.untyped)
  UDF = ::T.let(nil, ::T.untyped)
  UTF8CharLenTable = ::T.let(nil, ::T.untyped)
  UTF8SMModel = ::T.let(nil, ::T.untyped)
  UTF8_cls = ::T.let(nil, ::T.untyped)
  UTF8_st = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VISUAL_HEBREW_NAME = ::T.let(nil, ::T.untyped)
  Win1250HungarianCharToOrderMap = ::T.let(nil, ::T.untyped)
  Win1250HungarianModel = ::T.let(nil, ::T.untyped)
  Win1251BulgarianModel = ::T.let(nil, ::T.untyped)
  Win1251CyrillicModel = ::T.let(nil, ::T.untyped)
  Win1253GreekModel = ::T.let(nil, ::T.untyped)
  Win1253_CharToOrderMap = ::T.let(nil, ::T.untyped)
  Win1255HebrewModel = ::T.let(nil, ::T.untyped)
  Win1255_CharToOrderMap = ::T.let(nil, ::T.untyped)
end

module ChildProcess
  VERSION = ::T.let(nil, ::T.untyped)
end

class ChildProcess::AbstractProcess
  POLL_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Class
  def json_creatable?(); end
  EMPTY_INHERITABLE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Complex
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

module Concurrent
  NULL = ::T.let(nil, ::T.untyped)
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

Concurrent::Synchronization::Volatile = Concurrent::Synchronization::MriAttrVolatile

class CreateUsers
  def self.down_without_benchmarks(); end

  def self.up_without_benchmarks(); end
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Delegator
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
end

class Delegator
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

class DidYouMean::Formatter
  def initialize(corrections=T.unsafe(nil)); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def receiver(); end
end

module DidYouMean::NameErrorCheckers
  def self.included(*_); end

  def self.new(exception); end
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::SpellChecker
  def correct(input); end

  def initialize(dictionary:); end
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
end

class Dir
  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

Dispatcher = ActionController::Dispatcher

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

module ERB::Util
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE = ::T.let(nil, ::T.untyped)
end

Emitter = Psych::Stream::Emitter

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding
  def self._load(_); end

  def self.locale_charmap(); end
end

module Enumerable
  def chunk(); end

  def chunk_while(); end

  def each_entry(*_); end

  def grep_v(_); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def sum(identity=T.unsafe(nil), &block); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end

  def zip(*_); end
end

class Enumerator
  def each_with_index(); end

end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def force(*_); end

  def slice_when(*_); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir(); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid(); end

  def gid=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end

  def shell(); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid(); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

module Etc
  def self.confstr(_); end

  def self.endgrent(); end

  def self.endpwent(); end

  def self.getgrent(); end

  def self.getgrgid(*_); end

  def self.getgrnam(_); end

  def self.getlogin(); end

  def self.getpwent(); end

  def self.getpwnam(_); end

  def self.getpwuid(*_); end

  def self.group(); end

  def self.nprocessors(); end

  def self.passwd(); end

  def self.setgrent(); end

  def self.setpwent(); end

  def self.sysconf(_); end

  def self.sysconfdir(); end

  def self.systmpdir(); end

  def self.uname(); end
end

class Exception
  FrameworkRegexp = ::T.let(nil, ::T.untyped)
  FrameworkStart = ::T.let(nil, ::T.untyped)
  TraceSubstitutions = ::T.let(nil, ::T.untyped)
end

class Exception
  def self.exception(*_); end
end

class ExitCalledError
end

class ExitCalledError
end

module Faker
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faker::Base
  Letters = ::T.let(nil, ::T.untyped)
  Numbers = ::T.let(nil, ::T.untyped)
  ULetters = ::T.let(nil, ::T.untyped)
end

class Faker::DrivingLicence
  GB_PADDING = ::T.let(nil, ::T.untyped)
  NI_CHANCE = ::T.let(nil, ::T.untyped)
end

class Faker::Finance
  CREDIT_CARD_TYPES = ::T.let(nil, ::T.untyped)
end

class Faker::IDNumber
  BRAZILIAN_ID_FORMAT = ::T.let(nil, ::T.untyped)
  BRAZILIAN_ID_FROM = ::T.let(nil, ::T.untyped)
  BRAZILIAN_ID_TO = ::T.let(nil, ::T.untyped)
  CHECKS = ::T.let(nil, ::T.untyped)
  INVALID_SSN = ::T.let(nil, ::T.untyped)
  ZA_CITIZENSHIP_DIGITS = ::T.let(nil, ::T.untyped)
  ZA_RACE_DIGIT = ::T.let(nil, ::T.untyped)
end

class Faker::Time
  TIME_RANGES = ::T.let(nil, ::T.untyped)
end

class Faker::Types
  CHARACTERS = ::T.let(nil, ::T.untyped)
  COMPLEX_TYPES = ::T.let(nil, ::T.untyped)
  SIMPLE_TYPES = ::T.let(nil, ::T.untyped)
end

class Faker::Vehicle
  MILEAGE_MAX = ::T.let(nil, ::T.untyped)
  MILEAGE_MIN = ::T.let(nil, ::T.untyped)
  SG_CHECKSUM_CHARS = ::T.let(nil, ::T.untyped)
  SG_CHECKSUM_WEIGHTS = ::T.let(nil, ::T.untyped)
  VIN_LETTERS = ::T.let(nil, ::T.untyped)
  VIN_MAP = ::T.let(nil, ::T.untyped)
  VIN_REGEX = ::T.let(nil, ::T.untyped)
  VIN_WEIGHTS = ::T.let(nil, ::T.untyped)
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
  AS_JSON = ::T.let(nil, ::T.untyped)
end

module Fcntl
  FD_CLOEXEC = ::T.let(nil, ::T.untyped)
  F_DUPFD = ::T.let(nil, ::T.untyped)
  F_GETFD = ::T.let(nil, ::T.untyped)
  F_GETFL = ::T.let(nil, ::T.untyped)
  F_GETLK = ::T.let(nil, ::T.untyped)
  F_RDLCK = ::T.let(nil, ::T.untyped)
  F_SETFD = ::T.let(nil, ::T.untyped)
  F_SETFL = ::T.let(nil, ::T.untyped)
  F_SETLK = ::T.let(nil, ::T.untyped)
  F_SETLKW = ::T.let(nil, ::T.untyped)
  F_UNLCK = ::T.let(nil, ::T.untyped)
  F_WRLCK = ::T.let(nil, ::T.untyped)
  O_ACCMODE = ::T.let(nil, ::T.untyped)
  O_APPEND = ::T.let(nil, ::T.untyped)
  O_CREAT = ::T.let(nil, ::T.untyped)
  O_EXCL = ::T.let(nil, ::T.untyped)
  O_NDELAY = ::T.let(nil, ::T.untyped)
  O_NOCTTY = ::T.let(nil, ::T.untyped)
  O_NONBLOCK = ::T.let(nil, ::T.untyped)
  O_RDONLY = ::T.let(nil, ::T.untyped)
  O_RDWR = ::T.let(nil, ::T.untyped)
  O_TRUNC = ::T.let(nil, ::T.untyped)
  O_WRONLY = ::T.let(nil, ::T.untyped)
end

module Fcntl
end

class Fiber
  def resume(*_); end
end

class Fiber
  def self.yield(*_); end
end

class File
  Separator = ::T.let(nil, ::T.untyped)
end

class File::Stat
  def size?(); end
end

class File
  def self.empty?(_); end

  def self.exists?(_); end

  def self.mkfifo(*_); end

end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils::LowMethods
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils::LowMethods
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils::NoWrite
  include ::FileUtils::LowMethods
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils::LowMethods
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
  def to_d(precision=T.unsafe(nil)); end
end

module Forwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_instance_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_instance_delegators(accessor, *methods); end

  def delegate(hash); end

  def instance_delegate(hash); end
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.latest_gc_info(*_); end

  def self.stress=(stress); end

  def self.verify_internal_consistency(); end
end

class Gem::NoAliasYAMLTree
end

class Gem::Package::TarHeader
  def self.oct_or_256based(str); end
end

class Gem::RemoteFetcher
  def s3_uri_signer(uri); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::S3URISigner
  def initialize(uri); end

  def sign(expiration=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end
  BASE64_URI_TRANSLATE = ::T.let(nil, ::T.untyped)
  EC2_METADATA_CREDENTIALS = ::T.let(nil, ::T.untyped)
end

class Gem::S3URISigner::ConfigurationError
  def initialize(message); end
end

class Gem::S3URISigner::ConfigurationError
end

class Gem::S3URISigner::InstanceProfileError
  def initialize(message); end
end

class Gem::S3URISigner::InstanceProfileError
end

class Gem::S3URISigner::S3Config
  def access_key_id(); end

  def access_key_id=(_); end

  def region(); end

  def region=(_); end

  def secret_access_key(); end

  def secret_access_key=(_); end

  def security_token(); end

  def security_token=(_); end
end

class Gem::S3URISigner::S3Config
  def self.[](*_); end

  def self.members(); end
end

class Gem::S3URISigner
end

module Gem::SafeYAML
  PERMITTED_CLASSES = ::T.let(nil, ::T.untyped)
  PERMITTED_SYMBOLS = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::Enumerable
end

Gem::SyckDefaultKey = Psych::Syck::DefaultKey

module Gem::Util
  def self.correct_for_windows_path(path); end
end

module HTML
end

class HTML::CDATA
end

class HTML::CDATA
end

class HTML::Document
  def find(conditions); end

  def find_all(conditions); end

  def initialize(text, strict=T.unsafe(nil), xml=T.unsafe(nil)); end

  def root(); end
end

class HTML::Document
end

class HTML::FullSanitizer
end

class HTML::FullSanitizer
end

class HTML::LinkSanitizer
  def included_tags(); end
end

class HTML::LinkSanitizer
  def self.included_tags(); end

  def self.included_tags=(obj); end
end

class HTML::Node
  def ==(node); end

  def children(); end

  def find(conditions); end

  def find_all(conditions); end

  def initialize(parent, line=T.unsafe(nil), pos=T.unsafe(nil)); end

  def line(); end

  def match(conditions); end

  def parent(); end

  def position(); end

  def tag?(); end

  def validate_conditions(conditions); end
end

class HTML::Node
  def self.parse(parent, line, pos, content, strict=T.unsafe(nil)); end
end

class HTML::Sanitizer
  def process_node(node, result, options); end

  def sanitize(text, options=T.unsafe(nil)); end

  def sanitizeable?(text); end

  def tokenize(text, options); end
end

class HTML::Sanitizer
end

class HTML::Selector
  def attribute_match(equality, value); end

  def initialize(selector, *values); end

  def match(element, first_only=T.unsafe(nil)); end

  def next_element(element, name=T.unsafe(nil)); end

  def next_selector(statement, values); end

  def nth_child(a, b, of_type, reverse); end

  def only_child(of_type); end

  def select(root); end

  def select_first(root); end

  def simple_selector(statement, values, can_negate=T.unsafe(nil)); end
end

class HTML::Selector::InvalidSelectorError
end

class HTML::Selector::InvalidSelectorError
end

class HTML::Selector
  def self.for_class(cls); end

  def self.for_id(id); end
end

class HTML::Tag
  def [](attr); end

  def attributes(); end

  def childless?(xml=T.unsafe(nil)); end

  def closing(); end

  def initialize(parent, line, pos, name, attributes, closing); end

  def name(); end

  def select(selector, *values); end
end

class HTML::Tag
end

class HTML::Text
  def content(); end

  def initialize(parent, line, pos, content); end
end

class HTML::Text
end

class HTML::Tokenizer
  def initialize(text); end

  def line(); end

  def next(); end

  def position(); end
end

class HTML::Tokenizer
end

module HTML::Version
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module HTML::Version
end

class HTML::WhiteListSanitizer
  def allowed_attributes(); end

  def allowed_css_keywords(); end

  def allowed_css_properties(); end

  def allowed_protocols(); end

  def allowed_tags(); end

  def bad_tags(); end

  def contains_bad_protocols?(attr_name, value); end

  def process_attributes_for(node, options); end

  def protocol_separator(); end

  def sanitize_css(style); end

  def shorthand_css_properties(); end

  def uri_attributes(); end
end

class HTML::WhiteListSanitizer
  def self.allowed_attributes(); end

  def self.allowed_attributes=(obj); end

  def self.allowed_css_keywords(); end

  def self.allowed_css_keywords=(obj); end

  def self.allowed_css_properties(); end

  def self.allowed_css_properties=(obj); end

  def self.allowed_protocols(); end

  def self.allowed_protocols=(obj); end

  def self.allowed_tags(); end

  def self.allowed_tags=(obj); end

  def self.bad_tags(); end

  def self.bad_tags=(obj); end

  def self.protocol_separator(); end

  def self.protocol_separator=(obj); end

  def self.shorthand_css_properties(); end

  def self.shorthand_css_properties=(obj); end

  def self.uri_attributes(); end

  def self.uri_attributes=(obj); end
end

module HTML
  def self.selector(statement, *values); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def compact(); end

  def compact!(); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def dig(*_); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def merge!(_); end

  def replace(_); end

  def to_h(); end

  def to_proc(); end

  def transform_values(); end

  def transform_values!(); end

  def update(_); end
end

class Hash
  def self.try_convert(_); end
end

module I18n
  DEFAULT_INTERPOLATION_PATTERNS = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Cache
end

module I18n::Backend::CacheFile
  def load_file(filename); end

  def normalized_path(file); end

  def path_roots(); end

  def path_roots=(path_roots); end
end

module I18n::Backend::CacheFile
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end
end

module I18n::Backend::Cascade
end

class I18n::Backend::Chain
  include ::I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def backends(); end

  def backends=(backends); end

  def eager_load!(); end

  def exists?(locale, key); end

  def init_translations(); end

  def initialize(*backends); end

  def initialized?(); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def namespace_lookup?(result, options); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translate(locale, key, default_options=T.unsafe(nil)); end

  def translations(); end
end

module I18n::Backend::Chain::Implementation
end

class I18n::Backend::Chain
end

module I18n::Backend::Fallbacks
  def exists?(locale, key); end

  def extract_non_symbol_default!(options); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Fallbacks
end

module I18n::Backend::Flatten
  def escape_default_separator(key); end

  def find_link(locale, key); end

  def flatten_keys(hash, escape, prev_key=T.unsafe(nil), &block); end

  def flatten_translations(locale, data, escape, subtree); end

  def links(); end

  def normalize_flat_keys(locale, key, scope, separator); end

  def resolve_link(locale, key); end

  def store_link(locale, key, link); end
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  def self.escape_default_separator(key); end

  def self.normalize_flat_keys(locale, key, scope, separator); end
end

module I18n::Backend::Gettext
  def load_po(filename); end

  def normalize(locale, data); end

  def normalize_pluralization(locale, key, value); end

  def parse(filename); end
end

class I18n::Backend::Gettext::PoData
  def set_comment(msgid_or_sym, comment); end
end

class I18n::Backend::Gettext::PoData
end

module I18n::Backend::Gettext
end

module I18n::Backend::InterpolationCompiler
  def compile_all_strings_in(data); end

  def interpolate(locale, string, values); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  def compile_if_an_interpolation(string); end

  def compile_interpolation_token(key); end

  def compiled_interpolation_body(str); end

  def direct_key(key); end

  def escape_key_sym(key); end

  def escape_plain_str(str); end

  def handle_interpolation_token(interpolation, matchdata); end

  def interpolate_key(key); end

  def interpolate_or_raise_missing(key); end

  def interpolated_str?(str); end

  def missing_key(key); end

  def nil_key(key); end

  def reserved_key(key); end

  def tokenize(str); end
  INTERPOLATION_SYNTAX_PATTERN = ::T.let(nil, ::T.untyped)
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::InterpolationCompiler::Compiler
  extend ::I18n::Backend::InterpolationCompiler::Compiler
end

module I18n::Backend::InterpolationCompiler
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def init_translations(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translations(); end
end

module I18n::Backend::KeyValue::Implementation
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::KeyValue::SubtreeProxy
end

class I18n::Backend::KeyValue
end

module I18n::Backend::Memoize
  def available_locales(); end

  def eager_load!(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Memoize
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

module I18n::Backend::Pluralization
end

module I18n::Backend::Transliterator
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext::Helpers
end

module I18n::Gettext
  def self.extract_scope(msgid, separator); end

  def self.plural_keys(*args); end
end

module I18n::Locale
end

class I18n::Locale::Fallbacks
  def [](locale); end

  def compute(tags, include_defaults=T.unsafe(nil), exclude=T.unsafe(nil)); end

  def defaults(); end

  def defaults=(defaults); end

  def initialize(*mappings); end

  def map(mappings); end
end

class I18n::Locale::Fallbacks
end

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Parents
  def parent(); end

  def parents(); end

  def self_and_parents(); end
end

module I18n::Locale::Tag::Parents
end

class I18n::Locale::Tag::Rfc4646
  include ::I18n::Locale::Tag::Parents
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Locale::Tag::Simple
  include ::I18n::Locale::Tag::Parents
  def initialize(*tag); end

  def subtags(); end

  def tag(); end

  def to_a(); end

  def to_sym(); end
end

class I18n::Locale::Tag::Simple
  def self.tag(tag); end
end

module I18n::Locale::Tag
  def self.implementation(); end

  def self.implementation=(implementation); end

  def self.tag(tag); end
end

module I18n::Locale
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

class I18n::Middleware
end

module I18n::Tests
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  def self.included(base); end
end

module I18n::Tests
end

module I18n
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.fallbacks(); end

  def self.fallbacks=(fallbacks); end

  def self.perform_caching?(); end
end

class IO
  def external_encoding(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def pathconf(_); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.foreach(*_); end

  def self.pipe(*_); end

end

class Iconv
  VERSION = ::T.let(nil, ::T.untyped)
end

class Iconv::BrokenLibrary
  include ::Iconv::Failure
end

class Iconv::BrokenLibrary
end

class Iconv::IllegalSequence
  include ::Iconv::Failure
end

class Iconv::IllegalSequence
end

class Iconv::InvalidCharacter
  include ::Iconv::Failure
end

class Iconv::InvalidCharacter
end

class Iconv::InvalidEncoding
  include ::Iconv::Failure
end

class Iconv::InvalidEncoding
end

class Iconv::OutOfRange
  include ::Iconv::Failure
end

class Iconv::OutOfRange
end

module IniParse
  VERSION = ::T.let(nil, ::T.untyped)
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def digits(*_); end

  def to_bn(); end

  def to_d(); end

  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

Integer::XChar = Builder::XChar

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

JSONTree = Psych::Visitors::JSONTree

module Kconv
  ASCII = ::T.let(nil, ::T.untyped)
  AUTO = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  EUC = ::T.let(nil, ::T.untyped)
  JIS = ::T.let(nil, ::T.untyped)
  NOCONV = ::T.let(nil, ::T.untyped)
  SJIS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  UTF16 = ::T.let(nil, ::T.untyped)
  UTF32 = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

module Kconv
  def self.guess(str); end

  def self.iseuc(str); end

  def self.isjis(str); end

  def self.issjis(str); end

  def self.isutf8(str); end

  def self.kconv(str, to_enc, from_enc=T.unsafe(nil)); end

  def self.toeuc(str); end

  def self.tojis(str); end

  def self.tolocale(str); end

  def self.tosjis(str); end

  def self.toutf16(str); end

  def self.toutf32(str); end

  def self.toutf8(str); end
end

module Kernel
  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def respond_to?(*_); end

end

module Kernel
  def self.`(_); end

  def self.at_exit(); end

  def self.load(*_); end

  def self.require(_); end
end

class LoadError
  def path(); end
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module Marshal
  def self.restore(*_); end
end

Methods = T::Private::Methods

module Mime
  ALL = ::T.let(nil, ::T.untyped)
  ATOM = ::T.let(nil, ::T.untyped)
  CSS = ::T.let(nil, ::T.untyped)
  CSV = ::T.let(nil, ::T.untyped)
  EXTENSION_LOOKUP = ::T.let(nil, ::T.untyped)
  HTML = ::T.let(nil, ::T.untyped)
  ICS = ::T.let(nil, ::T.untyped)
  JS = ::T.let(nil, ::T.untyped)
  JSON = ::T.let(nil, ::T.untyped)
  LOOKUP = ::T.let(nil, ::T.untyped)
  MULTIPART_FORM = ::T.let(nil, ::T.untyped)
  RSS = ::T.let(nil, ::T.untyped)
  SET = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  URL_ENCODED_FORM = ::T.let(nil, ::T.untyped)
  XML = ::T.let(nil, ::T.untyped)
  YAML = ::T.let(nil, ::T.untyped)
end

class MissingSourceFile
  REGEXPS = ::T.let(nil, ::T.untyped)
end

class Module
  def deprecate_constant(*_); end

  def psych_yaml_as(url); end

  def yaml_as(url); end
end

class Module
  def self.used_modules(); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_mon_enter(); end
end

class MonitorMixin::ConditionVariable
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

module MonitorMixin
  def self.extend_object(obj); end
end

module NKF
  ASCII = ::T.let(nil, ::T.untyped)
  AUTO = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  EUC = ::T.let(nil, ::T.untyped)
  JIS = ::T.let(nil, ::T.untyped)
  NKF_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  NKF_VERSION = ::T.let(nil, ::T.untyped)
  NOCONV = ::T.let(nil, ::T.untyped)
  SJIS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  UTF16 = ::T.let(nil, ::T.untyped)
  UTF32 = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module NKF
  def self.guess(_); end

  def self.nkf(_, _1); end
end

class NameError
  include ::DidYouMean::Correctable
  def name(); end

  def receiver(); end
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

Net::HTTPClientErrorCode = Net::HTTPClientError

Net::HTTPFatalErrorCode = Net::HTTPClientError

Net::HTTPInformation::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPInformationCode = Net::HTTPInformation

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRedirectionCode = Net::HTTPRedirection

Net::HTTPRequestURITooLarge = Net::HTTPRequestURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

class Net::HTTP
end

Net::HTTPSession::ProxyDelta = Net::HTTP::ProxyDelta

Net::HTTPSession::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTP
end

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPSuccessCode = Net::HTTPSuccess

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::ProtocRetryError = Net::ProtoRetriableError

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_i(); end
  AS_JSON = ::T.let(nil, ::T.untyped)
  METHOD_CLASS_MAP = ::T.let(nil, ::T.untyped)
  WHINERS = ::T.let(nil, ::T.untyped)
end

class NoMethodError
  include ::DidYouMean::Correctable
  def args(); end

  def private_call?(); end
end

class Numeric
  def finite?(); end

  def infinite?(); end

end

class Object
  include ::PP::ObjectMixin
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  def psych_to_yaml(options=T.unsafe(nil)); end

  def to_yaml(options=T.unsafe(nil)); end

  def to_yaml_properties(); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RAILS_CACHE = ::T.let(nil, ::T.untyped)
  RAILS_DEFAULT_LOGGER = ::T.let(nil, ::T.untyped)
  RAILS_ENV = ::T.let(nil, ::T.untyped)
  RAILS_ROOT = ::T.let(nil, ::T.untyped)
  RAILTIES_PATH = ::T.let(nil, ::T.untyped)
  RELATIVE_RAILS_ROOT = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class ObjectSpace::WeakMap
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

module ObjectSpace
  def self.count_objects(*_); end

  def self.define_finalizer(*_); end

  def self.garbage_collect(*_); end

  def self.undefine_finalizer(_); end
end

module Observable
  def add_observer(observer, func=T.unsafe(nil)); end

  def changed(state=T.unsafe(nil)); end

  def changed?(); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def notify_observers(*arg); end
end

module Observable
end

class OpenSSL::BN
  def /(_); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def tmp_key(); end
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

module Overcommit
  BUG_REPORT_URL = ::T.let(nil, ::T.untyped)
  CONFIG_FILE_NAME = ::T.let(nil, ::T.untyped)
  GIT_VERSION = ::T.let(nil, ::T.untyped)
  HOME = ::T.let(nil, ::T.untyped)
  HOOK_DIRECTORY = ::T.let(nil, ::T.untyped)
  REPO_URL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Overcommit::ConfigurationLoader
  DEFAULT_CONFIG_PATH = ::T.let(nil, ::T.untyped)
end

module Overcommit::GitRepo
  DIFF_HUNK_REGEX = ::T.let(nil, ::T.untyped)
  SUBMODULE_STATUS_REGEX = ::T.let(nil, ::T.untyped)
end

module Overcommit::Hook
  MESSAGE_TYPES = ::T.let(nil, ::T.untyped)
end

class Overcommit::HookSigner
  IGNORED_CONFIG_KEYS = ::T.let(nil, ::T.untyped)
end

class Overcommit::Installer
  MASTER_HOOK = ::T.let(nil, ::T.untyped)
  TEMPLATE_DIRECTORY = ::T.let(nil, ::T.untyped)
end

class Overcommit::MessageProcessor
  ERRORS_GENERIC_HEADER = ::T.let(nil, ::T.untyped)
  ERRORS_MODIFIED_HEADER = ::T.let(nil, ::T.untyped)
  ERRORS_UNMODIFIED_HEADER = ::T.let(nil, ::T.untyped)
  WARNINGS_GENERIC_HEADER = ::T.let(nil, ::T.untyped)
  WARNINGS_MODIFIED_HEADER = ::T.let(nil, ::T.untyped)
  WARNINGS_UNMODIFIED_HEADER = ::T.let(nil, ::T.untyped)
end

module Overcommit::OS
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

ParseError = Racc::ParseError

class Pathname
  def empty?(); end

  def fnmatch?(*_); end

  def make_symlink(_); end

end

class Proc
  def ===(*_); end

  def clone(); end

  def yield(*_); end
end

module Process
  CLOCK_MONOTONIC_RAW_APPROX = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW_APPROX = ::T.let(nil, ::T.untyped)
end

module Process::Sys
  def self.getegid(); end

end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  def self.[](*_); end

  def self.members(); end
end

module Process
  def self.setpgrp(); end

end

module Psych
  DEPRECATED = ::T.let(nil, ::T.untyped)
  LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::BadAlias
end

class Psych::BadAlias
end

class Psych::ClassLoader
  def big_decimal(); end

  def complex(); end

  def date(); end

  def date_time(); end

  def exception(); end

  def load(klassname); end

  def object(); end

  def psych_omap(); end

  def psych_set(); end

  def range(); end

  def rational(); end

  def regexp(); end

  def struct(); end

  def symbol(); end

  def symbolize(sym); end
  BIG_DECIMAL = ::T.let(nil, ::T.untyped)
  CACHE = ::T.let(nil, ::T.untyped)
  COMPLEX = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  DATE_TIME = ::T.let(nil, ::T.untyped)
  EXCEPTION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  PSYCH_OMAP = ::T.let(nil, ::T.untyped)
  PSYCH_SET = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  RATIONAL = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
end

class Psych::ClassLoader::Restricted
  def initialize(classes, symbols); end
end

class Psych::ClassLoader::Restricted
end

class Psych::ClassLoader
end

class Psych::Coder
  def [](k); end

  def []=(k, v); end

  def add(k, v); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(tag); end

  def map(tag=T.unsafe(nil), style=T.unsafe(nil)); end

  def map=(map); end

  def object(); end

  def object=(object); end

  def represent_map(tag, map); end

  def represent_object(tag, obj); end

  def represent_scalar(tag, value); end

  def represent_seq(tag, list); end

  def scalar(*args); end

  def scalar=(value); end

  def seq(); end

  def seq=(list); end

  def style(); end

  def style=(style); end

  def tag(); end

  def tag=(tag); end

  def type(); end
end

class Psych::Coder
end

module Psych::DeprecatedMethods
  def taguri(); end

  def taguri=(taguri); end

  def to_yaml_style(); end

  def to_yaml_style=(to_yaml_style); end
end

module Psych::DeprecatedMethods
end

class Psych::DisallowedClass
  def initialize(klass_name); end
end

class Psych::DisallowedClass
end

class Psych::Emitter
  def alias(_); end

  def canonical(); end

  def canonical=(canonical); end

  def end_document(_); end

  def indentation(); end

  def indentation=(indentation); end

  def initialize(*_); end

  def line_width(); end

  def line_width=(line_width); end

  def scalar(_, _1, _2, _3, _4, _5); end

  def start_document(_, _1, _2); end

  def start_mapping(_, _1, _2, _3); end

  def start_sequence(_, _1, _2, _3); end

  def start_stream(_); end
end

class Psych::Emitter
end

class Psych::Exception
end

class Psych::Exception
end

class Psych::FALLBACK
  def to_ruby(); end

  def to_ruby=(_); end
end

class Psych::FALLBACK
  def self.[](*_); end

  def self.members(); end
end

class Psych::Handler
  def alias(anchor); end

  def empty(); end

  def end_document(implicit); end

  def end_mapping(); end

  def end_sequence(); end

  def end_stream(); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end

  def start_stream(encoding); end

  def streaming?(); end
  EVENTS = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Psych::Handler::DumperOptions
  def canonical(); end

  def canonical=(canonical); end

  def indentation(); end

  def indentation=(indentation); end

  def line_width(); end

  def line_width=(line_width); end
end

class Psych::Handler::DumperOptions
end

class Psych::Handler
end

module Psych::Handlers
end

class Psych::Handlers::DocumentStream
  def initialize(&block); end
end

class Psych::Handlers::DocumentStream
end

module Psych::Handlers
end

module Psych::JSON
end

module Psych::JSON::RubyEvents
  def visit_DateTime(o); end

  def visit_String(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end
end

module Psych::JSON::RubyEvents
end

class Psych::JSON::Stream
  include ::Psych::Streaming
end

class Psych::JSON::Stream::Emitter
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::Stream::Emitter
end

class Psych::JSON::Stream
  extend ::Psych::Streaming::ClassMethods
end

class Psych::JSON::TreeBuilder
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::TreeBuilder
end

module Psych::JSON::YAMLEvents
  def end_document(implicit_end=T.unsafe(nil)); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end
end

module Psych::JSON::YAMLEvents
end

module Psych::JSON
end

module Psych::Nodes
end

class Psych::Nodes::Alias
  def anchor(); end

  def anchor=(anchor); end

  def initialize(anchor); end
end

class Psych::Nodes::Alias
end

class Psych::Nodes::Document
  def implicit(); end

  def implicit=(implicit); end

  def implicit_end(); end

  def implicit_end=(implicit_end); end

  def initialize(version=T.unsafe(nil), tag_directives=T.unsafe(nil), implicit=T.unsafe(nil)); end

  def root(); end

  def tag_directives(); end

  def tag_directives=(tag_directives); end

  def version(); end

  def version=(version); end
end

class Psych::Nodes::Document
end

class Psych::Nodes::Mapping
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Mapping
end

class Psych::Nodes::Node
  include ::Enumerable
  def children(); end

  def each(&block); end

  def tag(); end

  def to_ruby(); end

  def to_yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def transform(); end

  def yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Psych::Nodes::Node
end

class Psych::Nodes::Scalar
  def anchor(); end

  def anchor=(anchor); end

  def initialize(value, anchor=T.unsafe(nil), tag=T.unsafe(nil), plain=T.unsafe(nil), quoted=T.unsafe(nil), style=T.unsafe(nil)); end

  def plain(); end

  def plain=(plain); end

  def quoted(); end

  def quoted=(quoted); end

  def style(); end

  def style=(style); end

  def tag=(tag); end

  def value(); end

  def value=(value); end
  ANY = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTED = ::T.let(nil, ::T.untyped)
  FOLDED = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  PLAIN = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTED = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Scalar
end

class Psych::Nodes::Sequence
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Sequence
end

class Psych::Nodes::Stream
  def encoding(); end

  def encoding=(encoding); end

  def initialize(encoding=T.unsafe(nil)); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Stream
end

module Psych::Nodes
end

class Psych::Omap
end

class Psych::Omap
end

class Psych::Parser
  def external_encoding=(external_encoding); end

  def handler(); end

  def handler=(handler); end

  def initialize(handler=T.unsafe(nil)); end

  def mark(); end

  def parse(*_); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Parser::Mark
end

class Psych::Parser::Mark
end

class Psych::Parser
end

class Psych::ScalarScanner
  def class_loader(); end

  def initialize(class_loader); end

  def parse_int(string); end

  def parse_time(string); end

  def tokenize(string); end
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  TIME = ::T.let(nil, ::T.untyped)
end

class Psych::ScalarScanner
end

class Psych::Set
end

class Psych::Set
end

class Psych::Stream
  include ::Psych::Streaming
end

class Psych::Stream::Emitter
  def end_document(implicit_end=T.unsafe(nil)); end
end

class Psych::Stream::Emitter
end

class Psych::Stream
  extend ::Psych::Streaming::ClassMethods
end

module Psych::Streaming
  def start(encoding=T.unsafe(nil)); end
end

module Psych::Streaming::ClassMethods
  def new(io); end
end

module Psych::Streaming::ClassMethods
end

module Psych::Streaming
end

class Psych::SyntaxError
  def column(); end

  def context(); end

  def file(); end

  def initialize(file, line, col, offset, problem, context); end

  def line(); end

  def offset(); end

  def problem(); end
end

class Psych::SyntaxError
end

class Psych::TreeBuilder
  def end_document(implicit_end=T.unsafe(nil)); end

  def root(); end
end

class Psych::TreeBuilder
end

module Psych::Visitors
end

class Psych::Visitors::DepthFirst
  def initialize(block); end
end

class Psych::Visitors::DepthFirst
end

class Psych::Visitors::Emitter
  def initialize(io, options=T.unsafe(nil)); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::Emitter
end

class Psych::Visitors::JSONTree
  include ::Psych::JSON::RubyEvents
end

class Psych::Visitors::JSONTree
  def self.create(options=T.unsafe(nil)); end
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::ToRuby
  def class_loader(); end

  def initialize(ss, class_loader); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
  SHOVEL = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::ToRuby
  def self.create(); end
end

class Psych::Visitors::Visitor
  def accept(target); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::Visitor
end

class Psych::Visitors::YAMLTree
  def <<(object); end

  def finish(); end

  def finished(); end

  def finished?(); end

  def initialize(emitter, ss, options); end

  def push(object); end

  def start(encoding=T.unsafe(nil)); end

  def started(); end

  def started?(); end

  def tree(); end

  def visit_Array(o); end

  def visit_BasicObject(o); end

  def visit_BigDecimal(o); end

  def visit_Class(o); end

  def visit_Complex(o); end

  def visit_Date(o); end

  def visit_DateTime(o); end

  def visit_Encoding(o); end

  def visit_Exception(o); end

  def visit_FalseClass(o); end

  def visit_Float(o); end

  def visit_Hash(o); end

  def visit_Integer(o); end

  def visit_Module(o); end

  def visit_NameError(o); end

  def visit_NilClass(o); end

  def visit_Object(o); end

  def visit_Psych_Omap(o); end

  def visit_Psych_Set(o); end

  def visit_Range(o); end

  def visit_Rational(o); end

  def visit_Regexp(o); end

  def visit_String(o); end

  def visit_Struct(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end

  def visit_TrueClass(o); end
  BINARY_RANGE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  WS_RANGE = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::YAMLTree
  def self.create(options=T.unsafe(nil), emitter=T.unsafe(nil)); end

  def self.new(emitter=T.unsafe(nil), ss=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Psych::Visitors
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_private_type(type_tag, &block); end

  def self.add_ruby_type(type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.detect_implicit(thing); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.dump_stream(*objects); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load(yaml, filename=T.unsafe(nil), fallback=T.unsafe(nil)); end

  def self.load_documents(yaml, &block); end

  def self.load_file(filename, fallback=T.unsafe(nil)); end

  def self.load_stream(yaml, filename=T.unsafe(nil)); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.object_maker(klass, hash); end

  def self.parse(yaml, filename=T.unsafe(nil), fallback=T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_stream(yaml, filename=T.unsafe(nil), &block); end

  def self.parser(); end

  def self.quick_emit(thing, opts=T.unsafe(nil), &block); end

  def self.read_type_class(type, reference); end

  def self.remove_type(type_tag); end

  def self.safe_load(yaml, whitelist_classes=T.unsafe(nil), whitelist_symbols=T.unsafe(nil), aliases=T.unsafe(nil), filename=T.unsafe(nil)); end

  def self.tagurize(thing); end

  def self.to_json(object); end
end

module REXML
  COPYRIGHT = ::T.let(nil, ::T.untyped)
  Copyright = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  REVISION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

module REXML
end

module RSpec
  MODULES_TO_AUTOLOAD = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  ADDITIONAL_TOP_LEVEL_FILES = ::T.let(nil, ::T.untyped)
  IGNORE_REGEX = ::T.let(nil, ::T.untyped)
  LIB_REGEX = ::T.let(nil, ::T.untyped)
  RSPEC_LIBS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Configuration
  DEFAULT_FORMATTER = ::T.let(nil, ::T.untyped)
  FAILED_STATUS = ::T.let(nil, ::T.untyped)
  MOCKING_ADAPTERS = ::T.let(nil, ::T.untyped)
  PASSED_STATUS = ::T.let(nil, ::T.untyped)
  PENDING_STATUS = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  UNKNOWN_STATUS = ::T.let(nil, ::T.untyped)
  VALID_STATUSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ConfigurationOptions
  OPTIONS_ORDER = ::T.let(nil, ::T.untyped)
  UNFORCED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNPROCESSABLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

RSpec::Core::Example::AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt = RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue

class RSpec::Core::ExampleGroup
  INSTANCE_VARIABLE_TO_IGNORE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ExampleStatusPersister
  def initialize(examples, file_name); end

  def persist(); end
end

class RSpec::Core::ExampleStatusPersister
  def self.load_from(file_name); end

  def self.persist(examples, file_name); end
end

RSpec::Core::ExclusionRules = RSpec::Core::FilterRules

class RSpec::Core::FilterRules
  PROC_HEX_NUMBER = ::T.let(nil, ::T.untyped)
  PROJECT_DIR = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def example_failed(notification); end

  def example_finished(notification); end

  def initialize(expected_failures); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def self.inherited(formatter); end
end

class RSpec::Core::Formatters::BaseFormatter
  def close(_notification); end

  def example_group(); end

  def example_group=(example_group); end

  def example_group_started(notification); end

  def initialize(output); end

  def output(); end

  def start(notification); end
end

class RSpec::Core::Formatters::BaseFormatter
end

class RSpec::Core::Formatters::BaseTextFormatter
  def dump_failures(notification); end

  def dump_pending(notification); end

  def dump_summary(summary); end

  def message(notification); end

  def seed(notification); end
end

class RSpec::Core::Formatters::BaseTextFormatter
end

class RSpec::Core::Formatters::BisectDRbFormatter
  def initialize(_output); end

  def notify_results(results); end
end

class RSpec::Core::Formatters::BisectDRbFormatter
end

module RSpec::Core::Formatters::ConsoleCodes
  VT100_CODES = ::T.let(nil, ::T.untyped)
  VT100_CODE_VALUES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter
  DEPRECATION_STREAM_NOTICE = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_CONFIG_NOTICE = ::T.let(nil, ::T.untyped)
  TOO_MANY_WARNINGS_NOTICE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
  TOO_MANY_USES_LIMIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DocumentationFormatter
  def example_failed(failure); end

  def example_group_finished(_notification); end

  def example_passed(passed); end

  def example_pending(pending); end
end

class RSpec::Core::Formatters::DocumentationFormatter
end

class RSpec::Core::Formatters::ExceptionPresenter
  PENDING_DETAIL_FORMATTER = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::FallbackMessageFormatter
  def initialize(output); end

  def message(notification); end

  def output(); end
end

class RSpec::Core::Formatters::FallbackMessageFormatter
end

module RSpec::Core::Formatters::Helpers
  DEFAULT_PRECISION = ::T.let(nil, ::T.untyped)
  SUB_SECOND_PRECISION = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::HtmlFormatter
  def dump_summary(summary); end

  def example_failed(failure); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::HtmlFormatter
end

class RSpec::Core::Formatters::JsonFormatter
  def dump_profile(profile); end

  def dump_profile_slowest_example_groups(profile); end

  def dump_profile_slowest_examples(profile); end

  def dump_summary(summary); end

  def message(notification); end

  def output_hash(); end

  def seed(notification); end

  def stop(notification); end
end

class RSpec::Core::Formatters::JsonFormatter
end

class RSpec::Core::Formatters::ProfileFormatter
  def dump_profile(profile); end

  def initialize(output); end

  def output(); end
end

class RSpec::Core::Formatters::ProfileFormatter
end

class RSpec::Core::Formatters::ProgressFormatter
  def example_failed(_notification); end

  def example_passed(_notification); end

  def example_pending(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::ProgressFormatter
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  RESET_CODE = ::T.let(nil, ::T.untyped)
end

RSpec::Core::Formatters::SyntaxHighlighter::WindowsImplementation = RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation

class RSpec::Core::Hooks::HookCollections
  EMPTY_HOOK_ARRAY = ::T.let(nil, ::T.untyped)
  HOOK_TYPES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
  SCOPE_ALIASES = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Metadata
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Ordering::Random
  MAX_32_BIT = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Pending
  NOT_YET_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NO_REASON_GIVEN = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Profiler
  def example_group_finished(notification); end

  def example_group_started(notification); end

  def example_groups(); end

  def example_started(notification); end
  NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Profiler
end

class RSpec::Core::Reporter
  RSPEC_NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::SharedContext
  def __shared_context_recordings(); end

  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def context(*args, &block); end

  def describe(*args, &block); end

  def hooks(*args, &block); end

  def included(group); end

  def let(*args, &block); end

  def let!(*args, &block); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end

  def subject(*args, &block); end

  def subject!(*args, &block); end
end

class RSpec::Core::SharedContext::Recording
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def method_name(); end

  def method_name=(_); end

  def playback_onto(group); end
end

class RSpec::Core::SharedContext::Recording
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::SharedContext
  def self.record(methods); end
end

module RSpec::Core::ShellEscape
  SHELLS_ALLOWING_UNQUOTED_IDS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Version
  STRING = ::T.let(nil, ::T.untyped)
end

RSpec::SharedContext = RSpec::Core::SharedContext

module RSpec::Support
  DEFAULT_FAILURE_NOTIFIER = ::T.let(nil, ::T.untyped)
  DEFAULT_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  KERNEL_METHOD_METHOD = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  AVOID_RESCUING = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::Differ
  def color?(); end

  def diff(actual, expected); end

  def diff_as_object(actual, expected); end

  def diff_as_string(actual, expected); end

  def initialize(opts=T.unsafe(nil)); end
end

class RSpec::Support::Differ
end

class RSpec::Support::EncodedString
  ENCODE_NO_CONVERTER = ::T.let(nil, ::T.untyped)
  ENCODE_UNCONVERTABLE_BYTES = ::T.let(nil, ::T.untyped)
  REPLACE = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

RSpec::Support::Mutex = Thread::Mutex

module RSpec::Support::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support
  def self.deregister_matcher_definition(&block); end

  def self.is_a_matcher?(object); end

  def self.matcher_definitions(); end

  def self.register_matcher_definition(&block); end

  def self.rspec_description_for_object(object); end
end

module RSpec::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module Racc
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rack
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Adapter::Camping
  def call(env); end

  def initialize(app); end
end

class Rack::Adapter::Camping
end

class Rack::Auth::AbstractHandler
  def initialize(app, realm=T.unsafe(nil), &authenticator); end

  def realm(); end

  def realm=(realm); end
end

class Rack::Auth::AbstractHandler
end

class Rack::Auth::AbstractRequest
  def initialize(env); end

  def params(); end

  def parts(); end

  def provided?(); end

  def scheme(); end
  AUTHORIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractRequest
end

class Rack::Auth::Basic
  def call(env); end
end

class Rack::Auth::Basic::Request
  def basic?(); end

  def credentials(); end

  def username(); end
end

class Rack::Auth::Basic::Request
end

class Rack::Auth::Basic
end

class Rack::Auth::Digest::MD5
  def call(env); end

  def initialize(*args); end

  def opaque(); end

  def opaque=(opaque); end

  def passwords_hashed=(passwords_hashed); end

  def passwords_hashed?(); end
  QOP = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::MD5
end

class Rack::Auth::Digest::Nonce
  def digest(); end

  def fresh?(); end

  def initialize(timestamp=T.unsafe(nil), given_digest=T.unsafe(nil)); end

  def stale?(); end

  def valid?(); end
end

class Rack::Auth::Digest::Nonce
  def self.parse(string); end

  def self.private_key(); end

  def self.private_key=(private_key); end

  def self.time_limit(); end

  def self.time_limit=(time_limit); end
end

class Rack::Auth::Digest::Params
  def [](k); end

  def []=(k, v); end

  def initialize(); end

  def quote(str); end
  UNQUOTED = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::Params
  def self.dequote(str); end

  def self.parse(str); end

  def self.split_header_value(str); end
end

class Rack::Auth::Digest::Request
  def correct_uri?(); end

  def digest?(); end

  def method(); end

  def method_missing(sym); end

  def nonce(); end
end

class Rack::Auth::Digest::Request
end

class Rack::Builder
  def call(env); end

  def initialize(&block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, &block); end
end

class Rack::Builder
  def self.app(&block); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Rack::Cascade
  def <<(app); end

  def add(app); end

  def apps(); end

  def call(env); end

  def include?(app); end

  def initialize(apps, catch=T.unsafe(nil)); end
  NotFound = ::T.let(nil, ::T.untyped)
end

class Rack::Cascade
end

class Rack::Chunked
  include ::Rack::Utils
  def call(env); end

  def chunk(status, headers, body); end

  def close(); end

  def each(&blk); end

  def initialize(app); end
end

class Rack::Chunked
end

class Rack::CommonLogger
  def call(env); end

  def initialize(app, logger=T.unsafe(nil)); end
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
end

class Rack::ConditionalGet
  def call(env); end

  def initialize(app); end
end

class Rack::ConditionalGet
end

class Rack::Config
  def call(env); end

  def initialize(app, &block); end
end

class Rack::Config
end

class Rack::ContentLength
  include ::Rack::Utils
  def call(env); end

  def initialize(app); end
end

class Rack::ContentLength
end

class Rack::ContentType
  def call(env); end

  def initialize(app, content_type=T.unsafe(nil)); end
end

class Rack::ContentType
end

class Rack::Deflater
  def call(env); end

  def initialize(app); end
end

class Rack::Deflater::DeflateStream
  def each(&blk); end

  def initialize(body); end
  DEFLATE_ARGS = ::T.let(nil, ::T.untyped)
end

class Rack::Deflater::DeflateStream
end

class Rack::Deflater::GzipStream
  def each(&block); end

  def initialize(body, mtime); end

  def write(data); end
end

class Rack::Deflater::GzipStream
end

class Rack::Deflater
end

class Rack::Directory
  def _call(env); end

  def call(env); end

  def check_forbidden(); end

  def each(&blk); end

  def entity_not_found(); end

  def files(); end

  def filesize_format(int); end

  def initialize(root, app=T.unsafe(nil)); end

  def list_directory(); end

  def list_path(); end

  def path(); end

  def path=(path); end

  def root(); end

  def root=(root); end

  def stat(node, max=T.unsafe(nil)); end
  DIR_FILE = ::T.let(nil, ::T.untyped)
  DIR_PAGE = ::T.let(nil, ::T.untyped)
  FILESIZE_FORMAT = ::T.let(nil, ::T.untyped)
end

Rack::Directory::F = File

class Rack::Directory
end

class Rack::ETag
  def call(env); end

  def initialize(app); end
end

class Rack::ETag
end

class Rack::File
  def _call(env); end

  def call(env); end

  def each(&blk); end

  def forbidden(); end

  def initialize(root); end

  def not_found(); end

  def path(); end

  def path=(path); end

  def root(); end

  def root=(root); end

  def serving(); end

  def to_path(); end
end

Rack::File::F = File

class Rack::File
end

class Rack::ForwardRequest
  def env(); end

  def initialize(url, env=T.unsafe(nil)); end

  def url(); end
end

class Rack::ForwardRequest
end

module Rack::Handler
end

class Rack::Handler::CGI
end

class Rack::Handler::CGI
  def self.run(app, options=T.unsafe(nil)); end

  def self.send_body(body); end

  def self.send_headers(status, headers); end

  def self.serve(app); end
end

class Rack::Handler::WEBrick
  def initialize(server, app); end
end

class Rack::Handler::WEBrick
  def self.run(app, options=T.unsafe(nil)); end
end

module Rack::Handler
  def self.default(options=T.unsafe(nil)); end

  def self.get(server); end

  def self.register(server, klass); end

  def self.try_require(prefix, const_name); end
end

class Rack::Head
  def call(env); end

  def initialize(app); end
end

class Rack::Head
end

class Rack::Lint
  include ::Rack::Lint::Assertion
  def _call(env); end

  def call(env=T.unsafe(nil)); end

  def check_content_length(status, headers, env); end

  def check_content_type(status, headers); end

  def check_env(env); end

  def check_error(error); end

  def check_headers(header); end

  def check_input(input); end

  def check_status(status); end

  def close(); end

  def each(&blk); end

  def initialize(app); end
end

module Rack::Lint::Assertion
  def assert(message, &block); end
end

module Rack::Lint::Assertion
end

class Rack::Lint::ErrorWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def flush(); end

  def initialize(error); end

  def puts(str); end

  def write(str); end
end

class Rack::Lint::ErrorWrapper
end

class Rack::Lint::InputWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def each(*args, &blk); end

  def gets(*args); end

  def initialize(input); end

  def read(*args); end

  def rewind(*args); end

  def size(); end
end

class Rack::Lint::InputWrapper
end

class Rack::Lint::LintError
end

class Rack::Lint::LintError
end

class Rack::Lint
end

class Rack::Lock
  FLAG = ::T.let(nil, ::T.untyped)
end

class Rack::Logger
  def call(env); end

  def initialize(app, level=T.unsafe(nil)); end
end

class Rack::Logger
end

class Rack::MethodOverride
  def call(env); end

  def initialize(app); end
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_OVERRIDE_HEADER = ::T.let(nil, ::T.untyped)
  METHOD_OVERRIDE_PARAM_KEY = ::T.let(nil, ::T.untyped)
end

class Rack::MethodOverride
end

module Rack::Mime
  MIME_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Mime
  def self.mime_type(ext, fallback=T.unsafe(nil)); end
end

class Rack::MockRequest
  def delete(uri, opts=T.unsafe(nil)); end

  def get(uri, opts=T.unsafe(nil)); end

  def initialize(app); end

  def post(uri, opts=T.unsafe(nil)); end

  def put(uri, opts=T.unsafe(nil)); end

  def request(method=T.unsafe(nil), uri=T.unsafe(nil), opts=T.unsafe(nil)); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class Rack::MockRequest::FatalWarner
  def flush(); end

  def puts(warning); end

  def string(); end

  def write(warning); end
end

class Rack::MockRequest::FatalWarner
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest
  def self.env_for(uri=T.unsafe(nil), opts=T.unsafe(nil)); end
end

class Rack::MockResponse
  include ::Rack::Response::Helpers
  def =~(other); end

  def [](field); end

  def body(); end

  def errors(); end

  def errors=(errors); end

  def initialize(status, headers, body, errors=T.unsafe(nil)); end

  def match(other); end

  def status(); end
end

class Rack::MockResponse
end

class Rack::NullLogger
  def call(env); end

  def debug(progname=T.unsafe(nil), &block); end

  def error(progname=T.unsafe(nil), &block); end

  def fatal(progname=T.unsafe(nil), &block); end

  def info(progname=T.unsafe(nil), &block); end

  def initialize(app); end

  def warn(progname=T.unsafe(nil), &block); end
end

class Rack::NullLogger
end

class Rack::Recursive
  def call(env); end

  def include(env, path); end

  def initialize(app); end
end

class Rack::Recursive
end

class Rack::Reloader
  def call(env); end

  def initialize(app, cooldown=T.unsafe(nil), backend=T.unsafe(nil)); end

  def reload!(stderr=T.unsafe(nil)); end

  def safe_load(file, mtime, stderr=T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  def figure_path(file, paths); end

  def rotation(); end

  def safe_stat(file); end
end

module Rack::Reloader::Stat
end

class Rack::Reloader
end

class Rack::Request
  def GET(); end

  def POST(); end

  def [](key); end

  def []=(key, value); end

  def accept_encoding(); end

  def body(); end

  def content_charset(); end

  def content_length(); end

  def content_type(); end

  def cookies(); end

  def delete?(); end

  def env(); end

  def form_data?(); end

  def fullpath(); end

  def get?(); end

  def head?(); end

  def host(); end

  def host_with_port(); end

  def initialize(env); end

  def ip(); end

  def logger(); end

  def media_type(); end

  def media_type_params(); end

  def params(); end

  def parse_multipart(env); end

  def parse_query(qs); end

  def parseable_data?(); end

  def path(); end

  def path_info(); end

  def path_info=(s); end

  def port(); end

  def post?(); end

  def put?(); end

  def query_string(); end

  def referer(); end

  def referrer(); end

  def request_method(); end

  def scheme(); end

  def script_name(); end

  def script_name=(s); end

  def session(); end

  def session_options(); end

  def url(); end

  def user_agent(); end

  def values_at(*keys); end

  def xhr?(); end
  FORM_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
  PARSEABLE_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
end

class Rack::Request
end

class Rack::Response
  include ::Rack::Response::Helpers
  def [](key); end

  def []=(key, value); end

  def body(); end

  def body=(body); end

  def close(); end

  def delete_cookie(key, value=T.unsafe(nil)); end

  def each(&callback); end

  def finish(&block); end

  def header(); end

  def initialize(body=T.unsafe(nil), status=T.unsafe(nil), header=T.unsafe(nil), &block); end

  def length(); end

  def length=(length); end

  def redirect(target, status=T.unsafe(nil)); end

  def set_cookie(key, value); end

  def status(); end

  def status=(status); end

  def to_a(&block); end

  def write(str); end
end

module Rack::Response::Helpers
  def client_error?(); end

  def content_length(); end

  def content_type(); end

  def empty?(); end

  def forbidden?(); end

  def headers(); end

  def include?(header); end

  def informational?(); end

  def invalid?(); end

  def location(); end

  def not_found?(); end

  def ok?(); end

  def original_headers(); end

  def redirect?(); end

  def redirection?(); end

  def server_error?(); end

  def successful?(); end
end

module Rack::Response::Helpers
end

class Rack::Response
end

class Rack::Runtime
  def call(env); end

  def initialize(app, name=T.unsafe(nil)); end
end

class Rack::Runtime
end

class Rack::Sendfile
  def call(env); end

  def initialize(app, variation=T.unsafe(nil)); end
end

Rack::Sendfile::F = File

class Rack::Sendfile
end

class Rack::Server
  def app(); end

  def default_options(); end

  def initialize(options=T.unsafe(nil)); end

  def middleware(); end

  def options(); end

  def options=(options); end

  def server(); end

  def start(); end
end

class Rack::Server::Options
  def parse!(args); end
end

class Rack::Server::Options
end

class Rack::Server
  def self.middleware(); end

  def self.start(); end
end

module Rack::Session::Abstract
end

class Rack::Session::Abstract::ID
  def call(env); end

  def context(env, app=T.unsafe(nil)); end

  def default_options(); end

  def initialize(app, options=T.unsafe(nil)); end

  def key(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::ID
end

module Rack::Session::Abstract
end

class Rack::Session::Cookie
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Rack::Session::Cookie
end

class Rack::Session::Memcache
  def get_session(env, session_id); end

  def mutex(); end

  def pool(); end

  def set_session(env, session_id, new_session, options); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Memcache
end

class Rack::Session::Pool
  def mutex(); end

  def pool(); end

  def set_session(env, session_id, new_session, options); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Pool
end

class Rack::ShowExceptions
  def call(env); end

  def h(obj); end

  def initialize(app); end

  def pretty(env, exception); end
  CONTEXT = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
end

class Rack::ShowStatus
  def call(env); end

  def h(obj); end

  def initialize(app); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
end

class Rack::Static
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Rack::Static
end

class Rack::URLMap
  def call(env); end

  def initialize(map=T.unsafe(nil)); end

  def remap(map); end
end

class Rack::URLMap
end

module Rack::Utils
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_TO_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

module Rack::Utils::Multipart
  EOL = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
end

class Rails::Boot
  def run(); end
end

class Rails::Boot
end

class Rails::GemBoot
  def load_initializer(); end

  def load_rails_gem(); end
end

class Rails::GemBoot
  def self.gem_version(); end

  def self.load_rubygems(); end

  def self.parse_gem_version(text); end

  def self.rubygems_version(); end
end

class Rails::Rack::Debugger
  def call(env); end

  def initialize(app); end
end

class Rails::Rack::Debugger
end

class Rails::Rack::LogTailer
  def call(env); end

  def initialize(app, log=T.unsafe(nil)); end

  def tail_log(); end
  EnvironmentLog = ::T.let(nil, ::T.untyped)
end

class Rails::Rack::LogTailer
end

class Rails::Rack::Metal
  NotFound = ::T.let(nil, ::T.untyped)
  NotFoundResponse = ::T.let(nil, ::T.untyped)
end

class Rails::Rack::Static
  def call(env); end

  def initialize(app); end
  FILE_METHODS = ::T.let(nil, ::T.untyped)
end

class Rails::Rack::Static
end

module Rails::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class Rails::VendorBoot
  def load_initializer(); end
end

class Rails::VendorBoot
end

module Rails
  def self.boot!(); end

  def self.booted?(); end

  def self.pick_boot(); end

  def self.preinitialize(); end

  def self.preinitializer_path(); end

  def self.vendor_rails?(); end
end

class Random
  def self.raw_seed(_); end
end

class Rational
  def to_d(precision); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.ruby(); end
end

class Regexp
  def match?(*_); end
end

class Regexp
  def self.optionalize(pattern); end

  def self.union(*_); end

  def self.unoptionalize(pattern); end
end

class RubyVM::InstructionSequence
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end
end

class RubyVM::InstructionSequence
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

class RubyVM
  def self.stat(*_); end
end

module SQLite3
  SQLITE_VERSION = ::T.let(nil, ::T.untyped)
  SQLITE_VERSION_NUMBER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class SQLite3::Blob
end

class SQLite3::Blob
end

module SQLite3::Constants::ColumnType
  BLOB = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::ErrorCode
  ABORT = ::T.let(nil, ::T.untyped)
  AUTH = ::T.let(nil, ::T.untyped)
  BUSY = ::T.let(nil, ::T.untyped)
  CANTOPEN = ::T.let(nil, ::T.untyped)
  CONSTRAINT = ::T.let(nil, ::T.untyped)
  CORRUPT = ::T.let(nil, ::T.untyped)
  DONE = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  FULL = ::T.let(nil, ::T.untyped)
  INTERNAL = ::T.let(nil, ::T.untyped)
  INTERRUPT = ::T.let(nil, ::T.untyped)
  IOERR = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MISMATCH = ::T.let(nil, ::T.untyped)
  MISUSE = ::T.let(nil, ::T.untyped)
  NOLFS = ::T.let(nil, ::T.untyped)
  NOMEM = ::T.let(nil, ::T.untyped)
  NOTFOUND = ::T.let(nil, ::T.untyped)
  OK = ::T.let(nil, ::T.untyped)
  PERM = ::T.let(nil, ::T.untyped)
  PROTOCOL = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  ROW = ::T.let(nil, ::T.untyped)
  SCHEMA = ::T.let(nil, ::T.untyped)
  TOOBIG = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::Open
  AUTOPROXY = ::T.let(nil, ::T.untyped)
  CREATE = ::T.let(nil, ::T.untyped)
  DELETEONCLOSE = ::T.let(nil, ::T.untyped)
  EXCLUSIVE = ::T.let(nil, ::T.untyped)
  FULLMUTEX = ::T.let(nil, ::T.untyped)
  MAIN_DB = ::T.let(nil, ::T.untyped)
  MAIN_JOURNAL = ::T.let(nil, ::T.untyped)
  MASTER_JOURNAL = ::T.let(nil, ::T.untyped)
  MEMORY = ::T.let(nil, ::T.untyped)
  NOMUTEX = ::T.let(nil, ::T.untyped)
  PRIVATECACHE = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  READWRITE = ::T.let(nil, ::T.untyped)
  SHAREDCACHE = ::T.let(nil, ::T.untyped)
  SUBJOURNAL = ::T.let(nil, ::T.untyped)
  TEMP_DB = ::T.let(nil, ::T.untyped)
  TEMP_JOURNAL = ::T.let(nil, ::T.untyped)
  TRANSIENT_DB = ::T.let(nil, ::T.untyped)
  URI = ::T.let(nil, ::T.untyped)
  WAL = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::Open
end

module SQLite3::Constants::TextRep
  ANY = ::T.let(nil, ::T.untyped)
  UTF16 = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

module SQLite3::Pragmas
  AUTO_VACUUM_MODES = ::T.let(nil, ::T.untyped)
  ENCODINGS = ::T.let(nil, ::T.untyped)
  JOURNAL_MODES = ::T.let(nil, ::T.untyped)
  LOCKING_MODES = ::T.let(nil, ::T.untyped)
  SYNCHRONOUS_MODES = ::T.let(nil, ::T.untyped)
  TEMP_STORE_MODES = ::T.let(nil, ::T.untyped)
  WAL_CHECKPOINTS = ::T.let(nil, ::T.untyped)
end

module SQLite3::VersionProxy
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

ScanError = StringScanner::Error

module SecureRandom
end

module SecureRandom
  extend ::Random::Formatter
  def self.bytes(n); end
end

class Set
  def ==(other); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module Shellwords
end

module Shellwords
  def self.escape(str); end

  def self.join(array); end

  def self.shellescape(str); end

  def self.shelljoin(array); end

  def self.shellsplit(line); end

  def self.shellwords(line); end

  def self.split(line); end
end

class SignalException
  def signm(); end

  def signo(); end
end

module SingleForwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_single_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_single_delegators(accessor, *methods); end

  def delegate(hash); end

  def single_delegate(hash); end
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache
  def all_module_aliases(); end

  def all_module_names(); end

  def all_named_modules(); end

  def class_by_name(name); end

  def name_by_class(klass); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def aliases(); end

  def aliases=(_); end

  def const(); end

  def const=(_); end

  def const_name(); end

  def const_name=(_); end

  def found_name(); end

  def found_name=(_); end

  def owner(); end

  def owner=(_); end

  def primary_name(); end

  def primary_name=(_); end
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::ConstantLookupCache
end

class Sorbet::Private::CreateConfig
  include ::Sorbet::Private::StepInterface
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::CreateConfig
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::FetchRBIs
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
  SORBET_RBI_LIST = ::T.let(nil, ::T.untyped)
  SORBET_RBI_SORBET_TYPED = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REPO = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REVISION = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FetchRBIs
  def self.fetch_sorbet_typed(); end

  def self.main(); end

  def self.matching_version_directories(root, version); end

  def self.output_file(); end

  def self.paths_for_gem_version(gemspec); end

  def self.paths_for_ruby_version(ruby_version); end

  def self.vendor_rbis_within_paths(vendor_paths); end
end

class Sorbet::Private::FindGemRBIs
  include ::Sorbet::Private::StepInterface
  GEM_DIR = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FindGemRBIs
  def self.main(); end

  def self.output_file(); end

  def self.paths_within_gem_sources(gemspec); end
end

module Sorbet::Private::GemGeneratorTracepoint
  include ::Sorbet::Private::StepInterface
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def defs(); end

  def defs=(_); end

  def id(); end

  def id=(_); end

  def klass(); end

  def klass=(_); end
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
  def initialize(files:, delegate_classes:); end

  def serialize(output_dir); end
  BAD_METHODS = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
  def self.add_to_context(item); end

  def self.disable_tracepoints(); end

  def self.finish(); end

  def self.install_tracepoints(); end

  def self.on_method_added(mod, method, singleton); end

  def self.on_module_created(mod); end

  def self.on_module_extended(extended, extender); end

  def self.on_module_included(included, includer); end

  def self.pre_cache_module_methods(); end

  def self.register_delegate_class(klass, delegate); end

  def self.start(); end

  def self.trace(); end

  def self.trace_results(); end
end

module Sorbet::Private::GemGeneratorTracepoint
  def self.main(output_dir=T.unsafe(nil)); end

  def self.output_file(); end
end

class Sorbet::Private::GemLoader
  GEM_LOADER = ::T.let(nil, ::T.untyped)
  NO_GEM = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemLoader
  def self.my_require(gem); end

  def self.require_all_gems(); end

  def self.require_gem(gem); end
end

class Sorbet::Private::HiddenMethodFinder
  include ::Sorbet::Private::StepInterface
  def all_modules_and_aliases(); end

  def capture_stderr(); end

  def constant_cache(); end

  def gen_source_rbi(classes, aliases); end

  def looks_like_stub_name(name); end

  def main(); end

  def mk_dir(); end

  def read_constants(); end

  def real_name(mod); end

  def require_everything(); end

  def rm_dir(); end

  def serialize_alias(source_entry, rbi_entry, my_klass, source_symbols, rbi_symbols); end

  def serialize_class(source_entry, rbi_entry, klass, source_symbols, rbi_symbols, source_by_name); end

  def serialize_constants(source, rbi, klass, is_singleton, source_symbols, rbi_symbols); end

  def symbols_id_to_name(entry, prefix); end

  def write_constants(); end

  def write_diff(source, rbi); end
  BLACKLIST = ::T.let(nil, ::T.untyped)
  DIFF_RBI = ::T.let(nil, ::T.untyped)
  ERRORS_RBI = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  HIDDEN_RBI = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  TMP_PATH = ::T.let(nil, ::T.untyped)
  TMP_RBI = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::HiddenMethodFinder
  def self.main(); end

  def self.output_file(); end
end

module Sorbet::Private::Main
end

module Sorbet::Private::Main
  def self.cyan(msg); end

  def self.emojify(emoji, msg); end

  def self.init(); end

  def self.main(argv); end

  def self.make_step(step); end

  def self.usage(); end

  def self.yellow(msg); end
end

module Sorbet::Private::RealStdlib
end

module Sorbet::Private::RealStdlib
  def self.real_ancestors(mod); end

  def self.real_autoload?(o, klass); end

  def self.real_const_get(obj, const, arg); end

  def self.real_constants(mod); end

  def self.real_eqeq(obj, other); end

  def self.real_hash(o); end

  def self.real_instance_methods(mod, arg); end

  def self.real_is_a?(o, klass); end

  def self.real_name(o); end

  def self.real_object_id(o); end

  def self.real_private_instance_methods(mod, arg); end

  def self.real_singleton_class(obj); end

  def self.real_singleton_methods(mod, arg); end

  def self.real_spaceship(obj, arg); end

  def self.real_superclass(o); end
end

class Sorbet::Private::RequireEverything
end

class Sorbet::Private::RequireEverything
  def self.excluded_rails_files(); end

  def self.load_bundler(); end

  def self.load_rails(); end

  def self.my_require(abs_path, numerator, denominator); end

  def self.patch_kernel(); end

  def self.rails?(); end

  def self.rails_load_paths(); end

  def self.rb_file_paths(); end

  def self.require_all_files(); end

  def self.require_everything(); end
end

class Sorbet::Private::Serialize
  def alias(base, other_name); end

  def ancestor_has_method(method, klass); end

  def blacklisted_method(method); end

  def class_or_module(class_name); end

  def comparable?(value); end

  def constant(const, value); end

  def from_method(method); end

  def initialize(constant_cache); end

  def serialize_method(method, static=T.unsafe(nil), with_sig: T.unsafe(nil)); end

  def serialize_sig(parameters); end

  def to_sig(kind, name); end

  def valid_class_name(name); end

  def valid_method_name(name); end
  BLACKLIST_CONSTANTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::Serialize
  def self.header(typed=T.unsafe(nil), subcommand=T.unsafe(nil)); end
end

module Sorbet::Private::Status
end

module Sorbet::Private::Status
  def self.done(); end

  def self.say(message, print_without_tty: T.unsafe(nil)); end
end

module Sorbet::Private::StepInterface
end

module Sorbet::Private::StepInterface
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::SuggestTyped
  include ::Sorbet::Private::StepInterface
end

class Sorbet::Private::SuggestTyped
  def self.main(); end

  def self.output_file(); end

  def self.suggest_typed(); end
end

class Sorbet::Private::TodoRBI
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::TodoRBI
  def self.main(); end

  def self.output_file(); end
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class StopIteration
  def result(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def +@(); end

  def -@(); end

  def []=(*_); end

  def casecmp?(_); end

  def encode(*_); end

  def encode!(*_); end

  def iseuc(); end

  def isjis(); end

  def issjis(); end

  def isutf8(); end

  def kconv(to_enc, from_enc=T.unsafe(nil)); end

  def reverse!(); end

  def shellescape(); end

  def shellsplit(); end

  def succ!(); end

  def to_d(); end

  def toeuc(); end

  def tojis(); end

  def tolocale(); end

  def tosjis(); end

  def toutf16(); end

  def toutf32(); end

  def toutf8(); end

  def unicode_normalize(form=T.unsafe(nil)); end

  def unicode_normalize!(form=T.unsafe(nil)); end

  def unicode_normalized?(form=T.unsafe(nil)); end

  def unpack1(_); end

end

class StringIO
  def length(); end

  def truncate(_); end
end

class StringScanner
  def <<(_); end

  def [](_); end

  def beginning_of_line?(); end

  def bol?(); end

  def charpos(); end

  def check(_); end

  def check_until(_); end

  def clear(); end

  def concat(_); end

  def empty?(); end

  def exist?(_); end

  def get_byte(); end

  def getbyte(); end

  def initialize(*_); end

  def match?(_); end

  def matched(); end

  def matched?(); end

  def matched_size(); end

  def peek(_); end

  def peep(_); end

  def pointer(); end

  def pointer=(pointer); end

  def pos(); end

  def pos=(pos); end

  def post_match(); end

  def pre_match(); end

  def reset(); end

  def rest(); end

  def rest?(); end

  def rest_size(); end

  def restsize(); end

  def scan_full(_, _1, _2); end

  def scan_until(_); end

  def search_full(_, _1, _2); end

  def skip(_); end

  def skip_until(_); end

  def string(); end

  def string=(string); end

  def terminate(); end

  def unscan(); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def self.must_C_version(); end
end

class Struct
  def [](_); end

  def []=(_, _1); end

  def dig(*_); end

  def each_pair(); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

module Psych::Syck
end

Syck::DefaultKey = Psych::Syck::DefaultKey

module Psych::Syck
end

class SystemCallError
  def errno(); end
end

class SystemExit
  def status(); end

  def success?(); end
end

module TMail
  DEFAULT_CONFIG = ::T.let(nil, ::T.untyped)
  DEFAULT_STRICT_CONFIG = ::T.let(nil, ::T.untyped)
end

class TMail::AddressHeader
  PARSE_TYPE = ::T.let(nil, ::T.untyped)
end

class TMail::ContentDispositionHeader
  PARSE_TYPE = ::T.let(nil, ::T.untyped)
end

class TMail::ContentTransferEncodingHeader
  PARSE_TYPE = ::T.let(nil, ::T.untyped)
end

class TMail::ContentTypeHeader
  PARSE_TYPE = ::T.let(nil, ::T.untyped)
end

class TMail::DateTimeHeader
  PARSE_TYPE = ::T.let(nil, ::T.untyped)
end

class TMail::Decoder
  ENCODED_WORDS = ::T.let(nil, ::T.untyped)
  OUTPUT_ENCODING = ::T.let(nil, ::T.untyped)
  SPACER = ::T.let(nil, ::T.untyped)
end

class TMail::DeleteFields
  NOSEND_FIELDS = ::T.let(nil, ::T.untyped)
end

class TMail::Encoder
  BENCODE_DEBUG = ::T.let(nil, ::T.untyped)
  MAX_LINE_LEN = ::T.let(nil, ::T.untyped)
  METHOD_ID = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  RFC_2822_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  SPACER = ::T.let(nil, ::T.untyped)
end

class TMail::EncryptedHeader
  PARSE_TYPE = ::T.let(nil, ::T.untyped)
end

class TMail::HeaderField
  FNAME_TO_CLASS = ::T.let(nil, ::T.untyped)
end

class TMail::KeywordsHeader
  PARSE_TYPE = ::T.let(nil, ::T.untyped)
end

class TMail::Mail
  ALLOW_MULTIPLE = ::T.let(nil, ::T.untyped)
  FIELD_ORDER = ::T.let(nil, ::T.untyped)
  NOSEND_FIELDS = ::T.let(nil, ::T.untyped)
  USE_ARRAY = ::T.let(nil, ::T.untyped)
end

class TMail::Maildir
  TOO_OLD = ::T.let(nil, ::T.untyped)
end

TMail::Maildir::PORT_CLASS = TMail::MaildirPort

TMail::MaildirLoader = TMail::Maildir

class TMail::MaildirPort
  MAIL_FILE = ::T.let(nil, ::T.untyped)
end

TMail::MboxLoader = TMail::UNIXMbox

TMail::MhLoader = TMail::MhMailbox

TMail::MhMailbox::PORT_CLASS = TMail::MhPort

class TMail::MimeVersionHeader
  PARSE_TYPE = ::T.let(nil, ::T.untyped)
end

class TMail::Parser
  MAILP_DEBUG = ::T.let(nil, ::T.untyped)
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class TMail::ReceivedHeader
  PARSE_TYPE = ::T.let(nil, ::T.untyped)
end

class TMail::ReturnPathHeader
  PARSE_TYPE = ::T.let(nil, ::T.untyped)
end

TMail::Scanner = TMail::TMailScanner

class TMail::TMailScanner
  MIME_HEADERS = ::T.let(nil, ::T.untyped)
  PATTERN_TABLE = ::T.let(nil, ::T.untyped)
  RECV_TOKEN = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

module TMail::TextUtils
  ATOM_UNSAFE = ::T.let(nil, ::T.untyped)
  CONTROL_CHAR = ::T.let(nil, ::T.untyped)
  MESSAGE_ID = ::T.let(nil, ::T.untyped)
  MIME_ENCODED = ::T.let(nil, ::T.untyped)
  MONTH = ::T.let(nil, ::T.untyped)
  NKF_FLAGS = ::T.let(nil, ::T.untyped)
  PHRASE_UNSAFE = ::T.let(nil, ::T.untyped)
  RFC2231_ENCODED = ::T.let(nil, ::T.untyped)
  TOKEN_UNSAFE = ::T.let(nil, ::T.untyped)
  WDAY = ::T.let(nil, ::T.untyped)
  ZONESTR_TABLE = ::T.let(nil, ::T.untyped)
end

module TMail::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class Tempfile
  def _close(); end

  def inspect(); end
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

class Text::Format
  def ==(o); end

  def abbreviations(); end

  def abbreviations=(abbreviations); end

  def body_indent(); end

  def body_indent=(b); end

  def center(to_center=T.unsafe(nil)); end

  def columns(); end

  def columns=(c); end

  def expand(to_expand=T.unsafe(nil)); end

  def extra_space(); end

  def extra_space=(extra_space); end

  def first_indent(); end

  def first_indent=(f); end

  def format(to_wrap=T.unsafe(nil)); end

  def format_style(); end

  def format_style=(fs); end

  def hard_margins(); end

  def hard_margins=(hard_margins); end

  def hyphenate_to(word, size); end

  def hyphenator(); end

  def hyphenator=(h); end

  def initialize(arg=T.unsafe(nil), &block); end

  def justify?(); end

  def left_align?(); end

  def left_margin(); end

  def left_margin=(left); end

  def nobreak(); end

  def nobreak=(nobreak); end

  def nobreak_regex(); end

  def nobreak_regex=(nobreak_regex); end

  def paragraphs(to_wrap=T.unsafe(nil)); end

  def right_align?(); end

  def right_fill?(); end

  def right_margin(); end

  def right_margin=(r); end

  def split_rules(); end

  def split_rules=(s); end

  def split_words(); end

  def tabstop(); end

  def tabstop=(t); end

  def tag_paragraph(); end

  def tag_paragraph=(tag_paragraph); end

  def tag_text(); end

  def tag_text=(tag_text); end

  def text(); end

  def text=(text); end

  def unexpand(to_unexpand=T.unsafe(nil)); end
  ABBREV = ::T.let(nil, ::T.untyped)
  JUSTIFY = ::T.let(nil, ::T.untyped)
  LEFT_ALIGN = ::T.let(nil, ::T.untyped)
  LEQ_RE = ::T.let(nil, ::T.untyped)
  RIGHT_ALIGN = ::T.let(nil, ::T.untyped)
  RIGHT_FILL = ::T.let(nil, ::T.untyped)
  SPLIT_ALL = ::T.let(nil, ::T.untyped)
  SPLIT_CONTINUATION = ::T.let(nil, ::T.untyped)
  SPLIT_CONTINUATION_FIXED = ::T.let(nil, ::T.untyped)
  SPLIT_FIXED = ::T.let(nil, ::T.untyped)
  SPLIT_HYPHENATION = ::T.let(nil, ::T.untyped)
  SPLIT_HYPHENATION_CONTINUATION = ::T.let(nil, ::T.untyped)
  SPLIT_HYPHENATION_FIXED = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Text::Format::SplitWord
  def first(); end

  def initialize(word, first, rest); end

  def rest(); end

  def word(); end
end

class Text::Format::SplitWord
end

class Text::Format
end

class TracePoint
  def event(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
  AS_JSON = ::T.let(nil, ::T.untyped)
end

module URI
  include ::URI::RFC2396_REGEXP
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

class URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::Generic
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
end

class URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_registry(); end
end

class URI::HTTP
  def request_uri(); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.get_encoding(label); end
end

class UnboundMethod
  def clone(); end

  def original_name(); end
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

class User
  def password_confirmation(); end

  def password_confirmation=(password_confirmation); end
end

Visitor = Psych::Visitors::Visitor

module Warning
  def warn(_); end
end

module Warning
  extend ::Warning
end

class WillPaginate::InvalidPage
  BIGINT = ::T.let(nil, ::T.untyped)
end

YAML = Psych

YAMLTree = Psych::Visitors::YAMLTree

module Zlib
  ASCII = ::T.let(nil, ::T.untyped)
  BEST_COMPRESSION = ::T.let(nil, ::T.untyped)
  BEST_SPEED = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  DEFAULT_COMPRESSION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRATEGY = ::T.let(nil, ::T.untyped)
  DEF_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  FILTERED = ::T.let(nil, ::T.untyped)
  FINISH = ::T.let(nil, ::T.untyped)
  FIXED = ::T.let(nil, ::T.untyped)
  FULL_FLUSH = ::T.let(nil, ::T.untyped)
  HUFFMAN_ONLY = ::T.let(nil, ::T.untyped)
  MAX_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  MAX_WBITS = ::T.let(nil, ::T.untyped)
  NO_COMPRESSION = ::T.let(nil, ::T.untyped)
  NO_FLUSH = ::T.let(nil, ::T.untyped)
  OS_AMIGA = ::T.let(nil, ::T.untyped)
  OS_ATARI = ::T.let(nil, ::T.untyped)
  OS_CODE = ::T.let(nil, ::T.untyped)
  OS_CPM = ::T.let(nil, ::T.untyped)
  OS_MACOS = ::T.let(nil, ::T.untyped)
  OS_MSDOS = ::T.let(nil, ::T.untyped)
  OS_OS2 = ::T.let(nil, ::T.untyped)
  OS_QDOS = ::T.let(nil, ::T.untyped)
  OS_RISCOS = ::T.let(nil, ::T.untyped)
  OS_TOPS20 = ::T.let(nil, ::T.untyped)
  OS_UNIX = ::T.let(nil, ::T.untyped)
  OS_UNKNOWN = ::T.let(nil, ::T.untyped)
  OS_VMCMS = ::T.let(nil, ::T.untyped)
  OS_VMS = ::T.let(nil, ::T.untyped)
  OS_WIN32 = ::T.let(nil, ::T.untyped)
  OS_ZSYSTEM = ::T.let(nil, ::T.untyped)
  RLE = ::T.let(nil, ::T.untyped)
  SYNC_FLUSH = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  ZLIB_VERSION = ::T.let(nil, ::T.untyped)
end

class Zlib::BufError
end

class Zlib::BufError
end

class Zlib::DataError
end

class Zlib::DataError
end

class Zlib::Deflate
  def <<(_); end

  def deflate(*_); end

  def flush(*_); end

  def initialize(*_); end

  def params(_, _1); end

  def set_dictionary(_); end
end

class Zlib::Deflate
  def self.deflate(*_); end
end

class Zlib::Error
end

class Zlib::Error
end

class Zlib::GzipFile
  def close(); end

  def closed?(); end

  def comment(); end

  def crc(); end

  def finish(); end

  def level(); end

  def mtime(); end

  def orig_name(); end

  def os_code(); end

  def sync(); end

  def sync=(sync); end

  def to_io(); end
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::Error
  def input(); end
end

class Zlib::GzipFile::Error
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile
  def self.wrap(*_); end
end

class Zlib::GzipReader
  include ::Enumerable
  def bytes(); end

  def each(*_, &blk); end

  def each_byte(); end

  def each_char(); end

  def each_line(*_); end

  def eof(); end

  def eof?(); end

  def external_encoding(); end

  def getbyte(); end

  def getc(); end

  def initialize(*_); end

  def lineno(); end

  def lineno=(lineno); end

  def lines(*_); end

  def pos(); end

  def read(*_); end

  def readbyte(); end

  def readchar(); end

  def readpartial(*_); end

  def rewind(); end

  def tell(); end

  def ungetbyte(_); end

  def ungetc(_); end

  def unused(); end
end

class Zlib::GzipReader
end

class Zlib::GzipWriter
  def <<(_); end

  def comment=(comment); end

  def flush(*_); end

  def initialize(*_); end

  def mtime=(mtime); end

  def orig_name=(orig_name); end

  def pos(); end

  def tell(); end

  def write(_); end
end

class Zlib::GzipWriter
end

class Zlib::Inflate
  def <<(_); end

  def add_dictionary(_); end

  def inflate(_); end

  def initialize(*_); end

  def set_dictionary(_); end

  def sync(_); end

  def sync_point?(); end
end

class Zlib::Inflate
  def self.inflate(_); end
end

class Zlib::MemError
end

class Zlib::MemError
end

class Zlib::NeedDict
end

class Zlib::NeedDict
end

class Zlib::StreamEnd
end

class Zlib::StreamEnd
end

class Zlib::StreamError
end

class Zlib::StreamError
end

class Zlib::VersionError
end

class Zlib::VersionError
end

class Zlib::ZStream
  def adler(); end

  def avail_in(); end

  def avail_out(); end

  def avail_out=(avail_out); end

  def close(); end

  def closed?(); end

  def data_type(); end

  def end(); end

  def ended?(); end

  def finish(); end

  def finished?(); end

  def flush_next_in(); end

  def flush_next_out(); end

  def reset(); end

  def stream_end?(); end

  def total_in(); end

  def total_out(); end
end

class Zlib::ZStream
end

module Zlib
  def self.adler32(*_); end

  def self.adler32_combine(_, _1, _2); end

  def self.crc32(*_); end

  def self.crc32_combine(_, _1, _2); end

  def self.crc_table(); end

  def self.deflate(*_); end

  def self.gunzip(_); end

  def self.gzip(*_); end

  def self.inflate(_); end

  def self.zlib_version(); end
end
