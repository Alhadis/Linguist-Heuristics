# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/actionmailer/all/actionmailer.rbi
#
# actionmailer-2.3.18
module TMail
  def self.KCODE; end
  def self.KCODE=(arg0); end
  def self.new_boundary; end
  def self.new_message_id(fqdn = nil); end
  def self.random_tag; end
end
module TMail::VERSION
end
class TMail::SyntaxError < StandardError
end
module TMail::TextUtils
  def atom_safe?(str); end
  def decode_RFC2231(str); end
  def decode_params(hash); end
  def dquote(str); end
  def join_domain(arr); end
  def message_id?(str); end
  def mime_encoded?(str); end
  def quote_atom(str); end
  def quote_boundary; end
  def quote_phrase(str); end
  def quote_token(str); end
  def quote_unquoted_bencode; end
  def quote_unquoted_name; end
  def time2str(tm); end
  def timezone_string_to_unixtime(str); end
  def to_kcode(str); end
  def token_safe?(str); end
  def unquote(str); end
end
class TMail::Mail
  def [](key); end
  def []=(key, val); end
  def accept(strategy); end
  def add_date; end
  def add_hf(name, field); end
  def add_message_id(fqdn = nil); end
  def addrs2specs(addrs); end
  def attachment(part); end
  def attachment?(part); end
  def attachments; end
  def base64_decode!; end
  def base64_decode; end
  def base64_encode!; end
  def base64_encode; end
  def bcc(default = nil); end
  def bcc=(*strs); end
  def bcc_addrs(default = nil); end
  def bcc_addrs=(arg); end
  def body(to_charset = nil, &block); end
  def body=(str); end
  def body_port; end
  def canonical(name); end
  def cc(default = nil); end
  def cc=(*strs); end
  def cc_addrs(default = nil); end
  def cc_addrs=(arg); end
  def charset(default = nil); end
  def charset=(str); end
  def clear; end
  def content_disposition(default = nil); end
  def content_disposition=(str, params = nil); end
  def content_transfer_encoding(default = nil); end
  def content_transfer_encoding=(str); end
  def content_type(default = nil); end
  def content_type=(str, sub = nil, param = nil); end
  def content_type_is_text?; end
  def create_empty_mail; end
  def create_forward; end
  def create_reply; end
  def date(default = nil); end
  def date=(time); end
  def delete(key); end
  def delete_if; end
  def delete_no_send_fields; end
  def destinations(default = nil); end
  def disposition(default = nil); end
  def disposition=(str, params = nil); end
  def disposition_is_attachment?; end
  def disposition_param(name, default = nil); end
  def do_send_to(smtp); end
  def each(&block); end
  def each_dest(&block); end
  def each_destination(&block); end
  def each_field(&block); end
  def each_header; end
  def each_header_name(&block); end
  def each_key(&block); end
  def each_pair; end
  def each_part(&block); end
  def each_value(&block); end
  def encoding(default = nil); end
  def encoding=(str); end
  def enforced_message_id=(str); end
  def epilogue; end
  def epilogue=(str); end
  def error_reply_addresses(default = nil); end
  def fetch(key); end
  def friendly_from(default = nil); end
  def from(default = nil); end
  def from=(*strs); end
  def from_addrs(default = nil); end
  def from_addrs=(arg); end
  def has_attachments?; end
  def header; end
  def header_string(name, default = nil); end
  def in_reply_to(default = nil); end
  def in_reply_to=(*idstrs); end
  def indexes(*args); end
  def indices(*args); end
  def initialize(port = nil, conf = nil); end
  def inline_attachment?(part); end
  def inspect; end
  def key?(key); end
  def keys; end
  def main_type(default = nil); end
  def message_id(default = nil); end
  def message_id=(str); end
  def mime_encode; end
  def mime_encode_binary(body); end
  def mime_encode_multipart(top = nil); end
  def mime_encode_singlepart; end
  def mime_encode_text(body); end
  def mime_version(default = nil); end
  def mime_version=(m, opt = nil); end
  def mime_version_charset; end
  def multipart?; end
  def new_hf(name, field); end
  def ordered_each; end
  def parse_body(f = nil); end
  def parse_body_0(f); end
  def parse_header(f); end
  def parts; end
  def port; end
  def preamble; end
  def preamble=(str); end
  def quoted_body; end
  def quoted_body=(str); end
  def quoted_subject(default = nil); end
  def read_multipart(src); end
  def ready_to_send; end
  def references(default = nil); end
  def references=(*strs); end
  def reply_addresses(default = nil); end
  def reply_to(default = nil); end
  def reply_to=(*strs); end
  def reply_to_addrs(default = nil); end
  def reply_to_addrs=(arg); end
  def self.load(fname); end
  def self.load_from(fname); end
  def self.loadfrom(fname); end
  def self.parse(str); end
  def send_text_to(smtp); end
  def send_to(smtp); end
  def send_to_0(smtp, from, to); end
  def sender(default = nil); end
  def sender=(str); end
  def sender_addr(default = nil); end
  def sender_addr=(addr); end
  def set_addrfield(name, arg); end
  def set_content_disposition(str, params = nil); end
  def set_content_type(str, sub = nil, param = nil); end
  def set_disposition(str, params = nil); end
  def set_string_array_attr(key, strs); end
  def set_string_attr(key, str); end
  def setup_forward(mail); end
  def setup_reply(mail); end
  def skip_header(f); end
  def store(key, val); end
  def strftime(fmt, default = nil); end
  def sub_header(key, param); end
  def sub_type(default = nil); end
  def subject(to_charset = nil); end
  def subject=(str); end
  def text_content_type?; end
  def to(default = nil); end
  def to=(*strs); end
  def to_addrs(default = nil); end
  def to_addrs=(arg); end
  def transfer_encoding(default = nil); end
  def transfer_encoding=(str); end
  def type_param(name, default = nil); end
  def unquoted_body(to_charset = nil); end
  def values_at(*args); end
  def with_multipart_encoding(strategy); end
  def write_back(eol = nil, charset = nil); end
  include TMail::StrategyInterface
  include TMail::TextUtils
end
module TMail::Base64
  def decode(str, strict = nil); end
  def encode(str); end
  def folding_encode(str, eol = nil, limit = nil); end
  def self.decode(str, strict = nil); end
  def self.encode(str); end
  def self.folding_encode(str, eol = nil, limit = nil); end
end
class StringInput
  def close; end
  def closed?; end
  def each(&block); end
  def eof?; end
  def getc; end
  def gets; end
  def initialize(str); end
  def inspect; end
  def lineno; end
  def pos; end
  def read(len = nil); end
  def read_all; end
  def rewind; end
  def seek(offset, whence = nil); end
  def self.new(str); end
  def self.open(str); end
  def stream_check!; end
  def string; end
  def sysread(len = nil); end
  def tell; end
  include Enumerable
end
class StringOutput
  def <<(str); end
  def close; end
  def closed?; end
  def initialize(str = nil); end
  def inspect; end
  def pos; end
  def print(*args); end
  def printf(*args); end
  def putc(ch); end
  def puts(*args); end
  def self.new(str = nil); end
  def self.open(str = nil); end
  def size; end
  def stream_check!; end
  def string; end
  def syswrite(str); end
  def to_str; end
  def value; end
  def write(str); end
end
module TMail::StrategyInterface
  def accept_strategy(klass, eol, charset, dest = nil); end
  def create_dest(obj); end
  def decoded(eol = nil, charset = nil, dest = nil); end
  def encoded(eol = nil, charset = nil, dest = nil); end
  def self.create_dest(obj); end
  def to_s(eol = nil, charset = nil, dest = nil); end
end
class TMail::Decoder
  def decode(str); end
  def header_body(str); end
  def header_line(str); end
  def header_name(nm); end
  def initialize(dest, encoding = nil, eol = nil); end
  def kv_pair(k, v); end
  def lwsp(str); end
  def meta(str); end
  def phrase(str); end
  def puts(str = nil); end
  def puts_meta(str); end
  def self.decode(str, encoding = nil); end
  def space; end
  def spc; end
  def terminate; end
  def text(str); end
  def write(str); end
  include TMail::TextUtils
end
class TMail::Encoder
  def add_lwsp(lwsp); end
  def add_text(str); end
  def add_with_encode(str); end
  def concat_A_S(types, strs); end
  def concat_E(types, strs); end
  def dest; end
  def do_encode(types, strs); end
  def encode_value(str); end
  def extract_A(chunksize, str); end
  def extract_J(chunksize, str); end
  def extract_S(chunksize, str); end
  def flush(folded = nil); end
  def fold; end
  def fold_header; end
  def fold_the_string; end
  def header_body(str); end
  def header_line(line); end
  def header_name(name); end
  def initialize(dest = nil, encoding = nil, eol = nil, limit = nil); end
  def kv_pair(k, v); end
  def lwsp(str); end
  def max_bytes(chunksize, ssize); end
  def mazsize(whitespace_location); end
  def meta(str); end
  def normalize_encoding(str); end
  def phrase(str); end
  def preserve_quotes; end
  def preserve_quotes=(bool); end
  def puts(str = nil); end
  def puts_meta(str); end
  def reset; end
  def restsize; end
  def scanadd(str, force = nil); end
  def self.encode(str); end
  def space; end
  def spc; end
  def terminate; end
  def text(str); end
  def write(str); end
  include TMail::TextUtils
end
class TMail::Config
  def initialize(strict); end
  def new_body_port(mail); end
  def new_part_port(mail); end
  def new_preamble_port(mail); end
  def self.to_config(arg); end
  def strict_base64decode=(arg0); end
  def strict_base64decode?; end
  def strict_parse=(arg0); end
  def strict_parse?; end
end
class TMail::TMailScanner
  def debug; end
  def debug=(arg0); end
  def eof?; end
  def init_scanner(str); end
  def initialize(str, scantype, comments); end
  def readchar; end
  def readstr(re); end
  def rest_size; end
  def scan(&block); end
  def scan_comment; end
  def scan_domain_literal; end
  def scan_error!(msg); end
  def scan_main; end
  def scan_qstr(pattern, terminal, type); end
  def scan_quoted_word; end
  def skip(re); end
end
class TMail::Parser < Racc::Parser
  def _reduce_1(val, _values); end
  def _reduce_10(val, _values); end
  def _reduce_11(val, _values); end
  def _reduce_12(val, _values); end
  def _reduce_13(val, _values); end
  def _reduce_16(val, _values); end
  def _reduce_17(val, _values); end
  def _reduce_18(val, _values); end
  def _reduce_19(val, _values); end
  def _reduce_2(val, _values); end
  def _reduce_21(val, _values); end
  def _reduce_23(val, _values); end
  def _reduce_24(val, _values); end
  def _reduce_25(val, _values); end
  def _reduce_26(val, _values); end
  def _reduce_28(val, _values); end
  def _reduce_29(val, _values); end
  def _reduce_3(val, _values); end
  def _reduce_30(val, _values); end
  def _reduce_32(val, _values); end
  def _reduce_33(val, _values); end
  def _reduce_35(val, _values); end
  def _reduce_36(val, _values); end
  def _reduce_37(val, _values); end
  def _reduce_39(val, _values); end
  def _reduce_4(val, _values); end
  def _reduce_47(val, _values); end
  def _reduce_48(val, _values); end
  def _reduce_49(val, _values); end
  def _reduce_5(val, _values); end
  def _reduce_52(val, _values); end
  def _reduce_53(val, _values); end
  def _reduce_56(val, _values); end
  def _reduce_58(val, _values); end
  def _reduce_59(val, _values); end
  def _reduce_6(val, _values); end
  def _reduce_60(val, _values); end
  def _reduce_61(val, _values); end
  def _reduce_62(val, _values); end
  def _reduce_63(val, _values); end
  def _reduce_65(val, _values); end
  def _reduce_66(val, _values); end
  def _reduce_67(val, _values); end
  def _reduce_68(val, _values); end
  def _reduce_7(val, _values); end
  def _reduce_70(val, _values); end
  def _reduce_71(val, _values); end
  def _reduce_72(val, _values); end
  def _reduce_73(val, _values); end
  def _reduce_74(val, _values); end
  def _reduce_75(val, _values); end
  def _reduce_76(val, _values); end
  def _reduce_8(val, _values); end
  def _reduce_85(val, _values); end
  def _reduce_86(val, _values); end
  def _reduce_87(val, _values); end
  def _reduce_89(val, _values); end
  def _reduce_9(val, _values); end
  def _reduce_90(val, _values); end
  def _reduce_91(val, _values); end
  def _reduce_92(val, _values); end
  def _reduce_93(val, _values); end
  def _reduce_94(val, _values); end
  def _reduce_95(val, _values); end
  def _reduce_96(val, _values); end
  def _reduce_97(val, _values); end
  def _reduce_98(val, _values); end
  def _reduce_99(val, _values); end
  def _reduce_none(val, _values); end
  def debug; end
  def debug=(flag); end
  def initialize; end
  def on_error(t, val, vstack); end
  def parse(ident, str, comments = nil); end
  def parse_in(&block); end
  def self.parse(ident, str, cmt = nil); end
  def self.special_quote_address(str); end
  include TMail::TextUtils
end
class TMail::Address
  def ==(other); end
  def accept(strategy, dummy1 = nil, dummy2 = nil); end
  def address; end
  def address_group?; end
  def domain; end
  def dup; end
  def eql?(other); end
  def hash; end
  def initialize(local, domain); end
  def inspect; end
  def local; end
  def name; end
  def name=(str); end
  def phrase; end
  def phrase=(str); end
  def routes; end
  def self.parse(str); end
  def spec; end
  include TMail::StrategyInterface
  include TMail::TextUtils
end
class TMail::AddressGroup
  def ==(other); end
  def [](idx); end
  def accept(strategy, dummy1 = nil, dummy2 = nil); end
  def add(a); end
  def address_group?; end
  def delete(a); end
  def each(&block); end
  def each_address(&block); end
  def empty?; end
  def eql?(other); end
  def flatten; end
  def hash; end
  def include?(a); end
  def initialize(name, addrs); end
  def name; end
  def push(a); end
  def size; end
  def to_a; end
  def to_ary; end
  include Enumerable
  include TMail::StrategyInterface
end
class TMail::HeaderField
  def accept(strategy); end
  def body; end
  def body=(str); end
  def clear_parse_status; end
  def empty?; end
  def ensure_parsed; end
  def illegal?; end
  def initialize(body, conf, intern = nil); end
  def inspect; end
  def self.internal_new(name, conf); end
  def self.new(name, body, conf = nil); end
  def self.new_from_port(port, name, conf = nil); end
  def self.newobj(*arg0); end
  include TMail::StrategyInterface
  include TMail::TextUtils
end
class TMail::UnstructuredHeader < TMail::HeaderField
  def body; end
  def body=(arg); end
  def do_accept(strategy); end
  def isempty?; end
  def parse; end
  def parse_init; end
end
class TMail::StructuredHeader < TMail::HeaderField
  def comments; end
  def do_parse; end
  def parse; end
  def parse_init; end
end
class TMail::DateTimeHeader < TMail::StructuredHeader
  def date; end
  def date=(arg); end
  def do_accept(strategy); end
  def init; end
  def isempty?; end
  def set(t); end
end
class TMail::AddressHeader < TMail::StructuredHeader
  def addrs; end
  def do_accept(strategy); end
  def init; end
  def isempty?; end
  def set(a); end
end
class TMail::ReturnPathHeader < TMail::AddressHeader
  def addr; end
  def do_accept(strategy); end
  def routes; end
  def spec; end
end
class TMail::SingleAddressHeader < TMail::AddressHeader
  def addr; end
  def do_accept(strategy); end
end
class TMail::MessageIdHeader < TMail::StructuredHeader
  def do_accept(strategy); end
  def do_parse; end
  def id; end
  def id=(arg); end
  def init; end
  def isempty?; end
end
class TMail::ReferencesHeader < TMail::StructuredHeader
  def do_accept(strategy); end
  def do_parse; end
  def each_id; end
  def each_phrase; end
  def ids; end
  def init; end
  def isempty?; end
  def phrases; end
  def refs; end
end
class TMail::ReceivedHeader < TMail::StructuredHeader
  def _for; end
  def _for=(arg); end
  def by; end
  def by=(arg); end
  def date; end
  def date=(arg); end
  def do_accept(strategy); end
  def from; end
  def from=(arg); end
  def id; end
  def id=(arg); end
  def init; end
  def isempty?; end
  def set(args); end
  def via; end
  def via=(arg); end
  def with; end
end
class TMail::KeywordsHeader < TMail::StructuredHeader
  def do_accept(strategy); end
  def init; end
  def isempty?; end
  def keys; end
  def set(a); end
end
class TMail::EncryptedHeader < TMail::StructuredHeader
  def do_accept(strategy); end
  def encrypter; end
  def encrypter=(arg); end
  def init; end
  def isempty?; end
  def keyword; end
  def keyword=(arg); end
  def set(args); end
end
class TMail::MimeVersionHeader < TMail::StructuredHeader
  def do_accept(strategy); end
  def init; end
  def isempty?; end
  def major; end
  def major=(arg); end
  def minor; end
  def minor=(arg); end
  def set(args); end
  def version; end
end
class TMail::ContentTypeHeader < TMail::StructuredHeader
  def [](key); end
  def []=(key, val); end
  def content_type; end
  def do_accept(strategy); end
  def init; end
  def isempty?; end
  def main_type; end
  def main_type=(arg); end
  def params; end
  def set(args); end
  def sub_type; end
  def sub_type=(arg); end
end
class TMail::ContentTransferEncodingHeader < TMail::StructuredHeader
  def do_accept(strategy); end
  def encoding; end
  def encoding=(arg); end
  def init; end
  def isempty?; end
  def set(s); end
end
class TMail::ContentDispositionHeader < TMail::StructuredHeader
  def [](key); end
  def []=(key, val); end
  def disposition; end
  def disposition=(str); end
  def do_accept(strategy); end
  def init; end
  def isempty?; end
  def params; end
  def set(args); end
end
class TMail::Port
  def reproducible?; end
end
class TMail::FilePort < TMail::Port
  def ==(other); end
  def aopen(&block); end
  def copy_file(src, dest); end
  def copy_to(port); end
  def cp(port); end
  def eql?(other); end
  def filename; end
  def hash; end
  def ident; end
  def initialize(fname); end
  def inspect; end
  def move_to(port); end
  def mv(port); end
  def read_all; end
  def remove; end
  def reproducible?; end
  def ropen(&block); end
  def size; end
  def wopen(&block); end
end
module TMail::MailFlags
  def flagged=(b); end
  def flagged?; end
  def procinfostr(str, tag, true_p); end
  def replied=(b); end
  def replied?; end
  def seen=(b); end
  def seen?; end
end
class TMail::MhPort < TMail::FilePort
  def get_status(tag); end
  def set_status(tag, flag); end
  def write_status(f, tag, flag); end
  include TMail::MailFlags
end
class TMail::MaildirPort < TMail::FilePort
  def get_status(tag); end
  def move_to_cur; end
  def move_to_new; end
  def replace_dir(path, dir); end
  def set_status(tag, flag); end
  include TMail::MailFlags
end
class TMail::StringPort < TMail::Port
  def ==(other); end
  def aopen(&block); end
  def copy_to(port); end
  def cp(port); end
  def eql?(other); end
  def hash; end
  def initialize(str = nil); end
  def inspect; end
  def move_to(port); end
  def read_all; end
  def remove; end
  def reproducible?; end
  def rm; end
  def ropen(&block); end
  def size; end
  def string; end
  def to_s; end
  def wopen(&block); end
end
class TMail::Attachment < StringIO
  def content_type; end
  def content_type=(arg0); end
  def original_filename(to_charset = nil); end
  def original_filename=(arg0); end
  def quoted?(string); end
  def quoted_filename; end
  include TMail::TextUtils
end
class TMail::Unquoter
  def self.convert_to(text, to, from); end
  def self.convert_to_with_fallback_on_iso_8859_1(text, to, from); end
  def self.convert_to_without_fallback_on_iso_8859_1(text, to, from); end
  def self.unquote_and_convert_to(text, to_charset, from_charset = nil, preserve_underscores = nil); end
  def self.unquote_base64_and_convert_to(text, to, from); end
  def self.unquote_quoted_printable_and_convert_to(text, to, from, preserve_underscores = nil); end
end
class TMail::MhMailbox
  def close; end
  def directory; end
  def dirname; end
  def each; end
  def each_new_port(mtime = nil, &block); end
  def each_port; end
  def initialize(dir); end
  def inspect; end
  def last_atime; end
  def last_atime=(arg0); end
  def mail_files; end
  def new_port; end
  def next_file_name; end
  def reverse_each; end
  def reverse_each_port; end
end
class TMail::UNIXMbox
  def close; end
  def close_check; end
  def each(&block); end
  def each_new_port(mtime = nil); end
  def each_port(&block); end
  def fromline2time(line); end
  def initialize(fname, mhdir, readonly, static); end
  def new_port; end
  def reverse_each(&block); end
  def reverse_each_port(&block); end
  def self.create_from_line(port); end
  def self.fromaddr(port); end
  def self.lock(fname); end
  def self.mkfinal(mh, mboxfile, writeback_p, cleanup_p); end
  def self.new(filename, tmpdir = nil, readonly = nil); end
  def self.newobj(*arg0); end
  def self.static_new(fname, dir, readonly = nil); end
  def update; end
end
class TMail::Maildir
  def check_tmp; end
  def close; end
  def directory; end
  def each; end
  def each_filename(dir); end
  def each_new_port; end
  def each_port; end
  def initialize(dir = nil); end
  def inspect; end
  def mail_files(dir); end
  def new_port; end
  def reverse_each; end
  def reverse_each_port; end
  def self.lock; end
  def self.locked?; end
  def self.synchronize(&block); end
  def self.try_lock; end
  def self.unique_number; end
  def self.unlock; end
  extend Mutex_m
end
class TMail::DeleteFields
  def delete_empty_fields; end
  def delete_empty_fields=(arg0); end
  def exec(mail); end
  def initialize(nosend = nil, delempty = nil); end
  def no_send_fields; end
end
class TMail::AddMessageId
  def exec(mail); end
  def fqdn; end
  def fqdn=(arg0); end
  def initialize(fqdn = nil); end
end
class TMail::AddDate
  def exec(mail); end
end
class TMail::MimeEncodeAuto
  def exec(mail); end
  def initialize(s = nil, m = nil); end
  def multipart_composer; end
  def singlepart_composer; end
end
class TMail::MimeEncodeSingle
  def exec(mail); end
  def on_binary(body); end
  def on_text(body); end
end
class TMail::MimeEncodeMulti
  def exec(mail, top = nil); end
end
module CharDet
  def self.detect(aBuf); end
end
class CharDet::CharSetProber
  def active; end
  def active=(arg0); end
  def feed(aBuf); end
  def filter_high_bit_only(aBuf); end
  def filter_with_english_letters(aBuf); end
  def filter_without_english_letters(aBuf); end
  def get_charset_name; end
  def get_confidence; end
  def get_state; end
  def initialize; end
  def reset; end
end
class CharDet::MultiByteCharSetProber < CharDet::CharSetProber
  def feed(aBuf); end
  def get_charset_name; end
  def get_confidence; end
  def initialize; end
  def reset; end
end
class CharDet::Big5Prober < CharDet::MultiByteCharSetProber
  def get_charset_name; end
  def initialize; end
end
class CharDet::CharDistributionAnalysis
  def feed(aStr, aCharLen); end
  def get_confidence; end
  def get_order(aStr); end
  def got_enough_data; end
  def initialize; end
  def reset; end
end
class CharDet::EUCTWDistributionAnalysis < CharDet::CharDistributionAnalysis
  def get_order(aStr); end
  def initialize; end
end
class CharDet::EUCKRDistributionAnalysis < CharDet::CharDistributionAnalysis
  def get_order(aStr); end
  def initialize; end
end
class CharDet::GB2312DistributionAnalysis < CharDet::CharDistributionAnalysis
  def get_order(aStr); end
  def initialize; end
end
class CharDet::Big5DistributionAnalysis < CharDet::CharDistributionAnalysis
  def get_order(aStr); end
  def initialize; end
end
class CharDet::SJISDistributionAnalysis < CharDet::CharDistributionAnalysis
  def get_order(aStr); end
  def initialize; end
end
class CharDet::EUCJPDistributionAnalysis < CharDet::CharDistributionAnalysis
  def get_order(aStr); end
  def initialize; end
end
class CharDet::CharSetGroupProber < CharDet::CharSetProber
  def _mProbers; end
  def _mProbers=(arg0); end
  def feed(aBuf); end
  def get_charset_name; end
  def get_confidence; end
  def initialize; end
  def reset; end
end
class CharDet::CodingStateMachine
  def get_coding_state_machine; end
  def get_current_charlen; end
  def initialize(sm); end
  def next_state(c); end
  def reset; end
end
class CharDet::EscCharSetProber < CharDet::CharSetProber
  def feed(aBuf); end
  def get_charset_name; end
  def get_confidence; end
  def initialize; end
  def reset; end
end
class CharDet::EUCJPProber < CharDet::MultiByteCharSetProber
  def feed(aBuf); end
  def get_charset_name; end
  def get_confidence; end
  def initialize; end
  def reset; end
end
class CharDet::EUCKRProber < CharDet::MultiByteCharSetProber
  def get_charset_name; end
  def initialize; end
end
class CharDet::EUCTWProber < CharDet::MultiByteCharSetProber
  def get_charset_name; end
  def initialize; end
end
class CharDet::GB2312Prober < CharDet::MultiByteCharSetProber
  def get_charset_name; end
  def initialize; end
end
class CharDet::HebrewProber < CharDet::CharSetProber
  def feed(aBuf); end
  def get_charset_name; end
  def get_state; end
  def initialize; end
  def is_final(c); end
  def is_non_final(c); end
  def reset; end
  def set_model_probers(logicalProber, visualProber); end
end
class CharDet::JapaneseContextAnalysis
  def feed(aBuf, aLen); end
  def get_confidence; end
  def get_order(aStr); end
  def got_enough_data; end
  def initialize; end
  def reset; end
end
class CharDet::SJISContextAnalysis < CharDet::JapaneseContextAnalysis
  def get_order(aStr); end
end
class CharDet::EUCJPContextAnalysis < CharDet::JapaneseContextAnalysis
  def get_order(aStr); end
end
class CharDet::Latin1Prober < CharDet::CharSetProber
  def feed(aBuf); end
  def get_charset_name; end
  def get_confidence; end
  def initialize; end
  def reset; end
end
class CharDet::MBCSGroupProber < CharDet::CharSetGroupProber
  def initialize; end
end
class CharDet::SingleByteCharSetProber < CharDet::CharSetProber
  def feed(aBuf); end
  def get_charset_name; end
  def get_confidence; end
  def initialize(model, reversed = nil, nameProber = nil); end
  def reset; end
end
class CharDet::SBCSGroupProber < CharDet::CharSetGroupProber
  def initialize; end
end
class CharDet::SJISProber < CharDet::MultiByteCharSetProber
  def feed(aBuf); end
  def get_charset_name; end
  def get_confidence; end
  def initialize; end
  def reset; end
end
class CharDet::UniversalDetector
  def close; end
  def feed(aBuf); end
  def initialize; end
  def reset; end
  def result; end
  def result=(arg0); end
end
class CharDet::UTF8Prober < CharDet::CharSetProber
  def feed(aBuf); end
  def get_charset_name; end
  def get_confidence; end
  def initialize; end
  def reset; end
end
module ActionMailer
  def self.load_all!; end
end
module Text
end
module Net
end
module ActionMailer::AdvAttrAccessor
  def self.included(base); end
end
module ActionMailer::AdvAttrAccessor::ClassMethods
  def adv_attr_accessor(*names); end
end
module ActionMailer::PartContainer
  def attachment(params, &block); end
  def parse_content_type(defaults = nil); end
  def part(params); end
  def parts; end
end
module ActionMailer::Quoting
  def quote_address_if_necessary(address, charset); end
  def quote_any_address_if_necessary(charset, *args); end
  def quote_any_if_necessary(charset, *args); end
  def quote_if_necessary(text, charset); end
  def quoted_printable(text, charset); end
  def quoted_printable_encode(character); end
end
module ActionMailer::Utils
  def normalize_new_lines(text); end
end
module ActionMailer::Helpers
  def initialize_template_class_with_helper(assigns); end
  def self.included(base); end
end
module ActionMailer::Helpers::ClassMethods
  def add_template_helper(helper_module); end
  def helper(*args, &block); end
  def helper_attr(*attrs); end
  def helper_method(*methods); end
  def inherited_with_helper(child); end
end
module MailHelper
  def block_format(text); end
end
class ActionMailer::Base
  def action_name; end
  def bcc(*parameters); end
  def bcc=(value); end
  def body(*parameters); end
  def body=(value); end
  def candidate_for_layout?(options); end
  def cc(*parameters); end
  def cc=(value); end
  def charset(*parameters); end
  def charset=(value); end
  def content_type(*parameters); end
  def content_type=(value); end
  def create!(method_name, *parameters); end
  def create_mail; end
  def default_charset; end
  def default_charset=(obj); end
  def default_content_type; end
  def default_content_type=(obj); end
  def default_implicit_parts_order; end
  def default_implicit_parts_order=(obj); end
  def default_mime_version; end
  def default_mime_version=(obj); end
  def default_template_format; end
  def default_template_name; end
  def default_url_options; end
  def default_url_options=(obj); end
  def deliver!(mail = nil); end
  def deliveries; end
  def deliveries=(obj); end
  def delivery_method; end
  def delivery_method=(arg0); end
  def delivery_method?; end
  def from(*parameters); end
  def from=(value); end
  def headers(*parameters); end
  def headers=(value); end
  def implicit_parts_order(*parameters); end
  def implicit_parts_order=(value); end
  def initialize(method_name = nil, *parameters); end
  def initialize_defaults(method_name); end
  def initialize_template_class(assigns); end
  def initialize_template_class_without_helper(assigns); end
  def logger; end
  def logger=(obj); end
  def mail; end
  def mailer_name(value = nil); end
  def mailer_name=(value); end
  def master_helper_module; end
  def master_helper_module=(obj); end
  def mime_version(*parameters); end
  def mime_version=(value); end
  def perform_deliveries; end
  def perform_deliveries=(obj); end
  def perform_delivery_sendmail(mail); end
  def perform_delivery_smtp(mail); end
  def perform_delivery_test(mail); end
  def protected_instance_variables; end
  def raise_delivery_errors; end
  def raise_delivery_errors=(obj); end
  def recipients(*parameters); end
  def recipients=(value); end
  def render(opts); end
  def render_message(method_name, body); end
  def reply_to(*parameters); end
  def reply_to=(value); end
  def self.controller_name; end
  def self.controller_path; end
  def self.default_charset; end
  def self.default_charset=(obj); end
  def self.default_content_type; end
  def self.default_content_type=(obj); end
  def self.default_implicit_parts_order; end
  def self.default_implicit_parts_order=(obj); end
  def self.default_mime_version; end
  def self.default_mime_version=(obj); end
  def self.default_url_options; end
  def self.default_url_options=(obj); end
  def self.deliver(mail); end
  def self.deliveries; end
  def self.deliveries=(obj); end
  def self.delivery_method; end
  def self.delivery_method=(val); end
  def self.delivery_method?; end
  def self.inherited(child); end
  def self.inherited_without_helper(child); end
  def self.inherited_without_layout(child); end
  def self.logger; end
  def self.logger=(obj); end
  def self.mailer_name; end
  def self.mailer_name=(arg0); end
  def self.master_helper_module; end
  def self.master_helper_module=(obj); end
  def self.matches_dynamic_method?(method_name); end
  def self.method_missing(method_symbol, *parameters); end
  def self.new(*arg0); end
  def self.perform_deliveries; end
  def self.perform_deliveries=(obj); end
  def self.protected_instance_variables; end
  def self.raise_delivery_errors; end
  def self.raise_delivery_errors=(obj); end
  def self.receive(raw_email); end
  def self.respond_to?(method_symbol, include_private = nil); end
  def self.sendmail_settings; end
  def self.sendmail_settings=(obj); end
  def self.smtp_settings; end
  def self.smtp_settings=(obj); end
  def self.template_root; end
  def self.template_root=(root); end
  def self.view_paths; end
  def self.view_paths=(obj); end
  def sendmail_settings; end
  def sendmail_settings=(obj); end
  def sent_on(*parameters); end
  def sent_on=(value); end
  def smtp_settings; end
  def smtp_settings=(obj); end
  def sort_parts(parts, order = nil); end
  def subject(*parameters); end
  def subject=(value); end
  def template(*parameters); end
  def template=(value); end
  def template_name; end
  def template_path; end
  def template_root; end
  def template_root=(root); end
  def view_paths; end
  def view_paths=(obj); end
  extend ActionController::Layout::ClassMethods
  extend ActionMailer::AdvAttrAccessor::ClassMethods
  extend ActionMailer::Helpers::ClassMethods
  include ActionController::Layout
  include ActionController::Routing::Helpers
  include ActionController::UrlWriter
  include ActionMailer::AdvAttrAccessor
  include ActionMailer::Helpers
  include Anonymous_Module_4
end
