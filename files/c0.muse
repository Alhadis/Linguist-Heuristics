#title 将PL/0编译器改造为C0编译器
#author PB09210183 何春晖
#date 2012.03.24

* C0的词法
词法的名字以程序为准，从这里可以看出PL/0词法和C0词法间的对应关系。
** 关键字
<example>
ifsym	 -> "if"
procsym	 -> "void"
varsym	 -> "int"
whilesym -> "while"
</example>

** 符号
<example>
becomes	 -> "="
eql	 -> "=="
neq	 -> "!="
leq	 -> "<="
lss	 -> "<"
geq	 -> ">="
gtr	 -> ">"
plus	 -> "+"
minus	 -> "-"
times	 -> "*"
slash	 -> "/"
oddsym	 -> "%"
lparen	 -> "("
rparen	 -> ")"
begsym   -> "{"
endsym   -> "}"
comma	 -> ","
semicolon-> ";"
</example>

** 标识符
<example>
id	-> [_a-zA-Z][a-zA-Z0-9]*
</example>

** 数字
<example>
number  -> num10 | num16 | num8
num10	-> [1-9][0-9]*|0
num16	-> 0[xX][0-9a-f]+
num8	-> 0[0-7]+
</example>

** 注释
<example>
comment -> \/\*[^\*]*\*(([^\*\/][^\*]*)?\*)*\/
</example>

* C0的语法和语义
为了语法清晰起见，固定符号的终结符用引号引用原文，而不用上节定义的名字。非终结符以大写起头。

按照扩展方式的语法表示如下：
<example>
Program -> Block
Block   -> [Vardecl] [Procdecl] Stmts
Vardecl -> "int" Vardef {, Vardef} ";"
Vardef  -> ident ["=" number]
ProcDecl-> "void" ident "(" ")" "{" Block "}"
Stmt    -> ident StmtOpt | "{" Stmts "}" |
           "if" "(" Cond ")" Stmt | "while" "(" Cond ")" Stmt | ";"
StmtOpt -> "=" Exp ";" | "(" ")" ";"
Stmts   -> Stmt Stmts | E
Cond    -> Exp CondOpt
CondOpt -> "%" "2" | RelOp Exp
RelOp   -> "=="|"!="|"<"|">"|"<="|">="
Exp     -> ["+"|"-"] Term {"+" Term | "-" Term}
Term    -> Factor {"*" Factor | "/" Factor}
Factor  -> ident | number | "(" Exp ")"
</example>

可见相比PL/0语言的主要区别有：
    - Program不以句点结尾，而是 **以文件到达结尾作为程序的结尾**；
    - C0的函数不能向PL/0一样只有一句，而 **必须以大括号包围**。因此Block中Stmt相应改为Stmts，ProcDecl中Block要有大括号包围；
    - 合并了常量和变量的声明， **若声明时使用ident “=” number的模式，则认为ident是常量，若只用ident，则认为是变量**；
    - 分号不再只是语句间的分隔符，而要求 **每个语句必须以分号结束**，因此Stmt相应修改，并加上空语句“;”；
    - **函数调用没有“call”前缀**，与赋值语句前缀相同，因此要做提左因子以满足LL(1)文法要求；
    - **odd函数用“%2”代替**，并提左因子；
    - 其他细节，如左右括号。

至此，经过文法相应修改，PL/0文法已经基本变为C0的风格。但实践上还有两点不同：
    - **C0不像PL/0可以过程嵌套定义**；
    - **PL/0最外层的Stmt块在C0中没有对应成分，而C0中main函数在PL/0中没有对应成分**。

针对这两点不同，将问题简单化，并没有选择继续修改文法，而是在语义动作上做修改。

针对第一点，因为在block函数中，用lev来判断嵌套层次。因此，在递归调用block前判断lev，若进入嵌套则报语义错。

针对第二点，视main为普通函数定义。然后基于同样原理，判断lev，若处于最外层，则自动加上一个Stmts的机器代码。代码的内容是调用main函数。若找不到main函数，则报语义错。这样就满足了main函数首先调用的要求，也隐去了PL/0中最后一段Stmts成分。

这样PL/0语言成分就对应到了C0上。

** 中间代码
*** 符号表组织和结构
符号表目前定义在parser.c中，叫table，结构各个元素意义为：
    - name : 符号名
    - kind : 符号类型，有常量、变量和过程
    - val  : 常量的值
    - level : 符号的层次
    - addr : 过程或变量的地址

tx是 **当前层次上** 符号表第一个未分配的表项下标。

对符号表的操作有：
    - 登记新符号：将指定类型的当前符号顺序存入符号表，使用enter函数完成
    - 查找符号： 查找符号在当前层次对应的符号表项，使用position函数完成
    - 进入和退出层次：此工作是在block函数中实现的，进入一层时，置tx1=tx保存；退出一层时，置tx=tx1恢复

可见，对符号表是利用类似栈的结构进行管理的。这种管理保证了局部的符号不会在其他地方被引用。

*** 中间代码的组织
中间代码是全局量，定义在glo.h中，是一个叫code的指令数组，里面存放翻译的中间代码。

代码生成还依赖于两个全局量cx和dx。
    - cx是code中当前要生成的指令的下标
    - dx是在当前层次堆栈中第一个可分配数据的下标

其中dx也要根据分析层次的进出类似tx一样地调整，以完成局部变量的分配。

对code进行生成的函数是gen，在parser.c中，此函数仅仅简单将指令的操作码、层次和地址顺序登入code中。

*** 中间代码的生成
**** 表达式和条件表达式
    - 常量：先从符号表中查出数值，再生成lit，载入值到栈顶。
    - 变量：先从符号表中查出地址偏移a和层次l，生成lod，载入base(l)+a处的值到栈顶。
    - 数值：直接生成lit，载入值到栈顶。
    - 运算符：生成opr指令对顶部元素计算。

**** 语句
    - 赋值：先产生右部表达式代码，再从符号表查处变量的偏移和层次，生成sto指令。
    - 函数（过程）调用：先从符号表中查出地址偏移和层次，生成cal指令。
    - 条件和循环：先生成条件表达式的代码，再生成jpc、jmp和语句的代码。

**** 过程块
    - 开始：生成一个空jmp指令，用来跳转到首过程代码处执行。
    - 变量定义：生成int指令，在运行时栈上分配空间。 **由于用cal指令调用函数时，该指令会在栈上存下动态链信息、返址和静态链信息，因此生成的int指令至少要开辟3的空间**，因此dx初值赋值为3。
    - 过程定义：递归地做过程块的代码生成，并维护lev、tx、dx变量。
    - 代码开始：修改前面生成的空jmp指令，使目标地址指向此处。
    - 代码结束：生成opr(0,0)指令返回

** 错误处理
按照《PL/0编译器的错误与错误恢复》一文中的改进方案设计错误处理。
*** 修改test语义
在parser.c中：
修改test定义为int test(s1, s2)。

意义为：若sym在s1中，吃掉sym，返回1；否则报错，并向后同步扫描到s1或s2中，返回0；若同步到s1中，吃掉sym，若同步到s2中，保持sym不被吃掉。

经过这样的修改后，代码不少部分得以简化。并且所有的语法错均由test函数检测，因此不必附加错误号。

*** 增加miss_error函数
针对原文中提出的报错信息的修改，在lexer.c中增加miss_error函数，可以向miss_error函数传递一个集合，表示编译器期望接收到的符号集合。

*** 去除Follow集合检测
由代码清晰性的要求，去除了所有Follow集合的检验，即所有fsys参数被删除。

对Follow的检测改由调用者显式调用test函数检测，而非被调用者经由fsys间接检测。

*** 结果
以遗漏分号的例子检测：
<src>
void main()
{
    int a, b;
    a=3
    b=4;
}
</src>
报错为：
<example>
 ****     ^ 0
errmsg(0): miss ';' token
</example>
显然友好不少。
