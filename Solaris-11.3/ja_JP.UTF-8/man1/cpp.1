'\" te
.\" Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
.TH cpp 1 "2010 年 12 月 7 日" "SunOS 5.11" "ユーザーコマンド"
.SH 名前
cpp \- C 言語プリプロセッサ
.SH 形式
.LP
.nf
\fB/usr/lib/cpp\fR [\fB-BCHMpPRT\fR] [\fB-undef\fR] [\fB-D\fR\fIname\fR] [\fB-D\fR\fIname\fR = \fIdef\fR] 
     [\fB-I\fR\fIdirectory\fR] [\fB-U\fR\fIname\fR] [\fB-Y\fR\fIdirectory\fR] 
     [\fIinput-file\fR [\fIoutput-file\fR]]
.fi

.SH 機能説明
.sp
.LP
\fBcpp\fR は、C 言語プリプロセッサです。\fBcpp\fR は、ほかの Sun コンパイラの第 1 パスプリプロセッサとしても使用されます。
.sp
.LP
\fBcpp\fR はマクロプロセッサとしても使用できますが、その出力がコンパイラの第 2 パスへの入力として使用できる形式となっているため、一般にマクロプロセッサとしての使用はお勧めできません。このため、コンパイルコマンドの使用が \fBcpp\fR の望ましい呼び出し方法です。汎用のマクロ処理については、\fBm4\fR(1) を参照してください。 
.sp
.LP
\fBcpp\fR は、オプションとして 2 つのファイル名を引数として受け入れます。\fIinput-file\fR および \fIoutput-file\fR は、それぞれ、プリプロセッサ用の入力ファイルと出力ファイルです。デフォルトでは、標準入力と標準出力が使用されます。
.SH オプション
.sp
.LP
サポートしているオプションは、次のとおりです。
.sp
.ne 2
.mk
.na
\fB\fB-B\fR\fR
.ad
.RS 15n
.rt  
C++ の注釈インジケータ \fB/ /\fR をサポートします。このインジケータを使用すると、\fB/ /\fR の後の行は注釈として扱われます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-C\fR\fR
.ad
.RS 15n
.rt  
すべての注釈 (\fBcpp\fR の指令行にあるものは除く) をそのまま渡します。デフォルトでは、\fBcpp\fR は C 言語スタイルの注釈を削除します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-H\fR \fR
.ad
.RS 15n
.rt  
インクルードファイルのパス名を、1 行に 1 つずつ標準エラー出力に出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-M\fR\fR
.ad
.RS 15n
.rt  
メイクファイル依存関係のリストを生成して、標準出力に書き込みます。このリストは、入力ファイルから生成されるオブジェクトファイルが、入力ファイルだけでなく、参照されるインクルードファイルにも依存することを示します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-p\fR\fR
.ad
.RS 15n
.rt  
最初の 8 文字だけを使用してプリプロセッサシンボルを識別し、指令を含む行の終わりに余分なトークンがあれば警告を発行します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-P\fR\fR
.ad
.RS 15n
.rt  
C コンパイラの次のパスで使用される行制御情報を生成せずに、入力を前処理します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-R\fR\fR
.ad
.RS 15n
.rt  
再帰マクロを可能にします。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-T\fR \fR
.ad
.RS 15n
.rt  
最初の 8 文字だけを使用して、異なるプリプロセッサシンボルを識別します。このオプションは、常に最初の 8 文字だけを使用するシステムとの下方互換性のために提供されています。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-undef\fR\fR
.ad
.RS 15n
.rt  
事前定義されているすべてのシンボル初期定義を削除します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-D\fR\fIname\fR\fR
.ad
.RS 15n
.rt  
\fIname\fR を \fB1\fR と定義します。これは、\fBcpp\fR コマンド行に \fB-D\fR\fIname\fR\fB=1\fR オプションを指定した場合と同じです。または、
.sp
.in +2
.nf
\fB#define\fR \fIname\fR \fB1\fR
.fi
.in -2
.sp

の行が \fBcpp\fR の処理するソースファイル内にある場合と同じです。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-D\fR\fIname\fR\fB=\fR\fIdef\fR\fR
.ad
.RS 15n
.rt  
\fB#define\fR 指令と同様に \fIname\fR を定義します。これは、
.sp
.in +2
.nf
\fB#define\fR \fIname\fR \fBdef\fR
.fi
.in -2
.sp

の行が \fBcpp\fR の処理するソースファイル内にある場合と同じです。\fB-D\fR オプションは \fB-U\fR オプションよりも優先順位が低くなります。つまり、\fB-U\fR オプションと \fB-D\fR オプションの両方で同じ名前を使用した場合は、オプションの順序に関係なくその名前は定義されません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-I\fR\fIdirectory\fR\fR
.ad
.RS 15n
.rt  
\fI/\fR 以外で始まる名前を持つ \fB#include\fR ファイルの検索パスに \fBdirectory\fR を挿入します。\fIdirectory\fR は、標準の \fBinclude\fR ディレクトリリストの前に挿入されます。したがって、名前が二重引用符 (\fB"\fR) で囲まれた \fB#include\fR ファイルは、まず \fB#include\fR 行を含むファイルのあるディレクトリで検索され、次に \fB-I\fR オプションで指定されたディレクトリで検索されて、最後に標準リストのディレクトリで検索されます。名前が山括弧 (\fB< > \fR) で囲まれた \fB#include\fR ファイルの場合、\fB#include\fR 行を含むファイルのあるディレクトリは検索されません。この検索順序の詳細については、以下の\fB「詳細」\fRを参照してください。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-U\fR\fIname\fR\fR
.ad
.RS 15n
.rt  
\fIname\fR の初期定義をすべて削除します。ここで、\fIname\fR は個々のプリプロセッサによって事前定義されたシンボルです。以下に、システムのアーキテクチャーに応じて事前定義されているシンボルリストの一部を示します。 
.sp
.ne 2
.mk
.na
\fBオペレーティングシステム: \fR
.ad
.sp .6
.RS 4n
\fBibm\fR, \fBgcos\fR, \fBos\fR, \fBtss\fR and \fBunix\fR
.RE

.sp
.ne 2
.mk
.na
\fBハードウェア: \fR
.ad
.sp .6
.RS 4n
\fBinterdata\fR、\fBu3b20d\fR、\fB ns32000\fR、\fBi386\fR、\fBsparc\fR、および \fB sun\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fBUNIX システムからの派生: \fR\fR
.ad
.sp .6
.RS 4n
\fBRES\fR および \fBRT\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fBlint\fR コマンド:\fR
.ad
.sp .6
.RS 4n
\fBlint\fR
.RE

シンボル \fBsun\fR、\fBsparc\fR、 \fBunix\fR は、すべての Sun システムで定義されています。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-Y\fR\fIdirectory\fR\fR
.ad
.RS 15n
.rt  
\fB#include\fR ファイルを検索する場合は、標準のディレクトリリストの代わりに、ディレクトリ \fIdirectory\fR を使用します。
.RE

.SH 使用法
.SS "指令"
.sp
.LP
すべての \fBcpp\fR 指令行は、ハッシュシンボル (\fB#\fR) で始まります。適切なインデンテーションを行うために、スペース (SPACE または \fBTAB\fR 文字) を # の後に入れることができます。
.sp
.ne 2
.mk
.na
\fB\fB#define\fR \fIname token-string\fR\fR
.ad
.sp .6
.RS 4n
これ以降、\fIname\fR を \fItoken-string\fR で置き換えます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB#define\fR \fIname\fR\fB(\fR\fIargument\fR [\fB,\fR \fIargument\fR] . . .\fB)\fR\fI token-string\fR\fR
.ad
.sp .6
.RS 4n
\fIname\fR と \fB(\fR の間にスペースを入れることはできません。括弧で囲んだ引数のリストが後に続く、以降の \fIname\fR を \fItoken-string\fR で置き換えします。ここで、\fItoken-string\fR 中の各 \fIargument\fR は、コンマで区切られたリスト内の対応するトークンで置き換えられます。引数を持つマクロが展開されると、引数は展開された \fItoken-string\fR にそのまま入れられます。\fItoken-string\fR 全体が展開されると、\fBcpp\fR は、新たに作成された \fItoken-string\fR の先頭から、展開すべき名前の検索を再開します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB#undef\fR \fIname\fR\fR
.ad
.sp .6
.RS 4n
シンボル \fIname\fR の定義をすべて削除します。\fIname\fR の後の指令行には、トークンを付加することはできません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB#include "\fR\fIfilename\fR\fB "\fR\fR
.ad
.br
.na
\fB\fB#include\fR \fB<\fR\fI filename\fR\fB>\fR\fR
.ad
.sp .6
.RS 4n
この位置に \fIfilename\fR の内容を読み込みます。このデータは、現在のファイルの一部であるかのように \fBcpp\fR によって処理されます。\fB<\fR\fIfilename\fR\fB >\fR の表記法を使用すると、\fIfilename\fR は標準の \fBinclude\fR ディレクトリのみで検索されます。詳細については、前述の \fB-I\fR および \fB-Y\fR オプションを参照してください。最後の \fB"\fR または \fB >\fR の後の指令行にはトークンを付加することはできません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB#line\fR \fIinteger-constant\fR\fB "\fR\fIfilename\fR\fB"\fR\fR
.ad
.sp .6
.RS 4n
C コンパイラの次のパスのための行制御情報を生成します。\fIinteger-constant\fR は次の行の行番号として解釈され、\fIfilename\fR はその行を含むファイルとして解釈されます。\fB\fR\fIfilename\fR\fB\fR が指定されていない場合、現在のファイル名は変更されません。オプションの \fIfilename\fR の後の指令行には、トークンを付加することはできません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB#if\fR \fIconstant-expression\fR\fR
.ad
.sp .6
.RS 4n
対応する \fB#else\fR、\fB#elif\fR、または \fB#endif\fR 指令までの後続行は、\fIconstant-expression\fR が 0 以外の値に評価された場合にのみ出力されます。\fB&&\fR、\fB| |\fR、および \fB,\fR を含む、C 言語における代入以外のすべての 2 項演算子を、\fIconstant-expression\fR 中で使用できます。\fB?:\fR 演算子と単項演算子 \fB-\fR と \fB!\fR、および \fB~\fR も \fIconstant-expression\fR 中で使用できます。
.sp
これらの演算子の優先順位は、C における優先順位と同じです。また、単項演算子 \fBdefined\fR は、次の 2 つの形式で \fIconstant-expression\fR 中で使用できます。つまり、\fBdefined (\fR \fIname \fR \fB)\fR または \fBdefined\fR \fI name\fR です。これにより、\fB#ifdef\fR および \fB#ifndef\fR の各ディレクトリ (下記参照) は \fB#if\fR 指令で有効になります。\fBcpp\fR によって認識されている演算子、整数定数、および名前だけを \fIconstant-expression\fR 内で使用する必要があります。特に、\fBsize\fR \fBof\fR 演算子は使用できません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB#ifdef\fR \fIname\fR\fR
.ad
.sp .6
.RS 4n
対応 \fB#else\fR、\fB#elif\fR、または \fB#endif\fR までの後続行は、\fIname\fR が \fB#define\fR 指令または \fB--D\fR オプションのいずれかによって定義されており、\fBname\fR が #undef 指令の対象となっていない場合にのみ出力されます。指令行上の \fIname\fR の後に付加されたトークンは無視されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB#ifndef\fR \fIname\fR\fR
.ad
.sp .6
.RS 4n
対応する \fB#else\fR、\fB#elif\fR、または \fB#endif\fR までの後続行は、\fIname\fR が定義されて\fIいない\fRか、あるいは、その定義が \fB#undef\fR 指令の対象となっていない場合にのみ出力されます。\fIname\fR の後の指令行には、トークンを付加することはできません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB#elif\fR \fIconstant-expression\fR\fR
.ad
.sp .6
.RS 4n
\fB#if\fR、\fB#ifdef\fR、または \fB#ifndef\fR 指令と、対応する \fB#else\fR または \fB#endif\fR 指令の間には、任意の数の \fB#elif\fR 指令を置くことができます。\fB#elif\fR 指令に続く行は、次の条件がすべてあてはまる場合にのみ出力されます。 
.RS +4
.TP
.ie t \(bu
.el o
先行する \fB#if\fR 指令で \fIconstant-expression\fR が 0 と評価され、先行する \fB#ifdef\fR で \fIname\fR が定義されていない、あるいは先行する \fB#ifndef\fR 指令で \fIname\fR が定義\fIされていた\fR。
.RE
.RS +4
.TP
.ie t \(bu
.el o
すべての \fI#elif\fR 指令の対象となっている \fBconstant-expression\fR が 0 に評価されました。
.RE
.RS +4
.TP
.ie t \(bu
.el o
現在の \fIconstant-expression\fR が 0 以外に評価されました。
.RE
\fIconstant-expression\fR が \fB0\fR 以外に評価された場合、後続の \fB#elif\fR と \fB#else\fR 指令は、対応する #endif まで無視されます。\fB#if\fR 指令で使用できる \fIconstant-expression\fR はすべて、\fB#elif\fR 指令でも使用できます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB#else\fR\fR
.ad
.sp .6
.RS 4n
これは、条件指令の意味を反転します。つまり逆の意味になります。先行する条件指令が、行を含めることを示す場合、\fB#else\fR と対応する \fB#endif\fR の間の行は無視されます。先行する条件指令が、行を無視することを示す場合、後続の行は出力に含まれます。条件指令と対応する \fB#else\fR 指令はネストできます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB#endif\fR\fR
.ad
.sp .6
.RS 4n
条件指令 \fB#if\fR、\fB#ifdef\fR、または \fB#ifndef\fR のいずれかによって開始した行セクションを終了します。このような各指令には、対応する \fB#endif\fR が必要です。
.RE

.SS "マクロ"
.sp
.LP
マクロの正規パラメータは、文字定数や引用文字列内で発生する場合でも、\fB#define\fR 指令の本体で認識されます。たとえば、次の指令を見てください。
.sp
.in +2
.nf
#define abc(a)|`|a|
abc(xyz) 
.fi
.in -2
.sp

.sp
.LP
出力は次のようになります。
.sp
.in +2
.nf
# 1 ""
|`|xyz |
.fi
.in -2
.sp

.sp
.LP
2 番目の行は復帰改行です。最後の 7 文字は \fB|`|xyz| \fR (縦線、逆引用符、縦線、x、y、z、縦線) です。マクロ名は、通常の走査中は、文字定数や引用文字列内では認識されません。したがって、
.sp
.in +2
.nf
#define abc xyz
printf("abc");
.fi
.in -2
.sp

.sp
.LP
前述の指令は、2 番目の行で abc を展開しません。これは、\fBabc\fR が、\fB#define\fR マクロ定義の一部ではない引用文字列内にあるためです。
.sp
.LP
マクロは、\fB#define\fR または \fB#undef\fR の処理中には展開されません。したがって、
.sp
.in +2
.nf
#define abc zingo
#define xyz abc
#undef abc
xyz
.fi
.in -2
.sp

.sp
.LP
前述の指令は \fBabc\fR を作成します。\fB#ifdef\fR または \fB#ifndef\fR のすぐ後にあるトークンは展開されません。
.sp
.LP
マクロは、別のマクロ呼び出しへの実際のパラメータを判別する走査中は展開されません。 
.sp
.in +2
.nf
#define reverse(first,second)second first
#define greeting hello
reverse(greeting,
#define greeting goodbye
)
.fi
.in -2
.sp

.sp
.LP
の出力は次のようになります。  
.sp
.in +2
.nf
#define hello goodbye  hello
.fi
.in -2
.sp

.SS "出力"
.sp
.LP
出力は入力ファイルのコピーからなり、変更が加えられており、次の形式の行が追加されています。
.sp
.in +2
.nf
\fB#\fR\fIlineno\fR \fB"\fR \fIfilename\fR\fB"\fR \fB"\fR\fIlevel\fR\fB"\fR
.fi
.in -2
.sp

.sp
.LP
後続の出力行の元のソース行番号とファイル名、および、これがインクルードファイルを入力した後の最初のそのような行であるか (\fIレベル\fR \fB1\fR)、インクルードファイルが終了した後の最初のそのような行であるか (\fIレベル \fR\fB2\fR)、あるいはそれ以外のそのような行であるか (\fIlevel\fR は空) を示します。
.SS "詳細"
.sp
.LP
このセクションでは、使用法の詳細を示します。
.SS "\fIディレクトリの検索順序\fR"
.sp
.LP
\fB#include\fR ファイルは、次の順序で検索されます。
.RS +4
.TP
1.
\fB#include\fR 要求を含むファイルのディレクトリ (つまり \fB#include\fR は、要求が行われたときに、検索されているファイルに対応します)。
.RE
.RS +4
.TP
2.
\fB-I\fR オプションで指定された複数のディレクトリ。左から右の順に検索されます。
.RE
.RS +4
.TP
3.
標準ディレクトリ (\fBUNIX\fR システム上の \fB/usr/include\fR)
.RE
.SS "\fI特殊名\fR"
.sp
.LP
\fBcpp\fR は、2 つ特別な名前を認識します。名前 \fB_  _LINE_  _\fR は、\fBcpp\fR が認識する現在の行番号 (10 進整数) として定義されます。\fB_  _FILE_  _\fR は、\fBcpp\fR が認識する現在のファイル名 (C 文字列) として定義されます。これらは、他の定義済み名と同様に、任意の場所 (マクロ内を含む) で使用できます。
.SS "\fI改行文字\fR"
.sp
.LP
NEWLINE 文字は、文字定数または引用文字列を終了します。エスケープされた NEWLINE 文字 (つまり、バックスラッシュが先行する NEWLINE) を \fB#define\fR 文の本体で使用すると、定義を次の行に続けることができます。エスケープされた NEWLINE は、マクロ値には含まれません。
.SS "\fI注釈\fR"
.sp
.LP
注釈は削除されます (コマンド行に \fB-C\fR オプションが指定されている場合を除く)。また、注釈がトークンを終了する場合をのぞき注釈は、無視されます。
.SH 終了ステータス
.sp
.LP
次の終了ステータスが返されます。
.sp
.ne 2
.mk
.na
\fB\fB0\fR\fR
.ad
.RS 12n
.rt  
正常終了。
.RE

.sp
.ne 2
.mk
.na
\fB0 以外\fR
.ad
.RS 12n
.rt  
エラーが発生した。
.RE

.SH 属性
.sp
.LP
属性についての詳細は、マニュアルページの \fBattributes\fR(5) を参照してください。
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
属性タイプ属性値
_
使用条件developer/build/make
.TE

.SH 関連項目
.sp
.LP
\fBm4\fR(1), \fBattributes\fR(5)
.SH 診断
.sp
.LP
\fBcpp\fR によって生成されるエラーメッセージは、読めばわかるものです。エラーが発生した行番号とファイル名が、診断と共に出力されます。
.SH 注意事項
.sp
.LP
NEWLINE 文字が、展開されるマクロの引数リストで検出された場合、以前のバージョンの \fBcpp\fR の中には、NEWLINE 文字が検出されて展開された場合のように、NEWLINE 文字を出力するものがあります。現在のバージョンの \fBcpp\fR は、NEWLINE 文字を SPACE 文字で置き換えします。
.sp
.LP
インクルードファイルの標準ディレクトリは環境によって異なる場合があるため、次の形式の \fB#include\fR 指令を使用する必要があります。
.sp
.in +2
.nf
\fB#include <file.h>\fR
.fi
.in -2

.sp
.LP
次のような絶対パスを使用する #include 指令は使用しないようにしてください。
.sp
.in +2
.nf
\fB#include "/usr/include/file.h"\fR
.fi
.in -2

.sp
.LP
\fBcpp\fR は、絶対パス名が使用されていれば警告を出します。
.sp
.LP
コンパイラでは 8 ビットの文字列と注釈を使用できますが、コンパイラ以外では 8 ビットは使用できません。
