'\" te
.\" Copyright (c) 2011, 2012, Oracle and/or its affiliates.All rights reserved.
.TH aimanifest 1M "2012 年 6 月 19 日" "SunOS 5.11" "系统管理命令"
.SH 名称
aimanifest \- 修改自动化安装程序 (Automated Installer, AI) 所使用的 XML 文件
.SH 用法概要
.LP
.nf
/usr/bin/aimanifest [-h]
.fi

.LP
.nf
aimanifest add [-r] \fIpath\fR \fIvalue\fR
.fi

.LP
.nf
aimanifest delete \fIpath\fR
.fi

.LP
.nf
aimanifest get [-r] \fIpath\fR
.fi

.LP
.nf
aimanifest set [-r] \fIpath\fR \fIvalue\fR
.fi

.LP
.nf
aimanifest load [-i] \fIfilename\fR
.fi

.LP
.nf
aimanifest validate
.fi

.SH 描述
.sp
.LP
\fBaimanifest\fR 命令可创建新的 XML 清单或修改现有的清单。虽然 \fBaimanifest\fR 可用于包含对 DTD 定义的有效 \fB!DOCTYPE\fR 引用的任何 XML 文件，但它的设计目的是创建供自动化安装程序 (Automated Installer, AI) 使用的派生清单。有关 AI 派生清单的信息，请参见《\fI安装 Oracle Solaris 11 系统\fR》。
.sp
.LP
可以多次调用 \fBaimanifest\fR 命令以开发清单。\fBAIM_MANIFEST\fR 环境变量指定供 \fBaimanifest\fR 进行修改的清单的位置。必须设置 \fBAIM_MANIFEST\fR。每次调用带有 \fBload\fR、\fBadd\fR 或 \fBset\fR 子命令的 \fBaimanifest\fR 命令时，都会打开、修改和保存 \fBAIM_MANIFEST\fR 文件。
.sp
.LP
\fBaimanifest\fR 命令可以修改的最小 \fBAIM_MANIFEST\fR 文件必须包含以下两项：
.RS +4
.TP
.ie t \(bu
.el o
对适用于所开发的 XML 清单的 DTD 的 \fB!DOCTYPE\fR 引用。
.RE
.RS +4
.TP
.ie t \(bu
.el o
该清单的根元素。
.RE
.sp
.LP
如果开始时使用空 \fBAIM_MANIFEST\fR 文件，则在 AI 要执行派生清单脚本时，第一个 \fBaimanifest\fR 命令必须指定 \fBload\fR 子命令，以至少装入所需的最小 \fBAIM_MANIFEST\fR 文件。修改清单的后续 \fBaimanifest\fR 命令使用 DTD 来确定在正在开发的清单中的何处添加元素。
.sp
.LP
除了将消息显示到 \fBstdout\fR 和 \fBstderr\fR 外，若要将错误消息和信息性消息保存到文件，请将 \fBAIM_LOGFILE\fR 环境变量设置为日志文件位置。信息将附加到该日志文件。该日志文件不会被清除。
.SH 选项
.sp
.LP
\fBaimanifest\fR 命令包含以下选项：
.sp
.ne 2
.mk
.na
\fB\fB-h\fR，\fB--help\fR\fR
.ad
.sp .6
.RS 4n
显示用法帮助消息。
.RE

.sp
.LP
\fBaimanifest\fR 命令的 \fBadd\fR、\fBget\fR 和 \fBset\fR 子命令具有以下选项：
.sp
.ne 2
.mk
.na
\fB\fB-r\fR, \fB--return-path\fR\fR
.ad
.sp .6
.RS 4n
返回此 \fBaimanifest\fR 命令创建（或对其执行操作）的每个 XML 元素的路径。每个返回路径都是节点 ID 链。您可以保存这些返回的路径，以在对 \fBaimanifest\fR 的后续调用中使用。与使用 XML 元素和属性值指定路径相比，使用 \fB-r\fR 选项返回的路径会更为可靠，因为值可能会随所构建的 AI 清单而更改。有关 \fB-r\fR 选项返回的路径的更多信息，请参见“返回路径”部分。
.RE

.sp
.LP
\fBaimanifest\fR 命令的 \fBload\fR 子命令包含以下选项：
.sp
.ne 2
.mk
.na
\fB\fB-i\fR, \fB--incremental\fR\fR
.ad
.sp .6
.RS 4n
在添加新数据之前，不清除现有的 \fBAIM_MANIFEST\fR 数据。
.RE

.SH 子命令
.sp
.LP
支持以下子命令：
.sp
.ne 2
.mk
.na
\fB\fBaimanifest add [-r | --return-path] \fIpath \fR \fIvalue\fR\fR\fR
.ad
.sp .6
.RS 4n
将新元素添加到 XML 清单。在 \fIpath\fR 上添加新元素，其值为 \fIvalue\fR。有关 \fIpath\fR 的更多信息，请参见“操作数”部分。如果 \fIpath\fR 以属性 (\fB@\fIattr\fR\fR) 结尾，则新元素具有 \fIattr\fR 属性，而 \fIvalue\fR 为该属性的值。
.sp
除了检查 \fIpath\fR 中的父/子关系外，不执行任何验证。
.sp
\fB-r\fR 选项可返回新添加节点的路径。有关更多信息，请参见“返回路径”部分。
.sp
如果父路径与 \fBAIM_MANIFEST\fR 文件中的元素匹配，则它必须仅与一个元素匹配。新元素将创建为匹配的父元素的子项。该路径可以指定元素和属性值以匹配唯一的父元素，如本部分中“示例 2：带有值的路径”所示。
.sp
.LP
如果父路径与 \fBAIM_MANIFEST\fR 文件中的元素不匹配，则根据需要创建新元素并将新子元素添加到新父元素中。根据以下规则，将已添加元素的路径从以前存在的元素中分割出来：
.RS +4
.TP
.ie t \(bu
.el o
分割发生在路径中用于指定某个值的所有组成部分之后。
.RE
.RS +4
.TP
.ie t \(bu
.el o
分割发生在路径中用于指定某个值的所有组成部分之后，且在 DTD 允许多个带相同标记的相关元素的第一个位置处。
.RE
.sp
.LP
使用该 XML 清单模式分析以下示例：
.RS +4
.TP
.ie t \(bu
.el o
清单以单个 A 节点开始。
.RE
.RS +4
.TP
.ie t \(bu
.el o
A 节点只能有一个 B 节点子项。
.RE
.RS +4
.TP
.ie t \(bu
.el o
B 节点可以有多个 C 节点子项。
.RE
.RS +4
.TP
.ie t \(bu
.el o
C 节点可以有多个 D 节点子项。
.RE
\fB示例 1：简单路径\fR。AI 清单具有一个 A 节点、一个 B 节点和一个 C 节点：\fB/A/B/C\fR。在 \fIpath\fR 为 \fB/A/B/C/D\fR 的情况下发出 \fBadd\fR 子命令。在这种情况下，将创建新的 C 节点，因为 C 节点是路径中可以具有带相同标记的同级节点的第一个节点。将添加新 D 节点作为新 C 节点的子项。生成的清单结构为 \fB/A/B/{C,C/D}\fR。针对不同的 D 值发出同一命令将会产生三个 C 节点：\fB/A/B/{C,C/D,C/D}\fR。
.sp
\fB示例 2：带有值的路径\fR。AI 清单具有一个 A 节点、一个 B 节点和两个 C 节点。只有其中一个 C 节点的值为 1，因此清单的结构为 \fB/A/B/{C,C=1}\fR。在 \fIpath\fR 为 \fB/A/B/C=1/D\fR 和 \fIvalue\fR 为 10 的情况下发出 \fBadd\fR 子命令。在这种情况下，不会添加新的 C 节点，因为对 C 指定值 1 会标识唯一的节点，该路径不能在指定了值的分支上或其之前进行分割。该路径可以进行分割的第一个位置是 D 处。将添加值为 10 的新 D 节点作为值为 1 的 C 节点的子项。生成的清单结构为 \fB/A/B/{C,C=1/D=10}\fR。针对值为 20 的 D 发出同一命令将产生 \fB/A/B/{C,C=1/{D=10,D=20}}\fR。
.RE

.sp
.ne 2
.mk
.na
\fBaimanifest delete \fIpath\fR\fR
.ad
.sp .6
.RS 4n
删除与 path 匹配的所有节点或属性。如果 path 指定了节点，则会删除以与 path 匹配的每个节点为根的子树。如果 path 与属性匹配，则会删除与 path 匹配的所有属性；不删除任何节点。有关 path 的更多信息，请参见“Path 操作数”部分。
.sp
成功时，会将匹配项的数目输出到 \fBstdout\fR：
.sp
.in +2
.nf
5 element(s)/subtree(s) deleted
5 attribute(s) deleted
.fi
.in -2
.sp

.RE

.sp
.ne 2
.mk
.na
\fB\fBaimanifest get [-r | --return-path] \fIpath \fR\fR\fR
.ad
.sp .6
.RS 4n
检索与 path 匹配的每个元素或属性的值。对于空元素或属性值，将显示空字符串 (\fB""\fR)。有关 path 的更多信息，请参见“Path 操作数”部分。
.sp
\fB-r\fR 选项返回每个已访问节点的路径作为每个节点的第二个返回字符串。有关更多信息，请参见“返回路径”部分。
.RE

.sp
.ne 2
.mk
.na
\fB\fBaimanifest set [-r | --return-path] \fIpath \fR \fIvalue\fR\fR\fR
.ad
.sp .6
.RS 4n
更改与 path 匹配的每个元素或属性的值，或者为与 path 匹配的现有元素创建新属性。不执行任何验证。有关 path 的更多信息，请参见“Path 操作数”部分。
.sp
设置某个属性值时，该属性不需要存在，但该属性所属的元素必须存在。
.sp
如果未指定 \fB-r\fR 选项，则成功时会将匹配项的数目输出到 \fBstdout\fR：
.sp
.in +2
.nf
5 element(s) set
5 attribute(s) set
.fi
.in -2
.sp

.RE

.sp
.ne 2
.mk
.na
\fB\fBaimanifest load [-i | --incremental] \fIfilename \fR\fR\fR
.ad
.sp .6
.RS 4n
从文件 \fIfilename\fR 中装入 XML 清单或部分 XML 清单。除了检查元素的父/子关系外，不执行任何验证。
.sp
如果未指定 \fB-i\fR 选项，将覆盖任何现有 XML 数据。\fBAIM_MANIFEST\fR 文件中的所有数据将替换为 \fIfilename\fR 文件的内容。\fIfilename\fR 文件必须包括对 DTD 的 \fB!DOCTYPE\fR 引用，以便后续 \fBaimanifest\fR 命令可以修改该文件。
.sp
如果指定 \fB-i\fR 选项，则在添加新数据之前，不清除 \fBAIM_MANIFEST\fR 数据。而是，以增量方式插入新数据或将新数据与现有 XML 数据合并。\fBAIM_MANIFEST\fR 中 \fB!DOCTYPE\fR 引用指定的 DTD 用于确定合并 \fIfilename\fR 数据的方式和位置。如果缺少 \fB!DOCTYPE\fR 引用，将使用位于 \fB/usr/share/install/ai.dtd\fR 的 AI 清单 DTD。如果 \fIfilename\fR 中的数据无法与 DTD 协调，将返回非零错误状态。
.sp
.LP
以下注意事项会影响将新数据插入到 \fBAIM_MANIFEST\fR 清单的位置：
.RS +4
.TP
.ie t \(bu
.el o
\fBAIM_MANIFEST\fR 数据路径和 \fIfilename\fR 数据路径开头附近元素的标记的匹配程度
.RE
.RS +4
.TP
.ie t \(bu
.el o
这些 \fBAIM_MANIFEST\fR 数据元素下所允许的子元素
.RE
.RS +4
.TP
.ie t \(bu
.el o
允许带相同标记的同级元素的位置
.RE
.RS +4
.TP
.ie t \(bu
.el o
不带子项的 \fBAIM_MANIFEST\fR 数据节点所在的位置
.RE
.sp
.LP
处理 \fIfilename\fR 数据的每个元素时，如果符合以下所有条件，则通常不会在 \fBAIM_MANIFEST\fR 数据中为此元素创建新节点。而是，使用新数据替换现有节点。
.RS +4
.TP
.ie t \(bu
.el o
两个数据集均包含具有相同标记和相同位置的节点。
.RE
.RS +4
.TP
.ie t \(bu
.el o
\fBAIM_MANIFEST\fR 中 \fB!DOCTYPE\fR 引用指定的 DTD 不允许这两个节点作为带相同标记的同级元素一起存在。
.RE
.RS +4
.TP
.ie t \(bu
.el o
\fIfilename\fR 数据元素具有子项。
.RE
插入 \fIfilename\fR 中的元素时，将在开始创建新节点的位置进行分割，尽可能地接近 \fBAIM_MANIFEST\fR 数据根。分割的第一个新节点将在允许带相同标记的同级元素的最早点创建，或者在相应的最早点（如果 \fBAIM_MANIFEST\fR 中不存在带相同标记的元素）创建。
.sp
.LP
使用该 XML 清单模式分析以下示例：
.RS +4
.TP
.ie t \(bu
.el o
清单以单个 A 节点开始。
.RE
.RS +4
.TP
.ie t \(bu
.el o
A 节点只能有一个 B 节点子项。
.RE
.RS +4
.TP
.ie t \(bu
.el o
B 节点可以有多个 C 节点子项。
.RE
.RS +4
.TP
.ie t \(bu
.el o
B 节点只能有一个 E 节点子项。
.RE
.sp
.LP
\fB示例 1：插入带相同标记的元素\fR。如果 \fBAIM_MANIFEST\fR 的内容为 \fB/A/B/C1/D1\fR，而 \fIfilename\fR 的内容为 \fB/A/B/C2/D2\fR，则在执行 \fBload -i\fR 命令后，\fBAIM_MANIFEST\fR 文件的内容为 \fB/A/B/{C1/D1,C2/D2}\fR。C 节点是可以添加新节点的第一个位置。\fIfilename\fR 数据中的 C 节点将添加到 \fBAIM_MANIFEST\fR 数据的现有 C 节点之后。如果两个 A 元素具有不同的值或者两个 B 元素具有不同的值，则 \fIfilename\fR 元素的值将替换 \fBAIM_MANIFEST\fR 元素的值。如果两个 A 元素具有不同的属性或者两个 B 元素具有不同的属性，则将合并属性值。
.RS +4
.TP
.ie t \(bu
.el o
同时存在于 \fBAIM_MANIFEST\fR 文件和 \fIfilename\fR 文件中的 A 和 B 的属性在合并文件中采用 \fIfilename\fR 文件中的值。
.RE
.RS +4
.TP
.ie t \(bu
.el o
存在于 \fBAIM_MANIFEST\fR 文件或 \fIfilename\fR 文件但不同时存在于这两个文件中的 A 和 B 的属性将都保留在合并文件中。
.RE
\fB示例 2：插入带不同标记的元素\fR。如果 \fBAIM_MANIFEST\fR 的内容为 \fB/A/B/C/D\fR，而 \fIfilename\fR 的内容为 \fB/A/B/E/F\fR，则在执行 \fBload -i\fR 命令后，\fBAIM_MANIFEST\fR 文件的内容为 \fB/A/B/{E/F,C/D}\fR。E 节点将添加到 DTD 允许该节点的第一个位置处。元素 A 和 B 的值是 \fIfilename\fR 中的值，而 A 和 B 的属性将从 \fIfilename\fR 合并到 \fBAIM_MANIFEST\fR，如上面的示例 1 所述。
.sp
有时，无法确定正确的合并位置。如果尚未在要合并的节点后添加所需的同级节点，则可能会发生这种情况。要避免出现此问题，请以 DTD 要求的顺序将多个节点或子树添加到公共父节点。如果无法确定节点的正确位置，请将节点放置在它的新同级节点列表的末尾。
.RE

.sp
.ne 2
.mk
.na
\fB\fBaimanifest validate\fR\fR
.ad
.sp .6
.RS 4n
针对 \fB!DOCTYPE\fR 语句中引用的 DTD 验证 \fBAIM_MANIFEST\fR 清单。错误将输出到 \fBstderr\fR。如果验证失败，将返回非零状态。
.RE

.SH 操作数
.sp
.LP
需要以下操作数。
.SS "Filename 操作数"
.sp
.LP
\fBload\fR 子命令需要 \fIfilename\fR 操作数，它是要装入到 \fBAIM_MANIFEST\fR 清单的完整或部分清单的名称。
.SS "Value 操作数"
.sp
.LP
\fBadd\fR 和 \fBset\fR 子命令需要 \fIvalue\fR 操作数。\fIvalue\fR 操作数是 \fIpath\fR 操作数指定的元素或属性的有效值。
.SS "Path 操作数"
.sp
.LP
\fBaimanifest\fR 命令的 \fBadd\fR、\fBdelete\fR、\fBget\fR 和 \fBset\fR 子命令需要 \fIpath\fR 操作数。路径定义元素和属性的 XML 分层结构中的节点。
.sp
.LP
XML 元素分层结构也称为 XML 树。在以下部分 AI 清单中，\fBauto_install\fR 元素是树的根，\fBai_instance\fR 和 \fBsoftware\fR 元素是分支或子树的根。
.sp
.in +2
.nf
<auto_install>
  <ai_instance>
    <software type="IPS"/>
  </ai_instance>
</auto_install>
.fi
.in -2

.sp
.LP
在 \fBaimanifest\fR 路径语法中，使用正斜杠字符 (/) 表示树结构中的分支。在当前示例中，\fBsoftware\fR 元素的路径为 \fB/auto_install/ai_instance/software\fR。
.sp
.LP
属性将绑定到一个元素。在 \fBaimanifest\fR 路径语法中，使用 at 符号 (@) 标识属性名称。\fBsoftware\fR 元素的 \fBtype\fR 属性的路径为 \fB/auto_install/ai_instance/software@type\fR。
.sp
.LP
\fBaimanifest\fR path 操作数可能对应于多个元素。如果需要以某个特定元素为目标，请根据需要包括元素和属性值以使路径唯一。例如，要为以下部分 AI 清单中定义的第二个分片指定大小，可以使用路径 \fB/auto_install/ai_instance/target/disk/slice[@name="4"]/size@val\fR 来指明要为哪个分片指定大小。
.sp
.in +2
.nf
<auto_install>
  <ai_instance>
    <target>
        <disk>
          <slice name="0"/>
          <slice name="4"/>
        </disk>
    </target>
  </ai_instance>
</auto_install>
.fi
.in -2

.sp
.LP
\fBget\fR、\fBset\fR 和 \fBdelete\fR 子命令接受可能对应于多个元素的路径。\fBadd\fR 子命令需要与单个（父）元素匹配的路径。
.sp
.LP
允许使用相对路径。可以从 \fBai_instance\fR、\fBtarget\fR、\fBdisk\fR 或 \fBslice\fR 开始指定上一段落中显示的 \fBslice\fR 路径，因为只有一个 \fBname\fR 属性值为 4 的 \fBslice\fR。例如，您可以使用路径 \fBslice[@name="4"]/size@val\fR。
.sp
.LP
如果 \fIpath\fR 内的 \fIvalue\fR 包含正斜杠字符，则该值必须用单引号或双引号括起来，如 \fB/name="pkg:/entire"\fR 所示。
.sp
.LP
如果 \fBaimanifest\fR 调用位于 shell 脚本中，则包含引号的值可能需要进行其他特殊处理。在 shell 脚本中，\fBaimanifest\fR 路径值中的引号可能需要用前导反斜杠字符 (\) 进行转义，以便 shell 不会删除或解释引号。检查要使用的 shell 规则。以下示例显示了 \fBksh93\fR 脚本中带有正斜杠字符的值：
.sp
.in +2
.nf
/usr/bin/aimanifest get software_data[name=\e"pkg:/entire\e"]@action
.fi
.in -2

.sp
.LP
本手册页中的大多数示例都省略了反斜杠转义字符，因为本手册页假定不在脚本或特定 shell 中调用 \fBaimanifest\fR。有关 AI 派生清单脚本的信息，请参见《\fI安装 Oracle Solaris 11 系统\fR》。
.sp
.LP
以下分支格式说明了如何构造元素或元素属性的路径。
.sp
.ne 2
.mk
.na
\fB\fB/A\fR\fR
.ad
.sp .6
.RS 4n
\fBA\fR 是元素的标记名称，如 \fB/auto_install\fR 所示。该分支规范也称为简单分支。只具有简单分支的路径称为简单路径。
.RE

.sp
.ne 2
.mk
.na
\fB\fB/A=\fIvalue\fR\fR\fR
.ad
.sp .6
.RS 4n
\fBA\fR 是元素的标记名称，\fIvalue\fR 是该元素的值，如 \fB/name="pkg:/entire"\fR 所示。
.RE

.sp
.ne 2
.mk
.na
\fB\fB/A[B/C=\fIvalue\fR]\fR\fR
.ad
.sp .6
.RS 4n
\fBA\fR 是一个元素，\fBB\fR 是 \fBA\fR 的子元素，\fBC\fR 是 \fBB\fR 的子元素，\fIvalue\fR 是 \fBC\fR 元素的值。该路径格式指定的 \fBA\fR 元素具有值为 \fIvalue\fR 的孙元素 \fBC\fR。例如，如果 AI 清单具有多个软件部分，您可以使用此格式对安装软件包 \fBpkg:/entire\fR 的软件部分进行操作，如以下路径所示：
.sp
.in +2
.nf
software[software_data/name="pkg:/entire"]
.fi
.in -2

.RE

.sp
.ne 2
.mk
.na
\fB\fB/A[@Aattr=\fIvalue\fR]\fR\fR
.ad
.sp .6
.RS 4n
\fBA\fR 是一个元素，\fBAattr\fR 是 \fBA\fR 的属性，而 \fIvalue\fR 是 \fBAattr\fR 属性的值。该路径格式指定的 \fBA\fR 元素具有值为 \fIvalue\fR 的属性 \fBAattr\fR。例如，如果 AI 清单定义了多个分片，您可以使用此格式对 \fBname\fR 值为 4 的分片进行操作，如 \fBslice[@name="4"]\fR 所示。
.RE

.sp
.ne 2
.mk
.na
\fB\fB/A[B/C@Cattr=\fIvalue\fR]\fR\fR
.ad
.sp .6
.RS 4n
\fBA\fR 是一个元素，\fBB\fR 是 \fBA\fR 的子元素，\fBC\fR 是 \fBB\fR 的子元素，\fBCattr\fR 是 \fBC\fR 的属性，而 \fIvalue\fR 是 \fBCattr\fR 属性的值。该路径格式指定的 \fBA\fR 元素具有孙元素 \fBC\fR，C 元素具有值为 \fIvalue\fR 的属性 \fBCattr\fR。例如，如果您的 AI 清单包含多个 software 部分，则可以使用此格式对包含某个 publisher 部分（其 name 值为 \fBsolaris\fR）的 software 部分进行操作，例如，使用路径 \fB software[source/publisher@name="solaris"] \fR。
.RE

.sp
.ne 2
.mk
.na
\fB\fB/A[1]\fR\fR
.ad
.sp .6
.RS 4n
\fB/A[1]\fR 指定清单中 \fBA\fR 元素的第一个实例。例如，如果 AI 清单具有多个软件部分，您可以使用此格式对第二个软件部分进行操作，如 \fB/auto_install[1]/ai_instance[1]/software[2]\fR 所示。
.sp
这是由 \fB-r\fR 选项返回的路径格式。请参见“返回路径”部分。
.RE

.sp
.ne 2
.mk
.na
\fB\fB/A@Aattr\fR\fR
.ad
.sp .6
.RS 4n
该路径指定了 \fBA\fR 元素的 \fBAattr\fR 属性。该路径不指定 \fBA\fR 元素，而是指定 \fBAattr\fR 属性。可使用此格式设置或获取 \fBAattr\fR 属性。
.RE

.sp
.ne 2
.mk
.na
\fB\fB/A[B/C=\fIvalue\fR]@Aattr\fR\fR
.ad
.sp .6
.RS 4n
该路径指定了 \fBA\fR 元素的 \fBAattr\fR 属性，A 元素具有值为 \fIvalue\fR 的孙元素 \fBC\fR。
.RE

.sp
.ne 2
.mk
.na
\fB\fB/A[B/C@Cattr=\fIvalue\fR]@Aattr \fR\fR
.ad
.sp .6
.RS 4n
该路径指定了 \fBA\fR 元素的 \fBAattr\fR 属性，A 元素具孙元素 \fBC\fR，C 元素具有值为 \fIvalue\fR 的属性 \fBCattr\fR。
.RE

.sp
.ne 2
.mk
.na
\fB\fB/A/B=\fIvalue\fR@Battr\fR\fR
.ad
.sp .6
.RS 4n
该路径指定了值为 \fIvalue\fR 的 \fBB\fR 元素的 \fBBattr\fR 属性。\fBB\fR 元素是 \fBA\fR 元素的子元素。
.RE

.SH 返回路径
.sp
.LP
使用 \fB-r\fR 选项时，\fBadd\fR、\fBget\fR 和 \fBset\fR 子命令将返回该子命令创建或访问的每个元素的地址。这些返回的地址采用节点 ID 链的格式。可以使用这些返回的地址再次访问返回的元素，即使与这些元素关联的值已更改也是如此。
.sp
.LP
以下示例说明，由 \fB-r\fR 选项返回的地址可能比指定元素和属性值的路径更易于使用。从以下节点树开始：
.sp
.in +2
.nf
        auto_install
             |
        ai_instance
             |
           target
             |
           disk
         attribute: whole_disk=true
             |
         disk_name
         attribute: name=data1
         attribute: name_type=volid
.fi
.in -2

.sp
.LP
添加具有 \fBname\fR 属性值 \fBdata2\fR 和 \fBname_type\fR 属性值 \fBvolid\fR 的新 \fBdisk\fR 节点：
.sp
.in +2
.nf
        auto_install
             |
        ai_instance
             |
           target
             |
  |----------|----------|
disk                  disk
whole_disk=true       whole_disk=true
    |                     |
disk_name             disk_name
name=data1            name=data2
name_type=volid       name_type=volid
.fi
.in -2

.sp
.LP
可以使用单个命令轻松添加具有一个属性的新 \fBdisk_name\fR 元素。要添加第二个和第三个属性，您必须指定要更改的 \fBdisk_name\fR 元素。比较以下用于多次访问同一节点的两种方法。
.SS "使用值指定路径"
.sp
.LP
此示例中的命令使用值指定路径。请注意，您必须在第一个命令中分配一个唯一值，以便可以使用该值在后续命令中指定唯一路径。如果值已更改，该方法可能会产生错误的结果。
.sp
.in +2
.nf
$ \fBaimanifest add target/disk/disk_name@name data2\fR
$ \fBaimanifest set \e\fR
> \fBtarget/disk/disk_name[@name=data2]@name_type volid\fR
$ \fBaimanifest set \e\fR
> \fBtarget/disk[disk_name@name=data2]@whole_disk true\fR
.fi
.in -2
.sp

.SS "使用返回路径指定路径"
.sp
.LP
多次访问同一节点的最可靠方法是将路径保存到新 \fBdisk_name\fR 元素，然后使用该保存路径进行后续访问。
.sp
.in +2
.nf
$ \fBNewDisk=$(aimanifest add -r target/disk@whole_disk true)\fR
$ \fBaimanifest add ${NewDisk}/disk_name@name data2\fR
$ \fBaimanifest add ${NewDisk}/disk_name@name_type volid\fR
.fi
.in -2
.sp

.sp
.LP
通过 \fB-r\fR 选项返回到 \fB$NewDisk\fR 的路径采用 ID 来表示节点，并且没有值：
.sp
.in +2
.nf
$ \fBaimanifest add -r target/disk/@whole_disk true\fR
/auto_install[1]/ai_instance[1]/target[1]/disk[2]
.fi
.in -2
.sp

.SH 示例
.sp
.LP
要尝试执行这些示例，您需要设置 \fBAIM_MANIFEST\fR。
.sp
.in +2
.nf
$ \fBexport AIM_MANIFEST=/tmp/aimtest.xml\fR
.fi
.in -2
.sp

.sp
.LP
\fBaimanifest\fR 命令可以修改的最小 \fBAIM_MANIFEST\fR 文件必须包含以下两项：
.RS +4
.TP
.ie t \(bu
.el o
对适用于所开发的 XML 清单的 DTD 的 \fB!DOCTYPE\fR 引用。
.RE
.RS +4
.TP
.ie t \(bu
.el o
该清单的根元素。
.RE
.sp
.LP
以下示例显示 AI 清单的最小 \fBAIM_MANIFEST\fR 清单文件：
.sp
.in +2
.nf
<!DOCTYPE auto_install SYSTEM "file:///usr/share/install/ai.dtd">
<auto_install/>
.fi
.in -2

.sp
.LP
通常，您将在派生清单脚本中使用 \fBaimanifest\fR 命令，对现有的有效 AI 清单进行操作。要尝试执行这些示例，您可以复制 \fB/usr/share/auto_install/manifest/default.xml\fR，然后定义 \fBAIM_MANIFEST\fR 以引用该副本。确保该副本可写。
.LP
\fB示例 1 \fR设置 \fBauto_reboot\fR 属性
.sp
.in +2
.nf
$ \fBaimanifest set /auto_install/ai_instance@auto_reboot false\fR
.fi
.in -2
.sp

.LP
\fB示例 2 \fR获取 \fBauto_reboot\fR 值
.sp
.in +2
.nf
$ \fBaimanifest get /auto_install/ai_instance@auto_reboot\fR
false
.fi
.in -2
.sp

.LP
\fB示例 3 \fR使用值路径添加发布者
.sp
.LP
该示例中的软件包系统信息库是 \fBfile:///net/host2/export/extras_repo\fR 中的文件系统信息库。发布者为 \fBextras\fR。由于一个 \fBsoftware\fR 元素只能具有一个 \fBsource\fR 元素，因此本示例会将新 \fBpublisher\fR 元素添加到包含 \fBsolaris\fR 发布者的 \fBsource\fR 元素中。

.sp
.in +2
.nf
$ \fBaimanifest add \e\fR
> \fBsoftware[@type=IPS]/source[publisher@name=solaris]/publisher@name \e\fR
\fBextras\fR
$ \fBaimanifest add \e\fR
> \fBpublisher[@name=extras]/origin@name \e\fR
> \fBfile:///net/host2/export/extras_repo\fR
.fi
.in -2
.sp

.sp
.LP
如果您以 \fBdefault.xml\fR AI 清单起步，则这些 \fBaimanifest\fR 命令将导致以下 AI 清单条目。为简明起见，省略了 \fBdestination\fR 和 \fBsoftware_data\fR 元素。

.sp
.in +2
.nf
<software type="IPS">
  <source>
    <publisher name="solaris">
      <origin name="http://pkg.oracle.com/solaris/release"/>
    </publisher>
    <publisher name="extras">
      <origin name="file:///net/host2/export/extras_repo"/>
    </publisher>
  </source>
</software>
.fi
.in -2

.LP
\fB示例 4 \fR使用返回路径添加发布者
.sp
.LP
此示例与上一示例相同，但使用不同的方法实现相同的结果。

.sp
.in +2
.nf
$ \fBNEW_PUB=$(aimanifest add -r \e\fR
> \fBsoftware[@type=IPS]/source[publisher@name=solaris]/publisher@name \e\fR
\fBextras)\fR
$ \fBecho $NEW_PUB\fR
/auto_install[1]/ai_instance[1]/software[1]/source[1]/publisher[2]
$ \fBaimanifest add ${NEW_PUB}/origin@name \e\fR
\fBfile:///net/host2/export/extras_repo\fR
.fi
.in -2
.sp

.LP
\fB示例 5 \fR通过添加清单片段添加发布者
.sp
.LP
本示例通过装入包含一个部分 AI 清单的文件添加 \fBextras\fR 发布者。在这种情况下，会单独生成一个附加的 IPS 类型的 \fBsoftware\fR 元素且定义有 \fBextras\fR 发布者。此新的 \fBsoftware\fR 元素将插入到定义了 \fBsolaris\fR 发布者的原始 IPS \fBsoftware\fR 元素之后。以这一新 \fBsoftware\fR 元素内的 \fBsoftware_data \fR 元素命名的软件包仅从 \fBextras\fR 发布者或此新 \fBsoftware\fR 元素中定义的其他发布者中进行搜索。此清单片段还定义了一个要安装的软件包，因为不包含要安装的软件的 \fBsoftware\fR 元素不起作用。

.sp
.LP
创建具有以下内容的名为 \fBextras.xml\fR 的文件：

.sp
.in +2
.nf
<auto_install>
  <ai_instance>
    <software type="IPS">
      <source>
        <publisher name="extras">
          <origin name="file:///net/host2/export/extras_repo"/>
        </publisher>
      </source>
      <software_data action="install">
        <name>pkg:/package/from/extras_repo</name>
      </software_data> 
    </software>
  </ai_instance>
</auto_install>
.fi
.in -2

.sp
.LP
即使您只需要 \fBsoftware\fR 部分，您也必须包括 \fBauto_install\fR 和 \fBai_instance\fR 元素。如果装入的文件为 \fBauto_install\fR 或 \fBai_instance\fR 元素指定属性，则这些属性值将替换现有值，或者将添加这些属性值。

.sp
.LP
使用以下命令将此 \fBsoftware\fR 部分添加到 \fBAIM_MANIFEST\fR 清单：

.sp
.in +2
.nf
$ \fBaimanifest load -i extras.xml\fR
.fi
.in -2
.sp

.LP
\fB示例 6 \fR使用值路径添加软件包
.sp
.LP
该示例通过将发布者名称指定为路径中的值，来将软件包添加到具有名为 \fBsolaris\fR 的 \fBpublisher\fR 元素的 \fBsoftware\fR 元素。

.sp
.in +2
.nf
$ \fBaimanifest add \e\fR
> \fBsoftware[source/publisher@name=solaris]/software_data/name \e\fR
> \fBpkg:/system/utils\fR
.fi
.in -2
.sp

.sp
.LP
如果您以 \fBdefault.xml\fR AI 清单起步，则 \fBaimanifest\fR 命令会添加下面显示的第二个 \fBsoftware_data \fR 元素。

.sp
.in +2
.nf
<software_data action="install">
  <name>pkg:/entire@latest</name>
  <name>pkg:/group/system/solaris-large-server</name>
</software_data>
<software_data>
  <name>pkg:/system/utils</name>
</software_data>
.fi
.in -2

.LP
\fB示例 7 \fR使用返回路径添加软件包
.sp
.LP
此示例与上一示例相同，但使用不同的方法实现相同的结果。本示例使用带有返回路径选项的 \fBget\fR 子命令将软件包添加到定义了 \fBsolaris\fR 发布者的 \fBsoftware\fR 元素。

.sp
.in +2
.nf
$ \fBNEW_PKG=$(aimanifest get -r \e\fR
\fBsoftware[source/publisher@name=solaris] | awk '{print $2 }')\fR
$ \fBecho $NEW_PKG\fR
/auto_install[1]/ai_instance[1]/software[1]
$ \fBaimanifest add ${NEW_PKG}/software_data/name \e\fR
\fBpkg:/system/utils\fR
.fi
.in -2
.sp

.LP
\fB示例 8 \fR使用 Python 从清单中删除 "entire" 软件包
.sp
.LP
此示例查找要安装的其名称中包含 "entire" 的软件包，并通过 from subprocess import Popen, PIPE 将其删除。

.sp
.in +2
.nf
AIMANIFEST = "/usr/bin/aimanifest"
NODEPATH = "software/software_data[@action=install]/name"
cmd = [ AIMANIFEST, "get", NODEPATH ]
popen_ret = Popen(cmd, stdout=PIPE)
popen_ret.wait()
entire = None
if popen_ret.returncode == 0:
   entire = [ pk.strip() for pk in popen_ret.stdout if "entire" in pk ]
if len(entire) == 1:
   cmd = [ AIMANIFEST, "delete", NODEPATH + "='" + entire[0] + "'" ]
   popen_ret = Popen(cmd, stdout=PIPE)
   popen_ret.wait()
if len(entire) != 1 or popen_ret.returncode != 0:
   print "delete of 'entire' package failed"
.fi
.in -2

.LP
\fB示例 9 \fR使用单个 "set" 命令更新所有磁盘的一个共有属性
.sp
.LP
此示例设置位于单个控制器上的四个磁盘，将它们全部添加到 "datapool" zpool 中。它使用三个 "set" 子命令更新全部四个磁盘的三个属性。

.sp
.in +2
.nf
NUM_C0_DISKS=4
          for ((num = 0; num <= NUM_C0_DISKS; num++)) ; do
                aimanifest add disk/disk_name@name \
                    /pci@0,0/pci108e,534a@7/disk@${num},0
          done
          aimanifest set disk/disk_name@name_type devpath
          aimanifest set disk@in_zpool datapool
          aimanifest set disk@whole_disk true
.fi
.in -2

.sp
.LP
这将在 <target> 子树中生成以下 XML：

.sp
.in +2
.nf
<target>
             <disk in_zpool="datapool" whole_disk="true">
               <disk_name name="/pci@0,0/pci@108e,534a@7/disk@0,0" name_type="devpath"/>
             </disk>
             <disk in_zpool="datapool" whole_disk="true">
               <disk_name name="/pci@0,0/pci@108e,534a@7/disk@1,0" name_type="devpath"/>
             </disk>

             <disk in_zpool="datapool" whole_disk="true">
               <disk_name name="/pci@0,0/pci@108e,534a@7/disk@2,0" name_type="devpath"/>
             </disk>
             <disk in_zpool="datapool" whole_disk="true">
               <disk_name name="/pci@0,0/pci@108e,534a@7/disk@3,0" name_type="devpath"/>
             </disk>
             ...
             ...
             </target>
.fi
.in -2

.LP
\fB示例 10 \fR通过添加清单片段添加软件包
.sp
.LP
本示例通过装入包含一个部分 AI 清单的文件来添加软件包。在这种情况下，会单独生成一个附加的 IPS 类型的 \fBsoftware\fR 元素，且该元素插入到原始 IPS \fBsoftware\fR 元素之后。这一新 \fBsoftware\fR 只包含一个 \fBsoftware_data\fR 元素；没有指定任何 \fBsource\fR 元素。以这一新 \fBsoftware\fR 元素中的 \fBsoftware_data\fR 元素命名的软件包会从上述的 \fBsoftware\fR 元素中定义的发布者中进行搜索。

.sp
.LP
创建具有以下内容的名为 \fBnewpkg.xml\fR 的文件：

.sp
.in +2
.nf
<auto_install>
  <ai_instance>
    <software type="IPS">
      <software_data>
        <name>pkg:/system/utils</name>
      </software_data>
    </software>
  </ai_instance>
</auto_install>
.fi
.in -2

.sp
.LP
即使您只需要 \fBsoftware\fR 部分，您也必须包括 \fBauto_install\fR 和 \fBai_instance\fR 元素。如果装入的文件为 \fBauto_install\fR 或 \fBai_instance\fR 元素指定属性，则这些属性值将替换现有值，或者将添加这些属性值。

.sp
.LP
使用以下命令将此 \fBsoftware\fR 部分添加到 \fBAIM_MANIFEST\fR 清单：

.sp
.in +2
.nf
$ \fBaimanifest load -i newpkg.xml\fR
.fi
.in -2
.sp

.LP
\fB示例 11 \fR验证清单
.sp
.LP
验证 \fBAIM_MANIFEST\fR 清单。

.sp
.in +2
.nf
$ \fBaimanifest validate\fR
.fi
.in -2
.sp

.SH 退出状态
.sp
.LP
将返回以下退出值：
.sp
.ne 2
.mk
.na
\fB\fB0\fR\fR
.ad
.RS 13n
.rt  
该命令被成功处理。
.RE

.sp
.ne 2
.mk
.na
\fB\fB>0\fR\fR
.ad
.RS 13n
.rt  
出现错误。
.RE

.SH 文件
.sp
.ne 2
.mk
.na
\fB\fBAIM_MANIFEST\fR\fR
.ad
.sp .6
.RS 4n
该环境变量的值是所构建的 AI 清单的位置。
.RE

.sp
.ne 2
.mk
.na
\fB\fBAIM_LOGFILE\fR\fR
.ad
.sp .6
.RS 4n
该环境变量的值是 \fBaimanifest\fR 操作的日志文件位置。
.RE

.SH 属性
.sp
.LP
有关下列属性的说明，请参见 \fBattributes\fR(5)：
.sp

.sp
.TS
tab() box;
cw(1.65i) |cw(3.85i) 
lw(1.65i) |lw(3.85i) 
.
属性类型属性值
_
可用性T{
\fBsystem/install/auto-install/auto-install-common\fR
T}
_
接口稳定性Committed（已确定）
.TE

.SH 另请参见
.sp
.LP
\fBinstalladm\fR(1M)
.sp
.LP
Part\ III, \fI"Installing Using an Install Server,"\fR in \fI《Installing Oracle Solaris 11.3 Systems》\fR
