'\" te
.\" Copyright (c) 2007, 2011, Oracle and/or its affiliates.All rights reserved.
.\" Copyright 1989
.\" Portions Copyright (c) 1982-2007 AT&T Knowledge Ventures
.TH trap 1 "2011 年 7 月 12 日" "SunOS 5.11" "用户命令"
.SH 名称
trap, onintr \- 用于响应（硬件）信号的 shell 内置函数
.SH 用法概要
.SS "sh"
.LP
.nf
\fBtrap\fR [\fIargument\fR \fIn\fR [\fIn2\fR]...]
.fi

.SS "csh"
.LP
.nf
\fBonintr\fR [\fB-|\fR \fIlabel\fR]
.fi

.SS "ksh88"
.LP
.nf
\fB*trap\fR [\fIarg\fR \fIsig\fR [\fIsig2\fR...]]
.fi

.SS "ksh"
.LP
.nf
\fB+trap\fR [\fB-p\fR] [\fIaction\fR \fIcondition\fR...]
.fi

.SH 描述
.SS "sh"
.sp
.LP
当 shell 接收数字或符号信号 (\fIn\fR) 时，会读取和执行 \fBtrap\fR 命令 \fIargument\fR。（注意：在设置陷阱和获取陷阱时分别扫描一次 \fIargument\fR。）陷阱命令按照信号编号或对应符号名称的顺序执行。尝试对输入到当前 shell 时忽略的信号设置陷阱将不起作用。尝试对信号 11（内存故障）设置陷阱会生成错误。如果 \fIargument\fR 不存在，则会将所有陷阱 \fIn\fR 重置为其原始值。如果 \fIargument\fR 为空字符串，则 shell 及其调用的命令将忽略该信号。如果 \fIn\fR 为 \fB0\fR，将在退出 shell 时执行命令 \fIargument\fR。不带参数的 \fBtrap\fR 命令输出与各信号编号关联的命令的列表。
.SS "csh"
.sp
.LP
\fBonintr\fR 控制 shell 在发生中断时的操作。未指定参数时，\fBonintr\fR 在中断时将恢复 shell 的缺省操作。（shell 会终止 shell 脚本并返回到终端命令输入级别）。指定了 \fB-\fR 参数时，shell 将忽略所有中断。指定了 \fIlabel\fR 参数时，当收到中断信号时或者当某个子进程因为被中断而终止时，shell 将执行 \fBgoto\fR \fIlabel\fR。
.SS "ksh88"
.sp
.LP
\fBtrap\fR 将 \fIarg\fR 用作要在 shell 接收信号 \fIsig\fR 时读取和执行的命令。在设置陷阱和获取陷阱时分别扫描一次 \fIarg\fR。可以将各个 \fIsig\fR 指定为信号编号或信号名称。\fBtrap\fR 命令按照信号编号的顺序执行。尝试对输入到当前 shell 时忽略的信号设置陷阱将不起作用。如果 \fIarg\fR 已省略或为 \fB-\fR，则会将各个 \fIsig\fR 的陷阱重置为其原始值。如果 \fIarg\fR 为空（空字符串，例如 \fB""\fR）字符串，则 shell 及其调用的命令将忽略该信号。如果 \fIsig\fR 为 \fBERR\fR，则只要命令的退出状态为非零值，就会执行 \fIarg\fR。如果 \fIsig\fR 为 \fBDEBUG\fR，则在每个命令之后执行 \fIarg\fR。对于在任何函数外部设置的 \fBtrap\fR，如果 \fIsig\fR 为 \fB0\fR 或 \fBEXIT\fR，则会在退出 shell 时执行命令 \fIarg\fR。不带参数的 \fBtrap\fR 命令输出与各信号编号关联的命令的列表。
.sp
.LP
在本手册页中，前面加有一个或两个 *（星号）的 \fBksh88\fR(1) 命令将通过以下方式进行特殊处理：
.RS +4
.TP
1.
命令完成时，该命令前面的变量赋值列表仍然有效。
.RE
.RS +4
.TP
2.
在变量赋值之后处理 I/O 重定向。
.RE
.RS +4
.TP
3.
脚本中包含的错误会导致其中止。
.RE
.RS +4
.TP
4.
如果字的后面是前面加有**的命令且字为变量赋值的格式，则使用与变量赋值相同的规则扩展这些字。这表示在 \fB=\fR 符号之后执行波浪号替换，并且不执行字拆分和文件名生成。
.RE
.SS "ksh"
.sp
.LP
\fBtrap\fR 是一个特殊的内置函数，用于定义发生诸如接收信号之类的情况时要执行的操作。\fBtrap\fR 也可以用于在标准输出中显示当前的陷阱设置。 
.sp
.LP
如果 \fIaction\fR 为 \fB-\fR，则 \fBtrap\fR 会将每种情况重置为缺省值。如果 \fIaction\fR 为空字符串，则 shell 会忽略每种情况（如果发生）。否则，发生相应的情况之一时，shell 将读取和执行参数 \fIaction\fR，就像由 \fBeval\fR 处理一样。陷阱操作将覆盖与每种指定情况关联的以前的所有操作。执行陷阱不会更改 \fB$?\fR 的值。 
.sp
.LP
\fIcondition\fR 可以是信号名称或信号编号，也可以是以下几项之一：
.sp
.ne 2
.mk
.na
\fB\fBEXIT\fR\fR
.ad
.RS 9n
.rt  
shell 退出时执行该陷阱。如果在带有 \fBfunction\fR 保留字的函数中定义了该选项，函数返回时将在调用者的环境中执行陷阱。陷阱操作将恢复为调用函数时的值。
.RE

.sp
.ne 2
.mk
.na
\fB\fB0\fR\fR
.ad
.RS 9n
.rt  
与 \fBEXIT\fR 相同。
.RE

.sp
.ne 2
.mk
.na
\fB\fBDEBUG\fR\fR
.ad
.RS 9n
.rt  
在每个简单命令执行之前但在参数扩展之后执行。
.RE

.sp
.ne 2
.mk
.na
\fB\fBERR\fR\fR
.ad
.RS 9n
.rt  
每当 \fBset -e\fR 会导致 shell 退出时就会执行。
.RE

.sp
.ne 2
.mk
.na
\fB\fBKEYBD\fR\fR
.ad
.RS 9n
.rt  
通过终端设备输入密钥时执行。
.RE

.sp
.LP
信号名称不区分大小写，\fBsig\fR 前缀是可选的。无法捕获或重置输入到非交互式 shell 时忽略的信号，但是这样做不会报告错误。使用除 1、2、3、6、9、14 和 15 之外的信号编号不可移植。 
.sp
.LP
尽管 trap 是一个特殊内置命令，但是指定 shell 不了解的情况会导致 trap 以\fB非零\fR退出状态退出，但不会终止正在调用的 shell。
.sp
.LP
如果未指定操作或情况，则会将当前的所有陷阱设置写入标准输出。
.sp
.LP
\fBksh\fR 中的 \fBtrap\fR 内置命令支持以下选项：
.sp
.ne 2
.mk
.na
\fB\fB-p\fR\fR
.ad
.RS 6n
.rt  
导致当前陷阱以可作为用于重新创建当前陷阱的 shell 输入处理的格式输出。
.RE

.sp
.LP
\fBksh\fR 中的陷阱内置命令将以下列值之一退出： 
.sp
.ne 2
.mk
.na
\fB\fB0\fR\fR
.ad
.RS 6n
.rt  
成功完成。
.RE

.sp
.ne 2
.mk
.na
\fB\fB>0\fR\fR
.ad
.RS 6n
.rt  
出现错误。
.RE

.sp
.LP
在本手册页中，前面有一个或两个 \fB+\fR（加号）的 \fBksh\fR(1) 命令按以下方式特殊处理：
.RS +4
.TP
1.
命令完成时，该命令前面的变量赋值列表仍然有效。
.RE
.RS +4
.TP
2.
在变量赋值之后处理 I/O 重定向。
.RE
.RS +4
.TP
3.
脚本中包含的错误会导致其中止。
.RE
.RS +4
.TP
4.
它们不是有效的函数名称。
.RE
.RS +4
.TP
5.
如果字的后面是前面加有 \fB++\fR 的命令且字为变量赋值的格式，则使用与变量赋值相同的规则扩展这些字。这表示在 \fB=\fR 符号之后执行波浪号替换，并且不执行字拆分和文件名生成。
.RE
.SH 属性
.sp
.LP
有关下列属性的说明，请参见 \fBattributes\fR(5)：
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
属性类型属性值
_
可用性system/core-os
.TE

.SH 另请参见
.sp
.LP
\fBcsh\fR(1)、\fBeval\fR(1)、\fBexit\fR(1)、\fBksh\fR(1)、\fBksh88\fR(1)、\fBsh\fR(1)、\fBattributes\fR(5)
