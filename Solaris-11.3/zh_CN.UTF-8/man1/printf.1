'\" te
.\" Copyright (c) 2009, 2012, Oracle and/or its affiliates.All rights reserved.
.\" Copyright 1992, X/Open Company Limited All Rights Reserved
.\" Portions Copyright (c) 1982-2007 AT&T Knowledge Ventures
.\" Sun Microsystems, Inc. gratefully acknowledges The Open Group for permission to reproduce portions of its copyrighted documentation.Original documentation from The Open Group can be obtained online at http://www.opengroup.org/bookstore/.
.\" The Institute of Electrical and Electronics Engineers and The Open Group, have given us permission to reprint portions of their documentation.In the following statement, the phrase"this text" refers to portions of the system documentation.Portions of this text are reprinted and reproduced in electronic form in the Sun OS Reference Manual, from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group Base Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group.In the event of any discrepancy between these versions and the original IEEE and The Open Group Standard,the original IEEE and The Open Group Standard is the referee document.The original Standard can be obtained online at http://www.opengroup.org/unix/online.html.This notice shall appear on any product containing this material. 
.TH printf 1 "2012 年 3 月 23 日" "SunOS 5.11" "用户命令"
.SH 名称
printf \- 写入格式化输出
.SH 用法概要
.SS "/usr/bin/printf"
.LP
.nf
\fBprintf\fR \fIformat\fR [\fIargument\fR]...
.fi

.SS "ksh"
.LP
.nf
\fBprintf\fR \fIformat\fR [\fIstring\fR...]
.fi

.SH 描述
.SS "/usr/bin/printf"
.sp
.LP
\fBprintf\fR 实用程序使用 \fIformat\fR 将每个字符串操作数写入标准输出以控制输出格式。
.SH 操作数
.SS "/usr/bin/printf"
.sp
.LP
\fB/usr/bin/printf\fR 支持以下操作数：
.sp
.ne 2
.mk
.na
\fB\fIformat\fR\fR
.ad
.RS 12n
.rt  
描述用于写入剩余操作数的格式的字符串。\fIformat\fR 操作数用作 \fIformat\fR 字符串（如 \fBformats\fR(5) 手册页所述），但下述情况例外： 
.RS +4
.TP
.ie t \(bu
.el o
在任何非转换规范标志的上下文中，格式字符串中的\fB空格\fR字符都被视为复制到输出的普通字符。
.RE
.RS +4
.TP
.ie t \(bu
.el o
格式字符串中的字符将被视为字符，而不会视为\fB空格\fR字符。
.RE
.RS +4
.TP
.ie t \(bu
.el o
除 \fBformats\fR(5) 手册页 (\fB\\\fR, \fB\a\fR, \fB\b \fR, \fB\f\fR, \fB\n\fR, \fB\r\fR, \fB\t\fR, \fB\v\fR) 上所述的转义序列外，还有 \fB\\fR\fIddd\fR，其中 \fIddd\fR 是一位、两位或三位八进制数字，并写为以八进制数字指定的数值的一个字节。
.RE
.RS +4
.TP
.ie t \(bu
.el o
该程序之前或之后没有来自 \fBd\fR 或 \fBu\fR 转换规范的输出（包含 \fIformat\fR 操作数未指定的空白字符）。
.RE
.RS +4
.TP
.ie t \(bu
.el o
该程序之前或之后没有来自 \fBo\fR 转换规范的输出（包含 \fIformat\fR 操作数未指定的前导零）。
.RE
.RS +4
.TP
.ie t \(bu
.el o
还支持另一个转换字符 \fBb\fR，如下所示。参数被视为可包含反斜杠转义序列的字符串。支持以下反斜杠转义序列：
.RS +4
.TP
.ie t \(bu
.el o
\fBformats\fR(5) 手册页 (\fB\\\fR, \fB\a\fR, \fB\b\fR, \fB \f\fR, \fB\n\fR, \fB\r\fR, \fB\t\fR, \fB\v\fR) 上列出的转义序列，将转换为其表示的字符
.RE
.RS +4
.TP
.ie t \(bu
.el o
\fB\0\fR\fIddd\fR，其中 \fIddd\fR 是一位、两位或三位八进制数字，将转换为包含由八进制数字指定的数值的字节
.RE
.RS +4
.TP
.ie t \(bu
.el o
\fB\c\fR，将写入并会导致 \fBprintf\fR 忽略包含该转义序列的字符串操作数中的任何剩余字符、任何剩余字符串操作数及 \fIformat\fR 操作数中的任何其他字符。
.RE
.RE
反斜杠（后跟任何其他字符序列）解释不确定。
.sp
写入转换字符串中的字节（直至字符串末尾，或者达到由精度规范指示的字节数）。如果省略精度，则会无限写入，即写入所有字节（直至转换字符串末尾）。对于使用参数的每个规范，将计算下一个参数操作数并将其转换为相应的转换类型，如下文指定。根据需要尽量多次重用 \fIformat\fR 操作数以满足参数操作数要求。在计算任何额外 \fBc\fR 或 \fBs\fR 转换规范时会假定提供了空字符串参数；计算其他额外转换规范时则假定提供了零参数。如果 \fIformat\fR 操作数不包含转换规范但包含 \fIargument\fR 操作数，则结果不确定。如果 \fIformat\fR 字符串中的某个字符序列以 \fB%\fR 字符开头，但未形成有效的转换规范，则行为不确定。
.RE

.sp
.ne 2
.mk
.na
\fB\fIargument\fR\fR
.ad
.RS 12n
.rt  
字符串将写入标准输出，并会受到 \fBformat\fR 的控制。如果对应的转换字符是 \fBb\fR、\fBc\fR 或 \fBs\fR，则 \fIargument\fR 操作数将被视为字符串。否则，将作为 C 常量计算（如 ISO C 标准所述），并具有以下扩展： 
.RS +4
.TP
.ie t \(bu
.el o
允许前导加号或减号。
.RE
.RS +4
.TP
.ie t \(bu
.el o
如果前导字符为单引号或双引号，值为单引号或双引号后的字符底层代码集中的数值。
.RE
如果不能将参数操作数完全转换为对应于相应转换规范的内部值，诊断消息将被写入标准错误，实用程序退出时不会返回零退出状态，但会继续处理所有剩余操作数，并将检测到错误时累积的值写入到标准输出。
.RE

.SS "ksh"
.sp
.LP
\fIformat\fR 操作数支持全范围 ANSI C/C99/XPG6 格式设置说明符及其他说明符：
.sp
.ne 2
.mk
.na
\fB\fB%b\fR\fR
.ad
.RS 6n
.rt  
特别处理字符串操作数中的每个字符，如下所示：
.sp
.ne 2
.mk
.na
\fB\fB\a\fR\fR
.ad
.RS 7n
.rt  
警报字符。
.RE

.sp
.ne 2
.mk
.na
\fB\fB\b\fR\fR
.ad
.RS 7n
.rt  
退格符。
.RE

.sp
.ne 2
.mk
.na
\fB\fB\c\fR\fR
.ad
.RS 7n
.rt  
终止输出并且不附加换行。忽略其余字符串操作数。
.RE

.sp
.ne 2
.mk
.na
\fB\fB\E\fR\fR
.ad
.RS 7n
.rt  
转义字符（\fBASCII\fR 八进制值 \fB033\fR）。
.RE

.sp
.ne 2
.mk
.na
\fB\fB\f\fR\fR
.ad
.RS 7n
.rt  
换页符。
.RE

.sp
.ne 2
.mk
.na
\fB\fB\n\fR\fR
.ad
.RS 7n
.rt  
换行符。
.RE

.sp
.ne 2
.mk
.na
\fB\fB\t\fR\fR
.ad
.RS 7n
.rt  
制表符。
.RE

.sp
.ne 2
.mk
.na
\fB\fB\v\fR\fR
.ad
.RS 7n
.rt  
垂直制表符。
.RE

.sp
.ne 2
.mk
.na
\fB\fB\\\fR\fR
.ad
.RS 7n
.rt  
反斜杠字符。
.RE

.sp
.ne 2
.mk
.na
\fB\fB\0\fR\fIx\fR\fR
.ad
.RS 7n
.rt  
8 位字符，其 \fBASCII\fR 代码为 \fB1\fR、\fB2\fR 或\fB3\fR 位数八进制数字 \fIx\fR。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fB%B\fR\fR
.ad
.RS 6n
.rt  
将参数视为变量名称并输出值（无需将其转换为字符串）。这对于 \fB-b\fR 类型的变量非常有用。
.RE

.sp
.ne 2
.mk
.na
\fB\fB%H\fR\fR
.ad
.RS 6n
.rt  
带有 \fB<\fR、\fB&\fR、\fB>\fR、\fB"\fR 字符和不可输出字符的输出字符串（正确转义以便在 HTML 和 XML 文档中使用）。
.RE

.sp
.ne 2
.mk
.na
\fB\fB%P\fR\fR
.ad
.RS 6n
.rt  
将 \fIstring\fR 视为扩展正则表达式并将其转换为 shell 模式。
.RE

.sp
.ne 2
.mk
.na
\fB\fB%q\fR\fR
.ad
.RS 6n
.rt  
输出 \fIstring\fR 以特定的方式用引号引起，以便 shell 读取并返回相同的字符串。但是，因缺少字符串操作数导致的空字符串则不会用引号引起。
.RE

.sp
.ne 2
.mk
.na
\fB\fB%R\fR\fR
.ad
.RS 6n
.rt  
将 \fIstring\fR 视为 shell 模式表达式并将其转换为扩展正则表达式。
.RE

.sp
.ne 2
.mk
.na
\fB\fB%T\fR\fR
.ad
.RS 6n
.rt  
将 \fIstring\fR 视为日期/时间字符串并为其设置格式。\fBT\fR 前面可带有 (\fIdformat\fR)，其中 \fIdformat\fR 是日期格式（如 \fBdate\fR(1) 命令所定义）。
.RE

.sp
.ne 2
.mk
.na
\fB\fB%Z\fR\fR
.ad
.RS 6n
.rt  
输出值为 \fB0\fR 的字节。
.RE

.sp
.LP
执行 \fIstring\fR 转换以满足数字格式说明符的要求时，如果 \fIstring\fR 的第一个字符为 \fB"or'\fR，则该值是 \fB"or'\fR 后的字符的底层代码集中的数值。否则，将 \fIstring\fR 与 shell 算术表达式一样对待并进行计算。
.sp
.LP
如果无法将 \fIstring\fR 操作数完全转换为适用于该格式说明符的值，将发生错误，但仍将继续处理剩余的 \fIstring\fR 操作数。
.sp
.LP
除格式说明符扩展外，格式说明符中允许以下 ANSI C/C99/XPG6 扩展：
.RS +4
.TP
.ie t \(bu
.el o
转义序列 \fB\E\fR 和 \fB\e\fR 扩展为转移字符（在 ASCII 中为八进制 033）。
.RE
.RS +4
.TP
.ie t \(bu
.el o
转义序列 \fB\cx\fR 扩展为 CTRL-x。
.RE
.RS +4
.TP
.ie t \(bu
.el o
转义序列 \fB\C[.\fR\fIname\fR\fB\&.]\fR 扩展为整理元素 \fIname\fR。
.RE
.RS +4
.TP
.ie t \(bu
.el o
转义序列 \fB\x{hex}\fR 扩展为十六进制值 \fBhex\fR 对应的字符。
.RE
.RS +4
.TP
.ie t \(bu
.el o
格式修饰符标志 = 可用于将字段居中为指定的宽度。输出为终端时，使用该字符宽度而非字节数。
.RE
.RS +4
.TP
.ie t \(bu
.el o
每个整数格式说明符还可包含第三个修饰符（在宽度和精度之后），用于将转换基数指定为 2 到 64 之间。在这种情况下，可通过 \fB#\fR 修饰符将 \fIbase\fR\fB#\fR 附加到值的前面。
.RE
.RS +4
.TP
.ie t \(bu
.el o
\fB#\fR 修饰符可在未指定基数的情况下与 \fBd\fR 说明符一起使用，从而以 1000 为单位（带有其中一个 \fBk M G T P E\fR 的后缀）写入输出。
.RE
.RS +4
.TP
.ie t \(bu
.el o
\fB#\fR 修饰符可与 \fBi\fR 说明符一起使用，从而以 \fB1024\fR 为单位（带有其中一个 \fBKi Mi Gi Ti Pi Ei\fR 的后缀）写入输出。
.RE
.sp
.LP
如果 \fIstring\fR 操作数超过格式说明符，则将从头开始重新处理格式字符串。如果 \fIstring\fR 操作数少于格式说明符，则按照提供空字符串的方式处理 \fIstring\fR 说明符、按照提供 \fB0\fR 的方式处理数字转换，并按照提供 \fBnow\fR 的方式处理时间转换。
.sp
.LP
\fB/usr/bin/printf\fR 等效于 \fBksh\fR 的 \fBprintf\fR 内置和 \fBprint -f\fR，允许指定其他选项。
.SH 用法
.SS "/usr/bin/printf"
.sp
.LP
\fBprintf\fR 实用程序（如其所基于的 \fBprintf\fR(3C) 函数）未针对使用 \fB%c\fR 转换规范时处理多字节字符设置任何特殊规定。字符集中包含多字节字符时，应用程序在使用上述任一功能时应极端谨慎。
.sp
.LP
不能将字段宽度和精度指定为 \fB*\fR。
.sp
.LP
\fB%b\fR 转换规范不是 ISO C 标准的一部分；此处已将其添加为可移植方式用来处理 \fBecho\fR 实用程序所提供的字符串操作数中扩展的反斜杠转义。另请参见 \fBecho\fR(1) 手册页的“用法”部分，了解使用 \fBprintf\fR 替换所有传统版本的 \fBecho\fR 实用程序的方式。
.sp
.LP
如果不能正确解析对应转换规范的参数，\fBprintf\fR 实用程序会报告错误。因此，用于执行数字转换的参数末尾的溢出和多余字符将报告为错误。
.sp
.LP
如果未完全使用参数操作数执行 \fBc\fR 或 \fBs\fR 转换，或使用字符串操作数的第一个或第二个字符获取字符数值，则不会视为错误。
.SH 示例
.SS "\fB/usr/bin/printf\fR 示例"
.LP
\fB示例 1 \fR列显一系列提示
.sp
.LP
以下示例向用户发出警报，然后输出并读取一系列提示：

.sp
.in +2
.nf
example% \fBprintf "\eaPlease fill in the following: \enName: "
read name
printf "Phone number: "
read phone\fR
.fi
.in -2
.sp

.LP
\fB示例 2 \fR列显计算表
.sp
.LP
以下示例输出计算表。从文件中读出正确和错误答复列表，正确计算百分比并将其输出。向右调整数字并以单个制表符分隔数字。百分比将写入某个精度小数位：

.sp
.in +2
.nf
example% \fBwhile read right wrong ; do
   percent=$(echo "scale=1;($right*100)/($right+$wrong)" | bc)
   printf "%2d right\et%2d wrong\et(%s%%)\en" \e
	   $right $wrong $percent
done < database_file\fR
.fi
.in -2
.sp

.LP
\fB示例 3 \fR列显数字字符串
.sp
.LP
此命令：

.sp
.in +2
.nf
example% \fBprintf "%5d%4d\en" 1 21 321 4321 54321\fR
.fi
.in -2
.sp

.sp
.LP
生成：

.sp
.in +2
.nf
    1  21
  3214321
54321   0
.fi
.in -2
.sp

.sp
.LP
使用三次 \fIformat\fR 操作数以输出所有给定字符串，\fBprintf\fR 还提供了 \fB0\fR 以满足最后一个 \fB%4d\fR 转换规范的要求。

.LP
\fB示例 4 \fR将转换错误制成表格
.sp
.LP
以下示例将转换错误制成表格。 

.sp
.LP
\fBprintf\fR 实用程序会在生成数字输出过程中检测到转换错误时通知用户。指定 \fB%d\fR 作为 \fIformat\fR 操作数时，通过 32 位二进制补码整数实现时将提供以下结果：

.sp

.sp
.TS
tab() box;
cw(1.27i) cw(1.27i) cw(2.96i) 
lw(1.27i) lw(1.27i) lw(2.96i) 
.
参数标准诊断
5a5printf：5a 未完全转换
99999999992147483647printf：9999999999：结果过大 
-9999999999-2147483648printf：-9999999999：结果过大 
ABC0printf：ABC 应当采用数值
.TE

.sp
.LP
标准输出显示的值将作为函数 \fBstrtol\fR(3C) 的返回值提供。\fB%u\fR 与 \fBstrtoul\fR(3C) 以及 \fB%e\fR、\fB%f\fR 和 \fB%g\fR 与 \fBstrtod\fR(3C) 之间存在类似的对应关系。

.LP
\fB示例 5 \fR列显特定语言环境的输出
.sp
.LP
以下示例输出特定语言环境的输出。在语言环境中，使用 ISO/IEC 646:1991 标准作为底层代码集，命令：

.sp
.in +2
.nf
example% \fBprintf "%d\en" 3 +3 -3 \e'3 \e"+3 "'-3"\fR
.fi
.in -2
.sp

.sp
.LP
生成：

.sp

.sp
.TS
tab() box;
lw(.5i) lw(5i) 
lw(.5i) lw(5i) 
.
\fB3\fR常量 3 的数值
\fB3\fR常量 3 的数值
\fB-3\fR常量 -3 的数值
\fB51\fRT{
ISO/IEC 646:1991 标准代码集中的字符 '3' 的数值
T}
\fB43\fRT{
ISO/IEC 646:1991 标准代码集中的字符 '+' 的数值
T}
\fB45\fRT{
SO/IEC 646:1991 标准代码集中的字符 '-' 的数值
T}
.TE

.sp
.LP
在带有多字节字符的语言环境中，字符的值将作为与该字符的 \fBwchar_t\fR 表示形式等效的值。

.sp
.LP
如果不能将参数操作数完全转换为对应于相应转换规范的内部值，诊断消息将被写入标准错误，实用程序退出时会返回零退出状态，但会继续处理所有剩余操作数，并将检测到错误时累积的值写入到标准输出。

.SS "\fBksh\fR 示例"
.sp
.LP
以下示例说明如何使用 \fBksh93\fR 版本的 \fBprintf\fR。
.LP
\fB示例 6 \fR备用浮点表示法 1
.sp
.LP
\fBprintf\fR 实用程序支持备用浮点表示法（有关 "\fB%a\fR"/"\fB%A\fR"，请参见 \fBprintf\fR(3C) 条目），从而以特定的格式输出浮点值，避免由常规 base16 到 base10 的舍入误差。

.sp
.in +2
.nf
example% printf "%a\en" 2 3.1 NaN
.fi
.in -2
.sp

.sp
.LP
生成：

.sp
.in +2
.nf
0x1.0000000000000000000000000000p+01
0x1.8ccccccccccccccccccccccccccdp+01
nan
.fi
.in -2
.sp

.LP
\fB示例 7 \fR备用浮点表示法 2
.sp
.LP
以下示例显示相同浮点值的两种不同表示法。

.sp
.in +2
.nf
example% x=2 ; printf "%f == %a\en" x x
.fi
.in -2
.sp

.sp
.LP
生成：

.sp
.in +2
.nf
2.000000 == 0x1.0000000000000000000000000000p+01
.fi
.in -2
.sp

.LP
\fB示例 8 \fRUnicode 值的输出
.sp
.LP
以下命令将输出 EURO Unicode 符号（代码点 0x20ac）。

.sp
.in +2
.nf
example% LC_ALL=en_US.UTF-8 printf "\eu[20ac]\en"
.fi
.in -2
.sp

.sp
.LP
生成：

.sp
.in +2
.nf
<euro>
.fi
.in -2
.sp

.sp
.LP
其中 \fB<euro>\fR 表示 EURO 货币符号字符。

.LP
\fB示例 9 \fR将 Unicode 字符转换为 Unicode 代码点值
.sp
.LP
以下命令将输出给定字符的十六进制值。

.sp
.in +2
.nf
example% export LC_ALL=en_US.UTF-8
example% printf "%x\en" "'<euro>"
.fi
.in -2
.sp

.sp
.LP
其中 \fB<euro>\fR 表示 EURO 货币符号字符（代码点 0x20ac）。

.sp
.LP
生成：

.sp
.in +2
.nf
20ac
.fi
.in -2
.sp

.LP
\fB示例 10 \fR列显 ASCII 字符的数值
.sp
.in +2
.nf
example% printf "%d\en" "'A"
.fi
.in -2
.sp

.sp
.LP
生成：

.sp
.in +2
.nf
65
.fi
.in -2
.sp

.LP
\fB示例 11 \fR列显独立于语言的日期和时间格式
.sp
.LP
要输出独立于语言的日期和时间格式，可以使用以下语句：

.sp
.in +2
.nf
example% printf "format" weekday month day hour min
.fi
.in -2
.sp

.sp
.LP
例如，

.sp
.in +2
.nf
$ printf format "Sunday" "July" 3 10 2
.fi
.in -2
.sp

.sp
.LP
对于美国使用，格式可为以下字符串：

.sp
.in +2
.nf
"%s, %s %d, %d:%.2d\en"
.fi
.in -2
.sp

.sp
.LP
生成消息：

.sp
.in +2
.nf
Sunday, July 3, 10:02
.fi
.in -2
.sp

.sp
.LP
而对于欧盟使用，格式可为以下字符串：

.sp
.in +2
.nf
"%1$s, %3$d. %2$s, %4$d:%5$.2d\en"
.fi
.in -2
.sp

.sp
.LP
请注意，必须正确转义 '$' 字符，如

.sp
.in +2
.nf
"%1\e$s, %3\e$d. %2\e$s, %4\e$d:%5\e$.2d\en" in this case
.fi
.in -2
.sp

.sp
.LP
生成消息：

.sp
.in +2
.nf
Sunday, 3. July, 10:02
.fi
.in -2
.sp

.SH 环境变量
.sp
.LP
有关影响 \fBprintf\fR 执行的以下环境变量的说明，请参见 \fBenviron\fR(5)：\fBLANG\fR、\fBLC_ALL\fR、\fBLC_CTYPE\fR、\fBLC_MESSAGES\fR、\fBLC_NUMERIC\fR 和 \fBNLSPATH\fR。
.SH 退出状态
.sp
.LP
将返回以下退出值：
.sp
.ne 2
.mk
.na
\fB\fB0\fR\fR
.ad
.RS 6n
.rt  
成功完成。
.RE

.sp
.ne 2
.mk
.na
\fB\fB>0\fR\fR
.ad
.RS 6n
.rt  
出现错误。
.RE

.SH 属性
.sp
.LP
有关下列属性的说明，请参见 \fBattributes\fR(5)：
.SS "/usr/bin/printf"
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
属性类型属性值
_
可用性text/locale
_
CSIEnabled（已启用）
_
接口稳定性Committed（已确定）
_
标准请参见 \fBstandards\fR(5)。
.TE

.SS "ksh"
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
属性类型属性值
_
可用性system/core-os
_
接口稳定性Uncommitted（未确定）
.TE

.SH 另请参见
.sp
.LP
\fBawk\fR(1)、\fBbc\fR(1)、\fBdate\fR(1)、\fBecho\fR(1)、\fBksh\fR(1)、\fBprintf\fR(3C)、\fBstrtod\fR(3C)、\fBstrtol\fR(3C)、\fBstrtoul\fR(3C)、\fBattributes\fR(5)、\fBenviron\fR(5)、\fBformats\fR(5)、\fBstandards\fR(5)
.SH 附注
.sp
.LP
使用未在 \fBprintf\fR(3C) 或此手册页中列出的格式说明符（'%' 后的字符），将会导致行为不确定。
.sp
.LP
使用未在 \fBprintf\fR(3C) 或此手册页中列出的转义序列（反斜杠 ('\') 后的字符），将会导致行为不确定。
.sp
.LP
浮点值遵循 C99、XPG6 和 IEEE 754 标准行为，并可采用与平台的 |\fBlong double\fR| 数据类型相同的方式处理值。
.sp
.LP
浮点值单独处理符号，从而允许对值使用符号，如 NaN（例如 -nan）、Infinite（例如 -inf）和零（例如 -0.0）。
