'\" te
.\" Copyright (c) 1992, Sun Microsystems, Inc.
.TH xstr 1 "1992 年 9 月 14 日" "SunOS 5.11" "用户命令"
.SH 名称
xstr \- 从 C 程序提取字符串以实现共享字符串
.SH 用法概要
.LP
.nf
\fBxstr\fR \fB-c\fR \fIfilename\fR [\fB-v\fR] [\fB-l\fR \fIarray\fR]
.fi

.LP
.nf
\fBxstr\fR [\fB-l\fR \fIarray\fR]
.fi

.LP
.nf
\fBxstr\fR \fIfilename\fR [\fB-v\fR] [\fB-l\fR \fIarray\fR]
.fi

.SH 描述
.sp
.LP
\fBxstr\fR 维护名为 \fBstrings\fR 的文件，大型程序组件部分中的字符串会散列至该文件。将使用通用区域的引用来替换这些字符串。这将用于实现共享的常量字符串，如果字符串同时为只读状态，则作用最大。
.sp
.LP
此命令：
.sp
.in +2
.nf
\fBexample% xstr \(mic\fR \fIfilename\fR
.fi
.in -2
.sp

.sp
.LP
提取指定 C 源中的字符串，通过 \fB&xstr[\fR\fInumber\fR\fB]\fR 格式的表达式替换一定数量的字符串引用。文件前会附加相应的 \fBxstr\fR 声明。会将生成的 C 文本置于文件 \fBx.c\fR 中，然后编译该文件。如果 \fBstrings\fR 数据库尚不包含来自此文件的字符串，则会将字符串置于该数据库中。如果字符串重复，或者字符串是现有字符串的后缀，则数据库不会发生任何变化。
.sp
.LP
编译了大型程序中的所有组件后，可通过以下格式的命令创建声明通用 \fBxstr\fR 空间（名为 \fBxs.c\fR）的文件：
.sp
.in +2
.nf
\fBexample%\fR \fBxstr\fR
.fi
.in -2
.sp

.sp
.LP
随后应该使用剩余程序编译并装入 \fBxs.c\fR 文件。如果可能，可以将数组设置为只读（共享）以节约空间和交换开销。
.sp
.LP
\fBxstr\fR 也可用于单个文件。命令：
.sp
.LP
\fBexample% xstr\fR \fIfilename\fR
.sp
.LP
可像之前那样创建文件 \fBx.c\fR 和 \fBxs.c\fR，不会使用或影响相同目录中的任何 \fBstrings\fR 文件。
.sp
.LP
如果有任何宏定义会生成字符串，或者有条件代码包含实际上不需要的字符串，则在 C 预处理程序之后运行 \fBxstr\fR 可能非常有用。如果提供了 "\fB-\fR" 参数，则 \fBxstr\fR 会从标准输入中进行读取。在 C 预处理程序之后运行 \fBxstr\fR 的合适命令序列为：
.sp
.in +2
.nf
example% cc \(miE name.c | xstr \(mic \(mi
example% cc \(mic x.c
example% mv x.o name.o
.fi
.in -2
.sp

.sp
.LP
除非添加了新条目，否则 \fBxstr\fR 不会触动文件 \fBstrings\fR；因此 \fBmake\fR(1S) 可避免重新生成 \fBxs.o\fR，除非确实需要。
.SH 选项
.sp
.ne 2
.mk
.na
\fB\fB-c\fR \fIfilename\fR\fR
.ad
.RS 15n
.rt  
从 \fIfilename\fR 中获取 C 源。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-v\fR\fR
.ad
.RS 15n
.rt  
详细模式：显示可指示新字符串或重复字符串发现位置的进度报告。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-l\fR \fIarray\fR\fR
.ad
.RS 15n
.rt  
指定程序引用中指定的 \fIarray\fR 提取字符串。缺省数组名称为 \fBxstr\fR。
.RE

.SH 文件
.sp
.ne 2
.mk
.na
\fB\fBstrings\fR\fR
.ad
.RS 12n
.rt  
字符串的数据库
.RE

.sp
.ne 2
.mk
.na
\fB\fBx.c\fR\fR
.ad
.RS 12n
.rt  
消息 C 源
.RE

.sp
.ne 2
.mk
.na
\fB\fBxs.c\fR\fR
.ad
.RS 12n
.rt  
数组 "xstr*(rq 定义的 C 源
.RE

.sp
.ne 2
.mk
.na
\fB\fB/tmp/xs*\fR\fR
.ad
.RS 12n
.rt  
\fBxstr\fR \fIfilename\fR 不触动 \fBstrings\fR 时的临时文件
.RE

.SH 属性
.sp
.LP
有关下列属性的说明，请参见 \fBattributes\fR(5)：
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
属性类型属性值
_
可用性system/core-os
.TE

.SH 另请参见
.sp
.LP
\fBmake\fR(1S)、\fBattributes\fR(5)
.SH 已知问题
.sp
.LP
如果字符串是数据库中另一个字符串的后缀，但 \fBxstr\fR 首先看见更短的字符串，那么会将两个字符串都置于数据库中，但实际只需将更长的字符串置于其中即可。
.SH 附注
.sp
.LP
请注意，\fBxstr\fR 会随意替换具有 \fB&xstr[\fR\fInumber\fR\fB]\fR 格式表达式的所有字符串，不管原始 C 代码以前使用该字符串的方式。例如，代码使用 \fBsizeof()\fR 来确定文本字符串的长度时，可能产生问题，因为 \fBxstr\fR 很可能会使用与字符串大小不同的指针来替换文本字符串。
.sp
.LP
要绕开此问题，您可以：
.RS +4
.TP
.ie t \(bu
.el o
使用 \fBstrlen()\fR 代替 \fBsizeof()\fR；请注意，\fBsizeof()\fR 会返回数组的大小（包括末尾的空字节），而 \fBstrlen()\fR 不会对空字节计数。\fB(strlen("\fR\fIxxx\fR\fB"))+1\fR 与 \fBsizeof("\fR\fI xxx\fR\fB")\fR 等效。
.RE
.RS +4
.TP
.ie t \(bu
.el o
为 \fBsizeof()\fR 操作数使用 \fB#define\fR 并使用经过 \fBdefine\fR 的版本。\fBxstr\fR 会忽略 \fB#define\fR 语句。请确保首先在 \fIfilename\fR 上运行 \fBxstr\fR，然后再在预处理程序上运行。
.RE
.sp
.LP
声明以下格式的初始化字符串数组时，您可能会遇到问题
.sp
.in +2
.nf
\fBchar x[] = "\fR\fIxxx\fR\fB";\fR
.fi
.in -2
.sp

.sp
.LP
\fBxstr\fR 将使用不会编译的 \fB&xstr[\fR\fInumber\fR\fB]\fR 格式的表达式来替换 \fIxxx\fR。要绕过此问题，请使用 \fBstatic char *x = "xxx"\fR 代替 \fBstatic char x[] = "xxx"\fR。
