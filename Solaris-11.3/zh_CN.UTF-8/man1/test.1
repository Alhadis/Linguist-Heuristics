'\" te
.\" Copyright (c) 2009, 2011, Oracle and/or its affiliates.All rights reserved.
.\" Copyright 1992, X/Open Company Limited All Rights Reserved
.\" Copyright 1989 AT&T
.\" Portions Copyright (c) 1982-2007 AT&T Knowledge Ventures
.\" Sun Microsystems, Inc. gratefully acknowledges The Open Group for permission to reproduce portions of its copyrighted documentation.Original documentation from The Open Group can be obtained online at http://www.opengroup.org/bookstore/.
.\" The Institute of Electrical and Electronics Engineers and The Open Group, have given us permission to reprint portions of their documentation.In the following statement, the phrase "this text" refers to portions of the system documentation.Portions of this text are reprinted and reproduced in electronic form in the Sun OS Reference Manual, from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group Base Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group.In the event of any discrepancy between these versions and the original IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.The original Standard can be obtained online at http://www.opengroup.org/unix/online.html.This notice shall appear on any product containing this material. 
.TH test 1 "2011 年 7 月 12 日" "SunOS 5.11" "用户命令"
.SH 名称
test \- 评估条件
.SH 用法概要
.LP
.nf
\fB/usr/bin/test\fR [\fIcondition\fR]
.fi

.LP
.nf
\fB[\fR [\fIcondition\fR] ]
.fi

.SS "sh"
.LP
.nf
\fBtest\fR [\fIcondition\fR]
.fi

.LP
.nf
\fB[\fR [\fIcondition\fR] ]
.fi

.SS "csh"
.LP
.nf
\fBtest\fR [\fIcondition\fR]
.fi

.LP
.nf
\fB[\fR [\fIcondition\fR] ]
.fi

.SS "ksh88"
.LP
.nf
\fBtest\fR [\fIcondition\fR]
.fi

.LP
.nf
\fB[\fR [\fIcondition\fR] ]
.fi

.SS "ksh"
.LP
.nf
\fBtest\fR [\fIcondition\fR]
.fi

.LP
.nf
\fB[\fR [\fIcondition\fR] ]
.fi

.SH 描述
.sp
.LP
\fBtest\fR 实用程序可评估 \fIcondition\fR 并通过其退出状态表明评估结果。退出状态为零表明条件评估为 true，退出状态为 1 表明条件评估为 false。
.sp
.LP
在“用法概要”部分所示实用程序的第一种格式中：
.sp
.in +2
.nf
test [\fIcondition\fR]
.fi
.in -2
.sp

.sp
.LP
方括号表示 \fIcondition\fR 是可选操作数，不会在命令行中输入。
.sp
.LP
在“用法概要”部分所示实用程序的第二种格式中：
.sp
.in +2
.nf
\fB[\fR [ \fIcondition\fR ] \fB]\fR
.fi
.in -2
.sp

.sp
.LP
第一个左方括号 \fB[\fR 是必需的实用程序名称。内部的一对方括号表示 \fIcondition\fR 是可选内容。最后一个右方括号 \fB]\fR 是必需的操作数。
.sp
.LP
有关 \fBtest\fR 遇到大于或等于 2 GB（2^31 字节）文件时行为的说明，请参见 \fBlargefile\fR(5)。
.sp
.LP
\fBtest\fR 和 \fB[\fR 实用程序将评估条件 \fIcondition\fR，如果其值为 true，会将退出状态设置为 \fB0\fR。否则，将设置非零 (false) 退出状态。如果未指定参数，则 \fBtest\fR 和 \fB[\fR 也会设置非零退出状态。测试权限时，将使用进程的有效用户 \fBID\fR。
.sp
.LP
所有运算符、标志和括号（括号的用法如“用法概要”部分最后一行所示）必须是这些命令的单独参数。通常，这些参数以空格分隔。
.SH 操作数
.sp
.LP
包含两个元素的采用以下格式的基元：
.sp
.in +2
.nf
\fI-primary_operator primary_operand\fR
.fi
.in -2

.sp
.LP
称为\fB一元基元\fR。包含三个元素的采用以下两种格式中任意一种的基元：
.sp
.in +2
.nf
\fIprimary_operand -primary_operator primary_operand\fR
\fIprimary_operand primary_operator primary_operand\fR
.fi
.in -2

.sp
.LP
称为\fB二元基元\fR。
.sp
.LP
如果除 \fB-h\fR 和 \fB-L\fR 基元之外的任何文件操作数指的是符号链接，则会扩展符号链接，并对生成的文件执行测试。
.sp
.LP
如果测试拥有的文件（\fB-r\fR \fB-w\fR 或 \fB-x\fR 测试），但是测试的权限未设置 \fIowner\fR 位，则即使文件可以设置该权限的 \fBgroup\fR 或 \fBother\fR 位，也会返回非零 (false) 退出状态。
.sp
.LP
\fB=\fR 和 \fB!=\fR 基元的优先级高于一元基元。\fB=\fR 和 \fB!=\fR 基元始终需要参数；因此，\fB=\fR 和 \fB!=\fR 不能用作一元基元的参数。
.sp
.LP
可以使用以下基元构造 \fIcondition\fR：
.sp
.ne 2
.mk
.na
\fB\fB-a\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile\fR 存在）。（\fBsh\fR 中未提供。）
.RE

.sp
.ne 2
.mk
.na
\fB\fB-b\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile\fR 存在且为块特殊文件）。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-c\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile\fR 存在且为字符特殊文件）。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-d\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile\fR 存在且为目录）。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-e\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile\fR 存在）。（\fBsh\fR 中未提供。）
.RE

.sp
.ne 2
.mk
.na
\fB\fB-f\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile\fR 存在且为正规文件）。或者，\fB/usr/bin/sh\fR 用户在 \fBPATH\fR 环境变量中先指定 \fB/usr/ucb\fR 再指定 \fB/usr/bin\fR 时，如果 \fIfile\fR 存在且为 (\fBnot-a-directory\fR)，\fBtest\fR 将返回 true。\fBcsh\fR \fBtest\fR 和 \fB[\fR 内置命令始终采用这种备用行为。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-g\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile\fR 存在且设置了其 set-group-\fBID\fR 标志）。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-G\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile\fR 存在且其组与该进程的有效组 \fBID\fR 匹配）。（\fBsh\fR 中未提供。）
.RE

.sp
.ne 2
.mk
.na
\fB\fB-h\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile\fR 存在且为符号链接）。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-k\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile\fR 存在且设置了其 sticky 位）。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-L\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile\fR 存在且为符号链接）。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-n\fR \fIstring\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIstring\fR 的长度为非零值）。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-o\fR \fIoption\fR\fR
.ad
.RS 28n
.rt  
True（如果已启用名为 \fIoption\fR 的选项）。\fBcsh\fR 和 \fBsh\fR 中未提供该选项。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-O\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile\fR 存在且归该进程的有效用户 \fBID\fR 所有）。\fBsh\fR 中未提供该选项。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-p\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile\fR 是指定管道 (\fBFIFO\fR)）。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-r\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile\fR 存在且可读）。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-s\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile\fR 存在且其大小大于零）。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-S\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile\fR 存在且为套接字）。\fBsh\fR 中未提供该选项。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-t\fR [\fIfile_descriptor\fR]\fR
.ad
.RS 28n
.rt  
True（如果文件描述符编号为 \fIfile_descriptor\fR 的文件已打开且与终端相关联）。如果未指定 \fIfile_descriptor\fR，则将 \fB1\fR 用作缺省值。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-u\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile\fR 存在且设置了其 set-user-ID 标志）。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-w\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile\fR 存在且可写）。True 只表示启用了写入标志。即使该测试表明 true，\fIfile\fR 也无法在只读文件系统上写入。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-x\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile\fR 存在且可执行）。True 只表示启用了执行标志。如果 \fIfile\fR 是目录，true 表示可以搜索 \fIfile\fR。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-z\fR \fIstring\fR\fR
.ad
.RS 28n
.rt  
True（如果字符串 \fIstring\fR 的长度为零）。
.RE

.sp
.ne 2
.mk
.na
\fB\fIfile1\fR \fB-nt\fR \fIfile2\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile1\fR 存在且比 \fIfile2\fR 更新）。\fBsh\fR 中未提供该选项。
.RE

.sp
.ne 2
.mk
.na
\fB\fIfile1\fR \fB-ot\fR \fIfile2\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile1\fR 存在且比 \fIfile2\fR 更旧）。\fBsh\fR 中未提供该选项。
.RE

.sp
.ne 2
.mk
.na
\fB\fIfile1\fR \fB-ef\fR \fIfile2\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIfile1\fR 和 \fIfile2\fR 存在且指的是同一文件）。\fBsh\fR 中未提供该选项。
.RE

.sp
.ne 2
.mk
.na
\fB\fIstring\fR\fR
.ad
.RS 28n
.rt  
True（如果字符串 \fIstring\fR 不是 null 字符串）。
.RE

.sp
.ne 2
.mk
.na
\fB\fIstring1\fR \fB=\fR \fIstring2\fR\fR
.ad
.RS 28n
.rt  
True（如果字符串 \fIstring1\fR 和 \fIstring2\fR 相同）。
.RE

.sp
.ne 2
.mk
.na
\fB\fIstring1\fR \fB!=\fR \fIstring2\fR\fR
.ad
.RS 28n
.rt  
True（如果字符串 \fIstring1\fR 和 \fIstring2\fR 不同）。
.RE

.sp
.ne 2
.mk
.na
\fB\fIn1\fR \fB-eq\fR \fIn2\fR\fR
.ad
.RS 28n
.rt  
True（如果数字 \fIn1\fR 和 \fIn2\fR 代数值相等）。数字可以是 C99/XPG6/SUS 所指定任意格式的整数、浮点或浮点常量（例如 [+/-]Inf、[+/-]NaN）。
.RE

.sp
.ne 2
.mk
.na
\fB\fIn1\fR \fB-ne\fR \fIn2\fR\fR
.ad
.RS 28n
.rt  
True（如果数字 \fIn1\fR 和 \fIn2\fR 代数值不等）。数字可以是 C99/XPG6/SUS 所指定任意格式的整数、浮点或浮点常量（例如 [+/-]Inf、[+/-]NaN）。
.RE

.sp
.ne 2
.mk
.na
\fB\fIn1\fR \fB-gt\fR \fIn2\fR\fR
.ad
.RS 28n
.rt  
True（如果数字 \fIn1\fR 代数值大于数字 \fIn2\fR）。数字可以是 C99/XPG6/SUS 所指定任意格式的整数、浮点或浮点常量（例如 [+/-]Inf、[+/-]NaN）。
.RE

.sp
.ne 2
.mk
.na
\fB\fIn1\fR \fB-ge\fR \fIn2\fR\fR
.ad
.RS 28n
.rt  
True（如果数字 \fIn1\fR 代数值大于或等于数字 \fIn2\fR）。数字可以是 C99/XPG6/SUS 所指定任意格式的整数、浮点或浮点常量（例如 [+/-]Inf、[+/-]NaN）。
.RE

.sp
.ne 2
.mk
.na
\fB\fIn1\fR \fB-lt\fR \fIn2\fR\fR
.ad
.RS 28n
.rt  
True（如果数字 \fIn1\fR 代数值小于数字 \fIn2\fR）。数字可以是 C99/XPG6/SUS 所指定任意格式的整数、浮点或浮点常量（例如 [+/-]Inf、[+/-]NaN）。
.RE

.sp
.ne 2
.mk
.na
\fB\fIn1\fR \fB-le\fR \fIn2\fR\fR
.ad
.RS 28n
.rt  
True（如果数字 \fIn1\fR 代数值小于或等于数字 \fIn2\fR）。数字可以是 C99/XPG6/SUS 所指定任意格式的整数、浮点或浮点常量（例如 [+/-]Inf、[+/-]NaN）。
.RE

.sp
.ne 2
.mk
.na
\fB\fIcondition1\fR \fB-a\fR \fIcondition2\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIcondition1\fR 和 \fIcondition2\fR 均为 true）。\fB-a\fR 二元基元从左向右执行运算，其优先级高于 \fB-o\fR 二元基元。
.RE

.sp
.ne 2
.mk
.na
\fB\fIcondition1\fR \fB-o\fR \fIcondition2\fR\fR
.ad
.RS 28n
.rt  
True（如果 \fIcondition1\fR 或 \fIcondition2\fR 为 true）。\fB-o\fR 二元基元从左向右执行运算。
.RE

.sp
.LP
这些基元可与以下运算符结合使用：
.sp
.ne 2
.mk
.na
\fB\fB!\fR \fIcondition\fR\fR
.ad
.RS 17n
.rt  
True（如果 \fIcondition\fR 为 false）。
.RE

.sp
.ne 2
.mk
.na
\fB( \fIcondition\fR )\fR
.ad
.RS 17n
.rt  
True（如果 condition 为 true）。可以使用括号 ( ) 更改常规优先级和结合性。括号对 shell 有意义，因此必须用引号引起来。
.RE

.sp
.LP
确定运算符优先级的算法和生成的返回值基于提供给 \fBtest\fR 的参数的数目。（但是，采用 \fB[...]\fR 格式时，右括号的最后一个参数并不计入这种算法。）
.sp
.LP
在以下列表中，\fB$1\fR、\fB$2\fR、\fB$3\fR 和 \fB$4\fR 表示作为 \fIcondition\fR、\fIcondition1\fR 或 \fIcondition2\fR 提供给 \fBtest\fR 的参数。
.sp
.ne 2
.mk
.na
\fB\fI0 个参数：\fR\fR
.ad
.RS 18n
.rt  
退出值为 false (1)。
.RE

.sp
.ne 2
.mk
.na
\fB\fI1 个参数：\fR\fR
.ad
.RS 18n
.rt  
退出值为 true (0)（如果 \fB$1\fR 不为空）。否则，退出值为 false。
.RE

.sp
.ne 2
.mk
.na
\fB\fI2 个参数：\fR\fR
.ad
.RS 18n
.rt  
.RS +4
.TP
.ie t \(bu
.el o
\fB$1\fR 为 \fB!\fR 时，如果 \fB$2\fR 为空，退出值为 true；如果 \fB$2\fR 不为空，退出值为 false。
.RE
.RS +4
.TP
.ie t \(bu
.el o
\fB$1\fR 为一元基元时，如果一元测试为 true，退出值为 true；如果一元测试为 false，退出值为 false。
.RE
.RS +4
.TP
.ie t \(bu
.el o
否则，不会产生指定的结果。
.RE
.RE

.sp
.ne 2
.mk
.na
\fB\fI3 个参数：\fR\fR
.ad
.RS 18n
.rt  
.RS +4
.TP
.ie t \(bu
.el o
如果 \fB$2\fR 为二元基元，将执行 \fB$1\fR 和 \fB$3\fR 的二元测试。
.RE
.RS +4
.TP
.ie t \(bu
.el o
如果 \fB$1\fR 为 \fB!\fR，将否定 \fB$2\fR 和 \fB$3\fR 的两个参数的测试。
.RE
.RS +4
.TP
.ie t \(bu
.el o
否则，不会产生指定的结果。
.RE
.RE

.sp
.ne 2
.mk
.na
\fB\fI4 个参数：\fR\fR
.ad
.RS 18n
.rt  
.RS +4
.TP
.ie t \(bu
.el o
如果 \fB$1\fR 为 \fB!\fR，将否定 \fB$2\fR、\fB$3\fR 和 \fB$4\fR 的三个参数的测试。
.RE
.RS +4
.TP
.ie t \(bu
.el o
否则，结果不确定。
.RE
.RE

.SH 用法
.sp
.LP
处理用户提供的输入时，使用脚本应该非常小心，因为输入可能与基元和运算符混淆。除非应用程序编写者了解在脚本中生成输入的所有情况，否则诸如 \fBtest "$1" -a "$2"\fR 之类的调用应写为 \fBtest "$1" && test "$2"\fR，以避免由用户提供值（例如将 \fB$1\fR 设置为 \fB!\fR，将 \fB$2\fR 设置为空字符串）时出现问题。也就是说，如果最高可移植性关系重大，应将 \fBtest expr1 -a expr2\fR 替换为 \fBtest expr1 && test expr2\fR，将 \fBtest expr1 -o expr2\fR 替换为 \fBtest expr1 || test expr2\fR。但请注意，在 \fBtest\fR 中，\fB-a\fR 优先级\fB高于\fR \fB-o\fR，而在 shell 中，\fB&&\fR 和 \fB||\fR 优先级\fB相等\fR。
.sp
.LP
在 shell 命令语言中，可使用圆括号或花括号来影响分组。
.sp
.LP
使用 \fBsh\fR 时，圆括号必须进行转义。例如：
.sp
.in +2
.nf
test \e( expr1 -a expr2 \e) -o expr3
.fi
.in -2

.sp
.LP
该命令并不总是能够移植到符合 XSI 要求的系统以外。在这种情况下，可采用以下格式：
.sp
.in +2
.nf
( test expr1 && test expr2 ) || test expr3
.fi
.in -2

.sp
.LP
以下两个命令：
.sp
.in +2
.nf
test "$1"
test ! "$1"
.fi
.in -2

.sp
.LP
在以前的某些系统上无法可靠地使用。如果使用了此类 \fIstring\fR 条件且 \fB$1\fR 扩展到 \fB!\fR、\fB(\fR 或已知的一元基元，会产生异常结果。更好的结构分别是：
.sp
.in +2
.nf
test -n "$1"
test -z "$1"
.fi
.in -2

.sp
.LP
以前的系统采用以下通用结构，这也导致了不可靠：
.sp
.in +2
.nf
test "$response" = "expected string"
.fi
.in -2

.sp
.LP
以下结构更为可靠：
.sp
.in +2
.nf
test "X$response" = "Xexpected string"
test "expected string" = "$response"
.fi
.in -2

.sp
.LP
第二种格式假定 \fBexpected string\fR 不能与任何一元基元混淆。如果 \fBexpected string\fR 以 \fB-\fR、\fB(\fR、\fB!\fR 或 \fB=\fR 开头，应采用第一种格式。无论输入为何，只要在不带标记扩展的情况下采用前面的规则，这三种比较格式都非常可靠。（但请注意，字符串在所有情况下均用引号引起来。）
.sp
.LP
由于字符串比较二元基元 \fB=\fR 和 \fB!=\fR 优先级高于参数超过 4 个时的任何一元基元，因此如果未妥善准备参数，可能会产生异常结果。例如，在以下命令中：
.sp
.in +2
.nf
test -d $1 -o -d $2
.fi
.in -2

.sp
.LP
如果 \fB$1\fR 评估结果为 \fB=\fR 可能的目录名称，将前三个参数视为字符串比较，这会导致遇到第二个 \fB-d\fR 时出现语法错误。以下格式可以防止该问题，首选第二种：
.sp
.in +2
.nf
test \e( -d "$1" \e) -o \e( -d "$2" \e)
test -d "$1" || test -d "$2"
.fi
.in -2

.sp
.LP
同样，参数超过 4 个时：
.sp
.in +2
.nf
test "$1" = "bat" -a "$2" = "ball"
.fi
.in -2

.sp
.LP
如果 \fB$1\fR 评估结果为 \fB(\fR 或 \fB!\fR，则会出现语法错误。以下格式可以防止该问题，首选第三种：
.sp
.in +2
.nf
test "X$1" = "Xbat" -a "X$2" = "Xball"
test "$1" = "bat" && test "$2" = "ball"
test "X$1" = "Xbat" && test "X$2" = "Xball"
.fi
.in -2

.SH 示例
.sp
.LP
在 \fBif\fR 命令示例中，测试了三个条件，如果三个全部评估为 true 或成功，则会将其有效性写入屏幕。这三项测试包括：
.RS +4
.TP
.ie t \(bu
.el o
设置为 1 的变量是否大于 0
.RE
.RS +4
.TP
.ie t \(bu
.el o
设置为 2 的变量是否等于 2
.RE
.RS +4
.TP
.ie t \(bu
.el o
文本文件 \fB/etc/passwd\fR 中是否包含 \fBroot\fR 一词
.RE
.SS "/usr/bin/test"
.LP
\fB示例 1 \fR使用 /usr/bin/test
.sp
.LP
如果目录不存在，执行 \fBmkdir\fR：

.sp
.in +2
.nf
test ! -d tempdir && mkdir tempdir
.fi
.in -2

.sp
.LP
等到文件变为不可读时：

.sp
.in +2
.nf
while test -r thefile
do
   sleep 30
done
echo'"thefile" is no longer readable'
.fi
.in -2

.sp
.LP
如果参数是以下三个字符串（两种变体）之一，执行命令，使用左方括号版本 \fB[\fR 的 \fBtest\fR 命令执行命令：

.sp
.in +2
.nf
if [ "$1" = "pear" ] || [ "$1" = "grape" ] || [ "$1" = "apple" ]
then
    command
fi
case "$1" in
    pear|grape|apple) command;;
esac
.fi
.in -2

.LP
\fB示例 2 \fR将 /usr/bin/test 用于 -e 选项
.sp
.LP
如果确实希望在 \fBsh\fR 中使用 \fB-e\fR 选项，应按如下方式使用 \fB/usr/bin/test\fR：

.sp
.in +2
.nf
if [ ! -h $PKG_INSTALL_ROOT$rLink ] && /usr/bin/test -e
$PKG_INSTALL_ROOT/usr/bin/$rFile ; then
    ln -s $rFile $PKG_INSTALL_ROOT$rLink
fi
.fi
.in -2

.SS "测试内置命令"
.sp
.LP
\fBtest\fR 内置命令的两种格式遵循 Bourne shell 的 \fBif\fR 示例。
.LP
\fB示例 3 \fR使用 sh 内置命令
.sp
.in +2
.nf
ZERO=0 ONE=1 TWO=2 ROOT=root

if  [ $ONE \fB-gt\fR $ZERO ]

[ $TWO \fB-eq\fR 2 ]

grep $ROOT  /etc/passwd >&1 > /dev/null  \fI# discard output\fR

then

    echo "$ONE is greater than 0, $TWO equals 2, and $ROOT is" \e
          "a user-name in the password file"

else

    echo "At least one of the three test conditions is false"        
fi
.fi
.in -2

.LP
\fB示例 4 \fR使用 test 内置命令
.sp
.LP
\fBtest\fR 内置命令示例如下：

.sp
.in +2
.nf
test \(gagrep $ROOT /etc/passwd >&1 /dev/null\(ga   \fI# discard output\fR 

echo $?    \fI# test for success\fR
[ \(gagrep nosuchname /etc/passwd >&1 /dev/null\(ga ]

echo $?    \fI# test for failure\fR
.fi
.in -2

.SS "csh"
.LP
\fB示例 5 \fR使用 csh 内置命令
.sp
.in +2
.nf
@ ZERO = 0; @ ONE = 1; @ TWO = 2;  set ROOT = root
grep $ROOT  /etc/passwd >&1 /dev/null  \fI# discard output\fR         
    \fI# $status must be tested for immediately following grep\fR 
if ( "$status" == "0" && $ONE > $ZERO && $TWO == 2 ) then
       echo "$ONE is greater than 0, $TWO equals 2, and $ROOT is" \e
             "a user-name in the password file"
 endif
.fi
.in -2

.SS "ksh88"
.LP
\fB示例 6 \fR使用 ksh88/ksh 内置命令
.sp
.in +2
.nf
ZERO=0 ONE=1 TWO=$((ONE+ONE)) ROOT=root         
if  ((ONE > ZERO))            \fI#  arithmetical comparison\fR
 [[ $TWO = 2 ]]                \fI#  string comparison\fR
 [ \(gagrep $ROOT  /etc/passwd >&1 /dev/null\(ga ] \fI# discard output\fR        
then 
     echo "$ONE is greater than 0, $TWO equals 2, and $ROOT is" \e
             "a user-name in the password file"

else
     echo "At least one of the three test conditions is false"
fi
.fi
.in -2

.SH 环境变量
.sp
.LP
有关影响 \fBtest\fR 执行的环境变量 \fBLANG\fR、\fBLC_ALL\fR、\fBLC_CTYPE\fR、\fBLC_MESSAGES\fR 和 \fBNLSPATH\fR 的说明，请参见 \fBenviron\fR(5)。
.SH 退出状态
.sp
.LP
将返回以下退出值：
.sp
.ne 2
.mk
.na
\fB\fB0\fR\fR
.ad
.RS 6n
.rt  
\fIcondition\fR 评估结果为 true。
.RE

.sp
.ne 2
.mk
.na
\fB\fB1\fR\fR
.ad
.RS 6n
.rt  
\fIcondition\fR 评估结果为 false 或缺少 \fIcondition\fR。
.RE

.sp
.ne 2
.mk
.na
\fB\fB>1\fR\fR
.ad
.RS 6n
.rt  
出现错误。
.RE

.SH 属性
.sp
.LP
有关下列属性的说明，请参见 \fBattributes\fR(5)：
.SS "/usr/bin/test、csh、ksh88、sh"
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
属性类型属性值
_
可用性system/core-os
_
接口稳定性Committed（已确定）
_
标准请参见 \fBstandards\fR(5)。
.TE

.SS "ksh"
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
属性类型属性值
_
可用性system/core-os
_
接口稳定性Uncommitted（未确定）
.TE

.SH 另请参见
.sp
.LP
\fBcsh\fR(1)、\fBksh\fR(1)、\fBksh88\fR(1)、\fBsh\fR(1)、\fBtest\fR(1B)、\fBattributes\fR(5)、\fBenviron\fR(5)、\fBlargefile\fR(5)、\fBstandards\fR(5)
.SH 附注
.sp
.LP
\fBnot-a-directory\fR 可以替代 \fB-f\fR 选项，但它只是在过渡期间对 \fBBSD\fR 应用程序起帮助作用，在未来的发行版中可能不再受支持。
.SS "XPG4 \fBsh\fR、\fBksh88\fR、\fBksh\fR"
.sp
.LP
使用算术表达式，例如
.sp
.in +2
.nf
$(( x > 3.1 )) #
.fi
.in -2
.sp

.sp
.LP
而非
.sp
.in +2
.nf
$ /usr/bin/test "$x" -gt 3.1 # )
.fi
.in -2
.sp

.sp
.LP
－在比较两个浮点变量或一个常量和一个浮点变量以防止舍入误差（由 base16 到 base10 的转换造成）影响结果时。此外，XPG4 \fBsh\fR、\fBksh88\fR 和 \fBksh\fR 中支持的内置命令算术速度明显加快，因为无需对每项比较的字符串进行显式转换。
