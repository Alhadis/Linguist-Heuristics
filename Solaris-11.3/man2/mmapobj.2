'\" te
.\" Copyright (c) 2008, 2015, Oracle and/or its affiliates. All rights reserved.
.TH mmapobj 2 "11 Mar 2015" "SunOS 5.11" "System Calls"
.SH NAME
mmapobj \- map a file object
.SH SYNOPSIS
.LP
.nf
#include <sys/mman.h>

\fBint\fR \fBmmapobj\fR(\fBint\fR \fIfd\fR, \fBuint_t\fR \fIflags\fR, \fBmmapobj_result_t *\fR\fIstorage\fR,
     \fBuint_t *\fR\fIelements\fR, \fBvoid *\fR\fIarg\fR);
.fi

.SH PARAMETERS
.sp
.ne 2
.mk
.na
\fB\fIfd\fR\fR
.ad
.RS 12n
.rt  
The open file descriptor of the file to be mapped.
.RE

.sp
.ne 2
.mk
.na
\fB\fIflags\fR\fR
.ad
.RS 12n
.rt  
Modify the default behavior of \fBmmapobj()\fR. The following flags are available.
.sp
.ne 2
.mk
.na
\fB\fBMMOBJ_INTERPRET\fR\fR
.ad
.sp .6
.RS 4n
Interpret the contents of the file descriptor instead of mapping the file as a single image. This flag can only be used with \fBELF\fR files.
.RE

.sp
.ne 2
.mk
.na
\fB\fBMMOBJ_PADDING\fR\fR
.ad
.sp .6
.RS 4n
Add an additional mapping before the lowest mapping and after the highest mapping. The size of each of these padding areas is at least as large as the amount pointed to by \fIarg\fR. These padding areas are private to the process, do not reserve any swap space, and have no protections. To use these padding areas, the protections for the underlying mappings must be changed. See \fBmprotect\fR(2).
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fIstorage\fR\fR
.ad
.RS 12n
.rt  
A pointer to the \fBmmapobj_result_t\fR array where the mapping data is copied out after a successful mapping of \fIfd\fR. A segment is represented by one or more adjacent VM page mappings.
.RE

.sp
.ne 2
.mk
.na
\fB\fIelements\fR\fR
.ad
.RS 12n
.rt  
A pointer to the number of \fBmmapobj_result_t\fR elements pointed to by \fIstorage\fR. On return, \fIelements\fR contains the number of segments required to fully map the requested object. If the original value of \fIelements\fR is too small, \fBE2BIG\fR is returned and \fIelements\fR is modified to contain the number of segments necessary.
.RE

.sp
.ne 2
.mk
.na
\fB\fIarg\fR\fR
.ad
.RS 12n
.rt  
A pointer to additional information that might be associated with the specific request. Only the \fBMMOBJ_PADDING\fR request uses this argument. If \fBMMOBJ_PADDING\fR is not specified, \fIarg\fR must be \fINULL\fR.
.RE

.SH DESCRIPTION
.sp
.LP
The \fBmmapobj()\fR function establishes a set of segment mappings between the address space of a process and a file. One segment is represented by one or more adjacent VM page mappings. On return from \fBmmapobj()\fR, data describing the mapping of the file is copied out to the area defined by \fIstorage\fR and \fIelements\fR.
.sp
.LP
By default, \fBmmapobj()\fR maps the whole file as a single, private, read-only mapping. In this case, only one storage element is required to describe the mapped file.
.sp
.LP
The \fBMMOBJ_INTERPRET\fR flag instructs \fBmmapobj()\fR to attempt to interpret the file and map the file according to the rules for that file format. \fBELF\fR objects define their mapping requirements in terms of segments. Typically, such objects define a \fBtext\fR and \fBdata\fR segment, as defined by the file's program header information. These segments are created from mappings of the file, and can be augmented with mappings that provide zero-filled memory. In this typical case, two storage elements are required to describe the segments of the mapped file.
.sp
.LP
The following \fBELF\fR formats are supported.
.sp
.ne 2
.mk
.na
\fB\fBET_EXEC\fR and \fBAOUT\fR executables\fR
.ad
.sp .6
.RS 4n
This format results in one or more segments whose size, alignment, and protections are as described by the file's program header information. The address of each segment is explicitly defined by the file's program headers.
.RE

.sp
.ne 2
.mk
.na
\fB\fBET_DYN\fR and \fBAOUT\fR shared objects\fR
.ad
.sp .6
.RS 4n
This format results in one or more segments whose size, alignment, and protections are as described by the file's program header information. The base address of the initial segment is chosen by \fBmmapobj()\fR. The addresses of adjacent segments are based off of this base address as defined by the file's program headers.
.RE

.sp
.ne 2
.mk
.na
\fB\fBET_REL\fR and \fBET_CORE\fR\fR
.ad
.sp .6
.RS 4n
This format results in a single, read-only mapping that covers the whole file. The base address of this mapping is chosen by \fBmmapobj()\fR.
.RE

.sp
.LP
The \fBmmapobj()\fR function will not map over any currently used mappings within the process, except for the case of an \fBELF ET_EXEC\fR file for which a previous reservation has been made via \fB/dev/null\fR. The most common way to make such a reservation is an \fBmmap()\fR of \fB/dev/null\fR.
.sp
.LP
Mapped segments created with \fBmmapobj()\fR can be processed individually by other system calls such as \fBmunmap\fR(2). Even if a segment is represented by several underlying VM page mappings, it is possible to process it at once.
.sp
.LP
The \fBmmapobj_result\fR structure contains the following members.
.sp
.in +2
.nf
typedef struct mmapobj_result {
      caddr_t     mr_addr;     /* mapping address */
      size_t      mr_msize;    /* mapping size */
      size_t      mr_fsize;    /* file size */
      size_t      mr_offset;   /* offset into mapping */
      uint_t      mr_prot;     /* protections provided */
      uint_t      mr_flags;    /* info on the mapping */
} mmapobj_result_t;
.fi
.in -2

.sp
.LP
The \fBMR_GET_TYPE\fR() macro must be used to interpret any \fImr_flags\fR. The following \fImr_flags\fR are available.
.sp
.in +2
.nf
MR_PADDING   0x1  /* mapping provides padding */
MR_HDR_ELF   0x2  /* ELF header is mapped at mr_addr */
.fi
.in -2

.sp
.LP
When \fBMR_PADDING\fR is set, \fImr_fsize\fR and \fImr_offset\fR are both 0.
.sp
.LP
The \fImr_fsize\fR member represents the amount of the file that is mapped into memory with this segment.
.sp
.LP
The \fImr_offset\fR member is the offset into the segment where valid data begins.
.sp
.LP
The \fImr_msize\fR member represents the size of the memory segment starting at \fImr_addr\fR. This size may include unused data prior to \fImr_offset\fR. This data can exist to satisfy the alignment requirements of segments within an interpreted \fBELF\fR file. This size may also include any non-file data that is required to provide zero-filled, or \fBNOBITS\fR data (typically \fB\&.bss\fR). The system reserves the right to map more than \fImr_msize\fR bytes of memory but only \fImr_msize\fR bytes is available to the caller of \fBmmapobj()\fR.
.SH RETURN VALUES
.sp
.LP
Upon successful completion, 0 is returned and \fIelements\fR contains the number of valid entries in the \fIstorage\fR array that are required to describe the mapping for \fIfd\fR. The data describing these elements are copied to \fIstorage\fR such that the first \fIelements\fR members of the storage array contain valid segment data.
.sp
.LP
On failure, -1 is returned and \fBerrno\fR is set to indicate the error. No data is copied to storage, however, \fIelements\fR can be updated in some error cases.
.SH ERRORS
.sp
.LP
The \fBmmapobj()\fR function will fail if:
.sp
.ne 2
.mk
.na
\fB\fBE2BIG\fR\fR
.ad
.RS 14n
.rt  
The \fIelements\fR argument is not large enough to describe the number of mappings for \fIfd\fR. The \fIelements\fR argument is modified to contain the number of mappings required.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEACCES\fR\fR
.ad
.RS 14n
.rt  
The file system containing the \fIfd\fR to be mapped does not allow execute access, or the file descriptor pointed to by \fIfd\fR is not open for reading.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEADDRINUSE\fR\fR
.ad
.RS 14n
.rt  
The mapping requirements overlap an object that is already used by the process.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEAGAIN\fR\fR
.ad
.RS 14n
.rt  
There is insufficient room to reserve swap space for the mapping.
.sp
The file to be mapped is already locked using advisory or mandatory record locking. See \fBfcntl\fR(2).
.RE

.sp
.ne 2
.mk
.na
\fB\fBEBADF\fR\fR
.ad
.RS 14n
.rt  
The \fIfd\fR argument is not a valid open file descriptor.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEFAULT\fR\fR
.ad
.RS 14n
.rt  
The \fIstorage\fR, \fIarg\fR, or \fIelements\fR argument points to an invalid address.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 14n
.rt  
The \fIflags\fR argument contains an invalid flag.
.sp
The \fIflags\fR argument does not contain \fBMMOBJ_PADDING\fR and \fIarg\fR is non-null.
.sp
The file to be mapped has a length of 0.
.RE

.sp
.ne 2
.mk
.na
\fB\fBENODEV\fR\fR
.ad
.RS 14n
.rt  
The \fIfd\fR argument refers to an object for which \fBmmapobj()\fR is meaningless, such as a terminal.
.RE

.sp
.ne 2
.mk
.na
\fB\fBENOMEM\fR\fR
.ad
.RS 14n
.rt  
Insufficient memory is available in the address space to create the mapping.
.sp
The \fIflags\fR argument contains \fBMMOBJ_INTERPRET\fR and there is insufficient memory available to hold the program headers for the \fBELF\fR file.
.RE

.sp
.ne 2
.mk
.na
\fB\fBENOTSUP\fR\fR
.ad
.RS 14n
.rt  
The current user data model does not match the \fIfd\fR to be interpreted. For example, a 32-bit process that tried to use \fBmmapobj()\fR to interpret a 64-bit object would return \fBENOTSUP\fR.
.sp
The \fIflags\fR argument contains \fBMMOBJ_INTERPRET\fR and the \fIfd\fR argument is a file whose type can not be interpreted.
.sp
The \fBELF\fR header contains an unaligned \fIe_phentsize\fR value.
.RE

.sp
.ne 2
.mk
.na
\fB\fBENOSYS\fR\fR
.ad
.RS 14n
.rt  
An unsupported file system operation is attempted while trying to map in the object.
.RE

.SH ATTRIBUTES
.sp
.LP
See \fBattributes\fR(5) for descriptions of the following attributes:
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
ATTRIBUTE TYPEATTRIBUTE VALUE
_
Interface StabilityPrivate
_
MT-LevelAsync-Signal-Safe
.TE

.SH SEE ALSO
.sp
.LP
\fBld.so.1\fR(1), \fBfcntl\fR(2), \fBmemcntl\fR(2), \fBmmap\fR(2), \fBmprotect\fR(2), \fBmunmap\fR(2), \fBelf\fR(3ELF), \fBmadvise\fR(3C), \fBmlockall\fR(3C), \fBmsync\fR(3C), \fBa.out\fR(4), \fBproc\fR(4), \fBattributes\fR(5)
.sp
.LP
\fIOracle Solaris 11.3 Linkers and Libraries         Guide\fR
