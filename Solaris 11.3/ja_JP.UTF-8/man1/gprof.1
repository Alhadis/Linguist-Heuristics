'\" te
.\" Copyright 1989 AT&T
.\" Copyright (c) 2007, 2014, Oracle and/or its affiliates.All rights reserved.
.TH gprof 1 "2014 年 4 月 23 日" "SunOS 5.11" "ユーザーコマンド"
.SH 名前
gprof \- コールグラフプロファイルデータの表示
.SH 形式
.LP
.nf
\fBgprof\fR [\fB-abcCDlsz\fR] [\fB-e\fR \fIfunction-name\fR] [\fB-E\fR \fIfunction-name\fR] 
     [\fB-f\fR \fIfunction-name\fR] [\fB-F\fR \fIfunction-name\fR] 
     [\fIimage-file\fR [\fIprofile-file\fR...]] 
     [\fB-n\fR \fInumber of functions\fR]
.fi

.SH 機能説明
.sp
.LP
\fBgprof\fR ユーティリティーは、プログラムの実行プロファイルを生成します。呼び出されたルーチンの結果が、各呼び出し元のプロファイルに取り込まれます。プロファイルデータは、\fBcc\fR(1) の \fB-xpg\fR オプションまたはその他のコンパイラの \fB-pg\fR オプションでコンパイルされたプログラムによって作成されたコールグラフプロファイルファイルから、または共有オブジェクトの \fBLD_PROFILE\fR 環境変数を設定することによって作成されたコールグラフプロファイルファイルから取得されます。\fBld.so.1\fR(1) を参照してください。これらのコンパイラオプションは、プロファイリング用にコンパイルされたライブラリルーチンのバージョンにもリンクされています。実行可能イメージファイル \fIimage-file\fR (デフォルトでは \fBa.out\fR) のシンボルテーブルが読み取られ、コールグラフプロファイルファイル \fIprofile-file\fR (デフォルトでは \fBgmon.out\fR) と関連付けられます。
.sp
.LP
最初に、各ルーチンの実行回数がコールグラフの境界に沿って伝播されます。サイクルが検出され、サイクルの時間を共有するためにサイクルへの呼び出しが行われます。最初のリストには、関数が示す時間 (コールグラフの子孫の時間を含む) に従ってソートされた関数が示されます。各関数エントリの下には、コールグラフの (直接の) 子およびそれらの時間がこの関数に伝播されている状況が示されます。関数の上の同様の表示には、この関数の時間およびその子孫の時間がコールグラフの (直接の) 親に伝播されている状況が示されます。
.sp
.LP
サイクルも表示され、サイクル全体のエントリ、サイクルのメンバーのリスト、時間への寄与、およびサイクルの呼び出し回数が示されます。
.sp
.LP
次に、\fBprof\fR(1) で生成されるプロファイルと同様のフラットプロファイルが生成されます。このリストには、プログラム内の各関数の合計実行時間および呼び出し回数が時間の多い順で示されています。最後に、インデックスが生成されます。これは、関数名とコールグラフプロファイルのインデックス番号の対応を示します。
.sp
.LP
\fBMARK\fR マクロを使用したプロファイリングのために、単一の関数がサブ関数に分割されることがあります。\fBprof\fR(5) を参照してください。
.sp
.LP
量子化エラーに注意してください。標本収集の粒度は示されますが、あくまで統計にすぎません。関数の各実行の時間は、関数の合計時間を関数が呼び出された回数で除算することによって表すことができると想定しています。このため、コールグラフの弧に沿って関数の親に伝播される時間は、弧を遷移した回数に正比例します。
.sp
.LP
プロファイリング情報を \fBgmon.out\fR ファイルに保存するには、プロファイルされたプログラムは \fBexit\fR(2) を呼び出すか、正常に終了する必要があります。
.SH オプション
.sp
.LP
サポートしているオプションは、次のとおりです。
.sp
.ne 2
.mk
.na
\fB\fB-a\fR\fR
.ad
.sp .6
.RS 4n
静的に宣言された関数の出力を抑制します。このオプションを指定した場合、静的関数に関連するすべての情報 (たとえば、時間の標本、別の関数への呼び出し、別の関数からの呼び出し) は、\fBa.out\fR ファイルの静的関数の直前にロードされた関数に属することになります。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-b\fR\fR
.ad
.sp .6
.RS 4n
簡略化します。プロファイル内の各フィールドの説明を抑制します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-c\fR\fR
.ad
.sp .6
.RS 4n
オブジェクトファイルのテキスト空間を検査する発見的方法によって、プログラムの静的コールグラフを検出します。静的関数のみを持つ親または子は、呼び出し回数 0 で示されます。動的にリンクされた実行可能ファイルの場合、リンクされた共有オブジェクトのテキストセグメントは検査されません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-C\fR\fR
.ad
.sp .6
.RS 4n
C++ シンボル名を出力する前に復号化します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-D\fR\fR
.ad
.sp .6
.RS 4n
指定されたすべてのプロファイルファイルのプロファイル情報の差異を示すプロファイルファイル \fBgmon.sum\fR を生成します。このサマリープロファイルファイルは、\fBa.out\fR ファイルの複数の実行のプロファイルデータを集約するために、\fBgprof\fR (\fB-D\fR も指定) の後続の実行に渡すことができます。\fB-s\fR オプションも参照してください。
.sp
たとえば、プロファイルファイル \fBgmon.sum\fR で関数 A が関数 B を \fBn\fR 回呼び出し、プロファイルファイル \fBgmon.out\fR で \fBm\fR 回呼び出すとします。\fB-D\fR を指定すると、A から B の呼び出し回数を \fBn-m\fR として示す新しい \fBgmon.sum\fR ファイルが作成されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-e\fR\fIfunction-name\fR\fR
.ad
.sp .6
.RS 4n
ルーチン \fIfunction-name\fR およびそのすべての子孫 (抑制されていない別の祖先がない場合) のグラフプロファイルエントリの出力を抑制します。\fB-e\fR オプションは複数指定できます。各 \fB-e\fR オプションに指定できる \fIfunction-name\fR は 1 つのみです。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-E\fR\fIfunction-name\fR\fR
.ad
.sp .6
.RS 4n
ルーチン \fIfunction-name\fR (およびその子孫) のグラフプロファイルエントリの出力を抑制します (下の \fB-e\fR と同様)。また、合計時間および時間の割合の計算から \fIfunction-name\fR (およびその子孫) が費やした時間を除外します。\fB-E\fR オプションは複数指定できます。例:  
.sp
\fB-E\fR \fImcount\fR \fB-E\fR \fImcleanup\fR
.sp
はデフォルトです。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-f\fR\fIfunction-name\fR\fR
.ad
.sp .6
.RS 4n
ルーチン \fIfunction-name\fR およびその子孫のグラフプロファイルエントリのみを出力します。\fB-f\fR オプションは複数指定できます。各 \fB-f\fR オプションに指定できる \fIfunction-name\fR は 1 つのみです。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-F\fR\fIfunction-name\fR\fR
.ad
.sp .6
.RS 4n
ルーチン \fIfunction-name\fR およびその子孫のグラフプロファイルエントリを出力します (下の \fB-f\fR と同様)。また、出力されるルーチンの時間のみを合計時間および割合の計算に使用します。\fB-F\fR オプションは複数指定できます。各 \fB-F\fR オプションに指定できる \fIfunction-name\fR は 1 つのみです。\fB-F\fR オプションは \fB-E\fR オプションをオーバーライドします。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-l\fR\fR
.ad
.sp .6
.RS 4n
すべてのローカルシンボルのグラフプロファイルエントリの報告を抑制します。このオプションは、指定された実行可能イメージのローカルシンボルを \fB-E\fR の除外リストに指定することと同等です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-n\fR\fR
.ad
.sp .6
.RS 4n
フラットプロファイルおよびグラフプロファイルのリストのサイズを、上位 \fBn\fR の問題のある関数に制限します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-s\fR\fR
.ad
.sp .6
.RS 4n
指定されたすべてのプロファイルファイルのプロファイル情報の合計を示すプロファイルファイル \fBgmon.sum\fR を生成します。このサマリープロファイルファイルは、\fBa.out\fR ファイルの複数の実行のプロファイルデータを累積するために、\fBgprof\fR (\fB-s\fR を指定) の後続の実行に渡すことができます。\fB-D\fR オプションも参照してください。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-z\fR\fR
.ad
.sp .6
.RS 4n
使用されていないルーチン (呼び出し回数および累積された時間で示されます) を表示します。これは、\fB-c\fR オプションと組み合わせると、呼び出されたことがないルーチンを検出するために役に立ちます。共有オブジェクトのテキスト空間は \fB-c\fR オプションによって検査されないため、動的にリンクされた実行可能ファイルの場合は使用が制限されます。
.RE

.SH 環境
.sp
.ne 2
.mk
.na
\fB\fBPROFDIR\fR\fR
.ad
.sp .6
.RS 4n
この環境変数に値が含まれている場合、そのディレクトリ内の \fIpid\fR\fB\&.\fR\fIprogramname\fR という名前のファイルにプロファイリング出力が書き込まれます。\fIpid\fR はプロセス \fBID\fR であり、\fIprogramname\fR はプログラムが呼び出されたときの \fBargv[0]\fR からパス接頭辞を削除することによって判別されるプロファイルされるプログラムの名前です。変数に NULL 値が含まれている場合、プロファイリングの出力は生成されません。それ以外の場合、プロファイリング出力は \fBgmon.out\fR ファイルに書き込まれます。
.RE

.SH ファイル
.sp
.ne 2
.mk
.na
\fB\fBa.out\fR\fR
.ad
.sp .6
.RS 4n
名前リストが含まれている実行可能ファイル
.RE

.sp
.ne 2
.mk
.na
\fB\fBgmon.out\fR\fR
.ad
.sp .6
.RS 4n
動的なコールグラフおよびプロファイル
.RE

.sp
.ne 2
.mk
.na
\fB\fBgmon.sum\fR\fR
.ad
.sp .6
.RS 4n
集約された動的なコールグラフおよびプロファイル
.RE

.sp
.ne 2
.mk
.na
\fB\fB$PROFDIR/\fR\fIpid\fR\fB\&.\fR\fIprogramname\fR\fR
.ad
.sp .6
.RS 4n

.RE

.SH 属性
.sp
.LP
属性についての詳細は、マニュアルページの \fBattributes\fR(5) を参照してください。
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
属性タイプ属性値
_
使用条件developer/base-developer-utilities
.TE

.SH 関連項目
.sp
.LP
\fBcc\fR(1)、\fBld.so.1\fR(1)、\fBprof\fR(1)、\fBexit\fR(2)、\fBpcsample\fR(2)、\fBprofil\fR(2)、\fBmalloc\fR(3C)、\fBmalloc\fR(3MALLOC)、\fBmonitor\fR(3C)、\fBattributes\fR(5)、\fBprof\fR(5)
.sp
.LP
Graham, S.L.、Kessler, P.B.、McKusick, M.K. 著、『\fIgprof: A Call Graph Execution Profiler Proceedings of the SIGPLAN '82 Symposium on Compiler Construction\fR』、\fBSIGPLAN\fR Notices、Vol. 17、No. 6、120-126 ページ、1982 年 6 月。
.sp
.LP
\fI『Oracle Solaris 11.3 Linkers and Libraries         Guide』\fR
.SH 注意事項
.sp
.LP
実行可能イメージが取り除かれ、\fB\&.symtab\fR シンボルテーブルがない場合、\fBgprof\fR はグローバル動的シンボルテーブル \fB\&.dynsym\fR および \fB\&.SUNW_ldynsym\fR (存在する場合) を読み込みます。動的シンボルテーブル内のシンボルは、\fB\&.symtab\fR にあるシンボルのサブセットです。\fB\&.dynsym\fR シンボルテーブルには、ランタイムリンカーによって使用されるグローバルシンボルが含まれています。\fB\&.SUNW_ldynsym\fR は \fB\&.dynsym\fR の情報をローカル関数のシンボルで拡張します。\fB\&.dynsym\fR が見つかって \fB\&.SUNW_ldynsym\fR が見つからない場合は、グローバルシンボルの情報のみを使用できます。ローカルシンボルがない場合、動作は \fB-a\fR オプションの説明と同じです。
.sp
.LP
プロファイリングするプログラムをコンパイルするときに、\fBLD_LIBRARY_PATH\fR に \fB/usr/lib\fR をコンポーネントとして含めないでください。\fBLD_LIBRARY_PATH\fR に \fB/usr/lib\fR が含まれている場合、プログラムは \fB/usr/lib/libp\fR のプロファイリングバージョンのシステムライブラリと正しくリンクされません。
.sp
.LP
同一の実行を連続して行なったときに報告される時間が異なる場合があります。これは、ほかのプロセスとキャッシュを共有したことによってキャッシュヒット率が変化したためです。マシンを使用しているプログラムが 1 つのみのように見えていても、隠れているバックグラウンドプロセスまたは非同期プロセスがデータに影響することがあります。まれに、プログラムの記録を開始するクロックティックがプログラムのループに\fB影響して\fR測定が大幅に歪むことがあります。ただし、呼び出し回数は常に正確に記録されます。
.sp
.LP
\fBmonitor\fR への最後の呼び出しが明示的にコーディングされていない場合、プロファイルファイルの生成が保証されるのは、\fBexit\fR を呼び出すプログラムまたは \fBmain\fR から戻るプログラムのみです。
.sp
.LP
\fBmcount()\fR、\fB_mcount()\fR、\fBmoncontrol()\fR、\fB_moncontrol()\fR、\fBmonitor()\fR、\fB_monitor()\fR などの関数が \fBgprof\fR の報告に表示されることがあります。これらの関数はプロファイリングの実装の一部であり、実行時のオーバーヘッドが多少あります。これらの関数はプロファイルされていないアプリケーションにはないため、アプリケーションのパフォーマンスを評価する場合、これらの関数の累積時間および呼び出し回数は無視できます。
.SS "64 ビットプロファイリング"
.sp
.LP
64 ビットのプロファイリングは、動的にリンクされた実行可能ファイルで自由に使用できます。オブジェクトがプロファイリング用にコンパイルされている場合は、共有オブジェクトのプロファイリング情報が収集されます。ほかの共有オブジェクトのシンボルが同じ名前である可能性があるため、プロファイルの出力を解釈するときに注意する必要があります。プロファイルの出力で名前の重複が発生した場合は、シンボルインデックスリストのシンボル名の前にあるモジュール ID 接頭辞を使用すると、シンボルの該当するモジュールを識別できます。
.sp
.LP
\fB-s\fR または \fB-D\fR オプションを使用して複数のプロファイルファイルを集約する場合は、32 ビットのプロファイルファイルと 64 ビットのプロファイルファイルを混同しないように注意する必要があります。
.SS "32 ビットプロファイリング"
.sp
.LP
32 ビットプロファイリングは動的にリンクされた実行可能ファイルに使用できますが、注意する必要があります。32 ビットプロファイリングでは、共有オブジェクトは \fBgprof\fR でプロファイルできません。このため、プロファイルされた動的にリンクされたプログラムを実行すると、イメージの \fBmain\fR の部分のみが標本収集されます。これは、\fBmain\fR オブジェクトの外部で費やされたすべての時間 (つまり、共有オブジェクトで費やされた時間) は、プロファイルサマリーに含められないことを意味し、プログラムで報告される合計時間が、プログラムによって使用された合計時間より少ない場合があります。
.sp
.LP
共有オブジェクトに費やされる時間は計測できないため、プログラムを \fBgprof\fR でプロファイルする場合は、共有オブジェクトの使用は最小限にしてください。必要な場合は、プログラムを共有オブジェクトではなくプロファイルされたバージョンのライブラリ (またはプロファイリングバージョンがない場合は、標準のアーカイブバージョン) にリンクして、ライブラリの関数のプロファイル情報を取得してください。プロファイルされたライブラリのバージョンは、システムの \fB/usr/lib/libp\fR ディレクトリに配置されている場合があります。プロファイリングについては、コンパイラドライバのドキュメントを参照してください。
.sp
.LP
極端な場合を考えてみます。共有 C ライブラリと動的にリンクされたプロファイルされたプログラムが、いくつかの \fBlibc\fR ルーチン (\fBmalloc()\fR など) で 100 単位時間を費やします。\fBmalloc()\fR はルーチン \fBB\fR からのみ呼び出され、\fBB\fR は 1 単位時間のみを消費するとします。さらに、ルーチン \fBA\fR は、イメージの \fBmain\fR (プロファイルされている) 部分のほかのどのルーチンよりも多い 10 単位時間を消費するとします。この場合、\fBgprof\fR は、ほとんどの時間は \fBA\fR で費やされ、\fBB\fR ではほとんど時間が費やされなかったと判断します。このことから、ルーチン \fBA\fR ではなくルーチン \fBB\fR を調査することによって大きな改善を望むのは、ほとんど不可能です。この場合のプロファイラの値は非常に劣化しています。これを解決するには、プロファイリングにアーカイブをできるかぎり使用します。
.SH 使用上の留意点
.sp
.LP
プロファイルされていない親には、プロファイルされた子の時間が伝播されますが、それらはコールグラフリストで自然発生的に呼び出されたように見え、時間はそれ以上伝播されません。同様に、シグナルキャッチャーは、プロファイルされていても自然発生的に見えます (原因はさらに不明です)。シグナルキャッチャーがプロファイリングルーチンの実行中に呼び出された場合 (この場合はすべてが失われます) を除き、シグナルキャッチャーのプロファイルされた子の時間は適切に伝播されるべきです。
