'\" te
.\" Copyright (c) 2009, 2011, Oracle and/or its affiliates.All rights reserved.
.\" Copyright 1989 AT&T
.TH prof 1 "2011 年 6 月 8 日" "SunOS 5.11" "ユーザーコマンド"
.SH 名前
prof \- プロファイルデータの表示
.SH 形式
.LP
.nf
\fBprof\fR [\fB-ChsVz\fR] [\fB-a\fR | c | n | t] [\fB-o\fR | x] [\fB-g\fR | l] [\fB-m\fR \fImdata\fR] 
     [\fIprog\fR]
.fi

.SH 機能説明
.sp
.LP
\fBprof\fR コマンドは、\fBmonitor\fR 関数によって生成されるプロファイルファイルを解釈します。オブジェクトファイル \fIprog\fR (デフォルトでは \fBa.out\fR) のシンボルテーブルが読み込まれ、プロファイルファイル (デフォルトでは \fBmon.out\fR) と関係付けされます。外部テキストシンボルごとに、そのシンボルのアドレスと次のシンボルのアドレスの間までの実行に費やされた時間の割合が、その関数が呼び出された回数と、呼び出し 1 回当たりの平均時間 (ミリ秒単位) と一緒に出力されます。
.SH オプション
.sp
.LP
相互排他的なオプション \fB-a\fR、\fB-c\fR、\fB-n\fR、および \fB-t\fR によって、出力行のソートのタイプが決定されます。
.sp
.ne 2
.mk
.na
\fB\fB-a\fR\fR
.ad
.RS 6n
.rt  
シンボルアドレスの昇順でソートします。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-c\fR\fR
.ad
.RS 6n
.rt  
呼び出し数の降順でソートします。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-n\fR\fR
.ad
.RS 6n
.rt  
シンボル名の字句によってソートします。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-t\fR\fR
.ad
.RS 6n
.rt  
合計時間の割合の降順でソートします (デフォルト)。
.RE

.sp
.LP
相互排他的なオプション \fB-o\fR および \fB-x\fR は、モニターされた各シンボルのアドレスの出力を指定します。
.sp
.ne 2
.mk
.na
\fB\fB-o\fR\fR
.ad
.RS 6n
.rt  
各シンボルアドレス (8 進数) とシンボル名を一緒に出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-x\fR\fR
.ad
.RS 6n
.rt  
各シンボルアドレス (16 進数) とシンボル名を一緒に出力します。
.RE

.sp
.LP
相互排他的なオプション \fB-g\fR および \fB-l\fR は、報告されるシンボルのタイプを制御します。\fB-l\fR オプションは慎重に使用する必要があります。これは、静的関数に費やした時間を前の (メモリー内の) グローバル関数に適用するのであって、静的関数に対してレポート内で別のエントリを立てるわけではありません。すべての静的関数が適切に配置されている場合、この機能は非常に便利です。そうではない場合、結果のレポートは誤解を招く可能性があります。
.sp
.LP
かりに、\fBA\fR と \fBB\fR がグローバル関数で、\fBA\fR のみが静的関数 \fBS\fR を呼び出すとします。\fBS\fR がソースコード内で A の直後に配置されている (つまり \fBS\fR が正しく配置されている) 場合、\fB-l\fR オプションを使用することで、\fBA\fR に費やされる時間量は、\fBS\fR に費やされる時間を含めて簡単に判定できます。ただし、\fBA\fR と \fBB\fR の両方が \fBS\fR を呼び出す場合に \fB-l\fR オプションが使用されると、レポートは誤解を与えます。\fBB\fR が \fBS\fR を呼び出す間に費やされる時間は \fBA\fR に加算されるため、実際よりも多くの時間が \fBA\fR に費やされたかのように表示されます。この場合、関数 \fBS\fR を正しく配置することはできません。
.sp
.ne 2
.mk
.na
\fB\fB-g\fR\fR
.ad
.RS 6n
.rt  
静的 (非大域) 関数に費やされた時間を別々にリストします。\fB-g\fR オプション関数は \fB-l\fR の関数の逆です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-l\fR\fR
.ad
.RS 6n
.rt  
静的に宣言された関数の出力を抑制します。このオプションが指定された場合、静的関数の実行に費やした時間は、実行可能ファイル内の静的関数の前にロードされたもっとも近いグローバル関数に割り当てられます。このオプションはデフォルトです。これは \fB-g\fR 関数の逆であり、慎重に使用する必要があります。
.RE

.sp
.LP
次のオプションは任意に組み合わせて使用できます。
.sp
.ne 2
.mk
.na
\fB\fB-C\fR\fR
.ad
.RS 12n
.rt  
C++ シンボル名を出力する前に復号化します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-h\fR\fR
.ad
.RS 12n
.rt  
レポートに通常出力されているヘッダーを抑制します。これは、レポートをさらに処理する場合に便利です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-m\fR \fImdata\fR\fR
.ad
.RS 12n
.rt  
入力プロファイルファイルとして \fBmon.out\fR の代わりにファイル \fImdata\fR を使用します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-s\fR\fR
.ad
.RS 12n
.rt  
モニタリングパラメータおよび統計の複数のサマリーを標準エラー出力に出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-V\fR \fR
.ad
.RS 12n
.rt  
標準エラー出力に \fBprof\fR バージョン情報を出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-z\fR\fR
.ad
.RS 12n
.rt  
コール数がゼロでゼロ時間に関連付けられている場合でも、プロファイル範囲内のすべての記号を含めます。
.RE

.sp
.LP
\fBMARK\fR マクロを使用したプロファイリングのために、単一の関数がサブ関数に分割されることがあります。\fBprof\fR(5) を参照してください。
.SH 環境
.sp
.ne 2
.mk
.na
\fB\fBPROFDIR\fR\fR
.ad
.RS 11n
.rt  
プロファイルされたプログラムによって作成されるファイルの名前は、環境変数 \fBPROFDIR\fR で制御されます。\fBPROFDIR\fR が設定されない場合、プログラムの終了時点の現行ディレクトリに \fBmon.out\fR が生成されます。\fBPROFDIR\fR=\fI string\fR の場合、\fIstring\fR\fB/\fR\fIpid\fR\fB\&.\fR\fIprogname\fR が生成されます。ここで、\fIprogname\fR はパス接頭辞が削除された \fBargv[0]\fR で構成され、\fIpid\fR はプログラムのプロセス ID です。\fBPROFDIR\fR が設定されていても NULL の場合、プロファイリング出力は生成されません。
.RE

.SH ファイル
.sp
.ne 2
.mk
.na
\fB\fBmon.out\fR\fR
.ad
.RS 11n
.rt  
デフォルトのプロファイルファイル
.RE

.sp
.ne 2
.mk
.na
\fB\fBa.out\fR\fR
.ad
.RS 11n
.rt  
デフォルトの名前リスト (オブジェクト) ファイル
.RE

.SH 属性
.sp
.LP
属性についての詳細は、マニュアルページの \fBattributes\fR(5) を参照してください。
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
属性タイプ属性値
_
使用条件developer/base-developer-utilities
.TE

.SH 関連項目
.sp
.LP
\fBgprof\fR(1), \fBexit\fR(2), \fBpcsample\fR(2), \fBprofil\fR(2), \fBmalloc\fR(3C), \fBmalloc\fR(3MALLOC), \fBmonitor\fR(3C), \fBattributes\fR(5), \fBprof\fR(5)
.SH 注意事項
.sp
.LP
実行可能イメージが取り除かれ、\fB\&.symtab\fR シンボルテーブルがない場合、\fBgprof\fR はグローバル動的シンボルテーブル \fB\&.dynsym\fR および \fB\&.SUNW_ldynsym\fR (存在する場合) を読み込みます。動的シンボルテーブル内のシンボルは、\fB\&.symtab\fR にあるシンボルのサブセットです。\fB\&.dynsym\fR シンボルテーブルには、ランタイムリンカーによって使用されるグローバルシンボルが含まれています。\fB\&.SUNW_ldynsym\fR は \fB\&.dynsym\fR の情報をローカル関数のシンボルで拡張します。\fB\&.dynsym\fR が見つかって \fB\&.SUNW_ldynsym\fR が見つからない場合は、グローバルシンボルの情報のみを使用できます。ローカルシンボルがない場合、動作は \fB-a\fR オプションの説明と同じです。
.sp
.LP
同一の実行を連続して行なったときに報告される時間が異なる場合があります。これは、ほかのプロセスとキャッシュを共有したことによってキャッシュヒット率が変化したためです。マシンを使用しているプログラムが 1 つのみのように見えていても、隠れているバックグラウンドプロセスまたは非同期プロセスがデータに影響することがあります。まれに、プログラムの記録を開始するクロックティックがプログラムのループに\fB影響して\fR測定が大幅に歪むことがあります。ただし、呼び出し回数は常に正確に記録されます。
.sp
.LP
\fBmonitor\fR への最後の呼び出しが明示的にコーディングされていない場合、プロファイルファイルの生成が保証されるのは、\fBexit\fR を呼び出すプログラムまたは \fBmain\fR から戻るプログラムのみです。
.sp
.LP
\fB-g\fR オプションが使用されない場合、静的関数に対する時間は前の外部テキストシンボルに加算されます。ただし、前の関数の呼び出し回数は正しいままです。つまり、静的関数の呼び出し回数は、外部関数の呼び出し回数に追加されません。
.sp
.LP
\fB-t\fR、\fB-c\fR、\fB-a\fR、および \fB-n\fR のうち複数が指定さた場合、最後に指定されたオプションが使用され、警告が表示されます。
.sp
.LP
プロファイリングするプログラムをコンパイルするときに、\fBLD_LIBRARY_PATH\fR に \fB/usr/lib\fR をコンポーネントとして含めないでください。\fBLD_LIBRARY_PATH\fR に \fB/usr/lib\fR が含まれている場合、プログラムは \fB/usr/lib/libp\fR のプロファイリングバージョンのシステムライブラリと正しくリンクされません。\fBgprof\fR(1) を参照してください。
.sp
.LP
\fBmcount()\fR、\fB_mcount()\fR、\fBmoncontrol()\fR、\fB_moncontrol()\fR、\fBmonitor()\fR、\fB_monitor()\fR などの関数が \fBprof\fR レポートに表示される場合もあります。これらの関数はプロファイリングの実装の一部であり、実行時のオーバーヘッドが多少あります。これらの関数はプロファイルされていないアプリケーションにはないため、アプリケーションのパフォーマンスを評価する場合、これらの関数の累積時間および呼び出し回数は無視できます。
.SS "64 ビットプロファイリング"
.sp
.LP
64 ビットのプロファイリングは、動的にリンクされた実行可能ファイルで自由に使用できます。オブジェクトがプロファイリング用にコンパイルされている場合は、共有オブジェクトのプロファイリング情報が収集されます。ほかの共有オブジェクトのシンボルが同じ名前である可能性があるため、プロファイルの出力を解釈するときに注意する必要があります。重複した名前がプロファイル出力に表示される場合、重複している各シンボルの前にモジュール ID の接頭辞を付ける、\fB-s\fR (サマリー) オプションを使用することをお勧めします。シンボルはサマリー内のモジュール情報を確認することで、適切なモジュールにマップできます。
.sp
.LP
動的にリンクされた実行可能ファイルと一緒に \fB-a\fR オプションが使用される場合、共有オブジェクト単位でソートが発生します。異なる共有オブジェクトからのシンボルが同じ値を持つ可能性が高いため、この方法により、理解しやすい出力が得られます。\fB-s\fR オプションが指定された場合、異なる共有オブジェクトからのシンボルは、空白行で区切られます。
.SS "32 ビットプロファイリング"
.sp
.LP
32 ビットプロファイリングは動的にリンクされた実行可能ファイルに使用できますが、注意する必要があります。32 ビットプロファイリングでは、\fBprof\fR を使用して共有オブジェクトのプロファイルを作成することはできません。このため、プロファイルされた動的にリンクされたプログラムを実行すると、イメージの \fBmain\fR の部分のみが標本収集されます。これは、\fBmain\fR オブジェクトの外部で費やされたすべての時間 (つまり、共有オブジェクトで費やされた時間) は、プロファイルサマリーに含められないことを意味し、プログラムで報告される合計時間が、プログラムによって使用された合計時間より少ない場合があります。
.sp
.LP
共有オブジェクト内で費やされる時間を計上できないため、\fBprof\fR を使用してプログラムのプロファイルを作成する場合は常に、共有オブジェクトの使用を最小限にする必要があります。必要な場合は、プログラムを共有オブジェクトではなくプロファイルされたバージョンのライブラリ (またはプロファイリングバージョンがない場合は、標準のアーカイブバージョン) にリンクして、ライブラリの関数のプロファイル情報を取得してください。プロファイルされたライブラリのバージョンは、システムの \fB/usr/lib/libp\fR ディレクトリに配置されている場合があります。プロファイリングについては、コンパイラドライバのドキュメントを参照してください。
.sp
.LP
極端な場合を考えてみます。共有 C ライブラリと動的にリンクされたプロファイルされたプログラムが、いくつかの \fBlibc\fR ルーチン (\fBmalloc()\fR など) で 100 単位時間を費やします。\fBmalloc()\fR はルーチン \fBB\fR からのみ呼び出され、\fBB\fR は 1 単位時間のみを消費するとします。さらに、ルーチン \fBA\fR は、イメージの \fBmain\fR (プロファイルされている) 部分のほかのどのルーチンよりも多い 10 単位時間を消費するとします。この場合、\fBprof\fR では、ほとんどの時間が \fBA\fR に費やされ、\fBB\fR に費やされる時間はほとんどないと結論づけられます。このことから、ルーチン \fBA\fR ではなくルーチン \fBB\fR を調査することによって大きな改善を望むのは、ほとんど不可能です。この場合のプロファイラの値は非常に劣化しています。これを解決するには、プロファイリングにアーカイブをできるかぎり使用します。
