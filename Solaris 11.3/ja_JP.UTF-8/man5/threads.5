'\" te
.\" Copyright (c) 2008, 2014, Oracle and/or its affiliates.All rights reserved.
.TH threads 5 "2014 年 4 月 23 日" "SunOS 5.11" "標準、環境、マクロ"
.SH 名前
threads, pthreads \- POSIX pthread と Solaris スレッドの概念
.SH 形式
.SS "POSIX"
.LP
.nf
cc –mt [ \fIflag\fR... ] \fIfile\fR... [ \fI library\fR... ]
.fi

.LP
.nf
#include <pthread.h> 
.fi

.SS "Solaris"
.LP
.nf
cc –mt [ \fIflag\fR... ] \fIfile\fR... [ \fI library\fR... ]
.fi

.LP
.nf
#include <sched.h>
.fi

.LP
.nf
#include <thread.h>
.fi

.SH 機能説明
.sp
.LP
POSIX スレッドと Solaris スレッドにはそれぞれ、\fBlibc\fR(3LIB) 内に独自の実装があります。両方の実装は相互運用可能であり、それぞれの機能は類似しているため、同じアプリケーション内で使用できます。POSIX に準拠したほかの環境に完全に移植できることが保証されているのは POSIX スレッドだけです。POSIX スレッドと Solaris スレッドには、異なるソース、インクルードファイル、およびリンクライブラリが必要です。「\fB形式\fR」を参照してください。 
.SS "類似点"
.sp
.LP
POSIX と Solaris のスレッド化関数のほとんどには、互いに対応する関数があります。セマフォー名を除き、POSIX 関数名には「\fBpthread\fR」の接頭辞が付いています。類似した POSIX 関数と Solaris 関数は、関数名の末尾が類似しています。通常、類似した POSIX 関数と Solaris 関数には、同じ数と用途の引数があります。
.SS "相違点"
.sp
.LP
POSIX pthread と Solaris スレッドは、次の点で異なっています: 
.RS +4
.TP
.ie t \(bu
.el o
POSIX スレッドの方が移植性があります。
.RE
.RS +4
.TP
.ie t \(bu
.el o
POSIX スレッドでは、構成可能な属性オブジェクトに従って、各スレッドの特性が確立されています。
.RE
.RS +4
.TP
.ie t \(bu
.el o
POSIX pthread には、スレッド取り消しが実装されています。 
.RE
.RS +4
.TP
.ie t \(bu
.el o
POSIX pthread では、スケジューリングのアルゴリズムが適用されます。
.RE
.RS +4
.TP
.ie t \(bu
.el o
POSIX pthread では、\fBfork\fR(2) 呼び出しのためのクリーンアップハンドラが許可されます。
.RE
.RS +4
.TP
.ie t \(bu
.el o
Solaris スレッドは中断したり、続行したりできます。
.RE
.RS +4
.TP
.ie t \(bu
.el o
Solaris スレッドには、プロセスがその消滅を待たないデーモンスレッドが実装されています。
.RE
.SH 関数の比較
.sp
.LP
次の表に、POSIX pthread と Solaris スレッドの関数の比較を示します。POSIX pthread または Solaris スレッドのどちらかで比較可能なインタフェースがない場合は、その列にハイフン (\fB–\fR) が表示されます。
.SS "作成に関連した関数"
.sp

.sp
.TS
tab();
lw(2.75i) lw(2.75i) 
lw(2.75i) lw(2.75i) 
.
\fBPOSIX\fR\fBSolaris\fR
\fBpthread_create()\fR\fBthr_create()\fR
\fBpthread_attr_init()\fR\fB–\fR
\fBpthread_attr_setdetachstate()\fR\fB–\fR
\fBpthread_attr_getdetachstate()\fR\fB–\fR
\fBpthread_attr_setinheritsched()\fR\fB–\fR
\fBpthread_attr_getinheritsched()\fR\fB–\fR
\fBpthread_attr_setschedparam()\fR\fB–\fR
\fBpthread_attr_getschedparam()\fR\fB–\fR
\fBpthread_attr_setschedpolicy()\fR\fB–\fR
\fBpthread_attr_getschedpolicy()\fR\fB–\fR
\fBpthread_attr_setscope()\fR\fB–\fR
\fBpthread_attr_getscope()\fR\fB–\fR
\fBpthread_attr_setstackaddr()\fR\fB–\fR
\fBpthread_attr_getstackaddr()\fR\fB–\fR
\fBpthread_attr_setstacksize()\fR\fB–\fR
\fBpthread_attr_getstacksize()\fR\fB–\fR
\fBpthread_attr_getguardsize()\fR\fB–\fR
\fBpthread_attr_setguardsize()\fR\fB–\fR
\fBpthread_attr_destroy()\fR\fB–\fR
\fB–\fR\fBthr_min_stack()\fR
.TE

.SS "終了に関連した関数"
.sp

.sp
.TS
tab();
lw(2.75i) lw(2.75i) 
lw(2.75i) lw(2.75i) 
.
\fBPOSIX\fR\fBSolaris\fR
\fBpthread_exit()\fR\fBthr_exit()\fR
\fBpthread_join()\fR\fBthr_join()\fR
\fBpthread_detach()\fR\fB–\fR
.TE

.SS "スレッド固有のデータに関連した関数"
.sp

.sp
.TS
tab();
lw(2.75i) lw(2.75i) 
lw(2.75i) lw(2.75i) 
.
\fBPOSIX\fR\fBSolaris\fR
\fBpthread_key_create()\fR\fBthr_keycreate()\fR
\fBpthread_setspecific()\fR\fBthr_setspecific()\fR
\fBpthread_getspecific()\fR\fBthr_getspecific()\fR
\fBpthread_key_delete()\fR\fB–\fR
.TE

.SS "シグナルに関連した関数"
.sp

.sp
.TS
tab();
lw(2.75i) lw(2.75i) 
lw(2.75i) lw(2.75i) 
.
\fBPOSIX\fR\fBSolaris\fR
\fBpthread_sigmask()\fR\fBthr_sigsetmask()\fR
\fBpthread_kill()\fR\fBthr_kill()\fR
.TE

.SS "ID に関連した関数"
.sp

.sp
.TS
tab();
lw(2.75i) lw(2.75i) 
lw(2.75i) lw(2.75i) 
.
\fBPOSIX\fR\fBSolaris\fR
\fBpthread_self()\fR\fBthr_self()\fR
\fBpthread_equal()\fR\fB–\fR
\fB–\fR\fBthr_main()\fR
.TE

.SS "スケジューリングに関連した関数"
.sp

.sp
.TS
tab();
lw(2.75i) lw(2.75i) 
lw(2.75i) lw(2.75i) 
.
\fBPOSIX\fR\fBSolaris\fR
\fB–\fR\fBthr_yield()\fR
\fB–\fR\fBthr_suspend()\fR
\fB–\fR\fBthr_continue()\fR
\fBpthread_setconcurrency()\fR\fBthr_setconcurrency()\fR
\fBpthread_getconcurrency()\fR\fBthr_getconcurrency()\fR
\fBpthread_setschedparam()\fR\fBthr_setprio()\fR
\fBpthread_setschedprio()\fR\fBthr_setprio()\fR
\fBpthread_getschedparam()\fR\fBthr_getprio()\fR
.TE

.SS "取り消しに関連した関数"
.sp

.sp
.TS
tab();
lw(2.75i) lw(2.75i) 
lw(2.75i) lw(2.75i) 
.
\fBPOSIX\fR\fBSolaris\fR
\fBpthread_cancel()\fR\fB–\fR
\fBpthread_setcancelstate()\fR\fB–\fR
\fBpthread_setcanceltype()\fR\fB–\fR
\fBpthread_testcancel()\fR\fB–\fR
\fBpthread_cleanup_pop()\fR\fB–\fR
\fBpthread_cleanup_push()\fR\fB–\fR
.TE

.SS "相互排他ロックに関連した関数"
.sp

.sp
.TS
tab();
lw(3.85i) lw(1.65i) 
lw(3.85i) lw(1.65i) 
.
\fBPOSIX\fR\fBSolaris\fR
\fBpthread_mutex_init()\fR\fBmutex_init()\fR
\fBpthread_mutexattr_init()\fR\fB–\fR
\fBpthread_mutexattr_setpshared()\fR\fB–\fR
\fBpthread_mutexattr_getpshared()\fR\fB–\fR
\fBpthread_mutexattr_setprotocol()\fR\fB–\fR
\fBpthread_mutexattr_getprotocol()\fR\fB–\fR
\fBpthread_mutexattr_setprioceiling()\fR\fB–\fR
\fBpthread_mutexattr_getprioceiling()\fR\fB–\fR
\fBpthread_mutexattr_settype()\fR\fB–\fR
\fBpthread_mutexattr_gettype()\fR\fB–\fR
\fBpthread_mutexattr_setrobust()\fR\fB–\fR
\fBpthread_mutexattr_getrobust()\fR\fB–\fR
\fBpthread_mutexattr_destroy()\fR\fB–\fR
\fBpthread_mutex_setprioceiling()\fR\fB–\fR
\fBpthread_mutex_getprioceiling()\fR\fB–\fR
\fBpthread_mutex_lock()\fR\fBmutex_lock()\fR
\fBpthread_mutex_trylock()\fR\fBmutex_trylock()\fR
\fBpthread_mutex_unlock()\fR\fBmutex_unlock()\fR
\fBpthread_mutex_destroy()\fR\fBmutex_destroy()\fR
.TE

.SS "条件変数に関連した関数"
.sp

.sp
.TS
tab();
lw(2.75i) lw(2.75i) 
lw(2.75i) lw(2.75i) 
.
\fBPOSIX\fR\fBSolaris\fR
\fBpthread_cond_init()\fR\fBcond_init()\fR
\fBpthread_condattr_init()\fR\fB–\fR
\fBpthread_condattr_setpshared()\fR\fB–\fR
\fBpthread_condattr_getpshared()\fR\fB–\fR
\fBpthread_condattr_destroy()\fR\fB–\fR
\fBpthread_cond_wait()\fR\fBcond_wait()\fR
\fBpthread_cond_timedwait()\fR\fBcond_timedwait()\fR
\fBpthread_cond_signal()\fR\fBcond_signal()\fR
\fBpthread_cond_broadcast()\fR\fBcond_broadcast()\fR
\fBpthread_cond_destroy()\fR\fBcond_destroy()\fR
.TE

.SS "読み取り書き込みロックに関連した関数"
.sp

.sp
.TS
tab();
lw(2.75i) lw(2.75i) 
lw(2.75i) lw(2.75i) 
.
\fBPOSIX\fR\fBSolaris\fR
\fBpthread_rwlock_init()\fR\fBrwlock_init()\fR
\fBpthread_rwlock_rdlock()\fR\fBrw_rdlock()\fR
\fBpthread_rwlock_tryrdlock()\fR\fBrw_tryrdlock()\fR
\fBpthread_rwlock_wrlock()\fR\fBrw_wrlock()\fR
\fBpthread_rwlock_trywrlock()\fR\fBrw_trywrlock()\fR
\fBpthread_rwlock_unlock()\fR\fBrw_unlock()\fR
\fBpthread_rwlock_destroy()\fR\fBrwlock_destroy()\fR
\fBpthread_rwlockattr_init()\fR\fB–\fR
\fBpthread_rwlockattr_destroy()\fR\fB–\fR
\fBpthread_rwlockattr_getpshared()\fR\fB–\fR
\fBpthread_rwlockattr_setpshared()\fR\fB–\fR
.TE

.SS "セマフォーに関連した関数"
.sp

.sp
.TS
tab();
lw(2.75i) lw(2.75i) 
lw(2.75i) lw(2.75i) 
.
\fBPOSIX\fR\fBSolaris\fR
\fBsem_init()\fR\fBsema_init()\fR
\fBsem_open()\fR\fB–\fR
\fBsem_close()\fR\fB–\fR
\fBsem_wait()\fR\fBsema_wait()\fR
\fBsem_trywait()\fR\fBsema_trywait()\fR
\fBsem_post()\fR\fBsema_post()\fR
\fBsem_getvalue()\fR\fB–\fR
\fBsem_unlink()\fR\fB–\fR
\fBsem_destroy()\fR\fBsema_destroy()\fR
.TE

.SS "fork( ) クリーンアップに関連した関数"
.sp

.sp
.TS
tab();
lw(2.75i) lw(2.75i) 
lw(2.75i) lw(2.75i) 
.
\fBPOSIX\fR\fBSolaris\fR
\fBpthread_atfork()\fR\fB–\fR
.TE

.SS "制限に関連した関数"
.sp

.sp
.TS
tab();
lw(2.75i) lw(2.75i) 
lw(2.75i) lw(2.75i) 
.
\fBPOSIX\fR\fBSolaris\fR
\fBpthread_once()\fR\fB–\fR
.TE

.SS "デバッグに関連した関数"
.sp

.sp
.TS
tab();
lw(2.75i) lw(2.75i) 
lw(2.75i) lw(2.75i) 
.
\fBPOSIX\fR\fBSolaris\fR
\fB–\fR\fBthr_stksegment()\fR
.TE

.SH ロック
.SS "同期"
.sp
.LP
マルチスレッド動作は非同期であるため、並列処理や並行処理のために最適化されます。各スレッドは (常に同じプロセス内から、場合によっては複数のプロセスから) 互いにグローバルデータを共有しますが、共有データへの排他的アクセスが任意の特定の時点で保証されているとは限りません。共有データへの相互に排他的なアクセスをセキュリティーで保護するには、スレッド間の同期が必要です。POSIX と Solaris のどちらにも、次の 4 つの同期メカニズムが実装されています: 相互排他ロック、条件変数、読み取り書き込みロック (\fI頻繁な読み取りと不定期の書き込みのための最適化された相互排他ロック\fR)、セマフォー。
.sp
.LP
複数のスレッドを同期させると、それらの並行性が低下します。同期の粒度が粗い程 (つまり、ロックされるコードのブロックが大きい程)、並行性は低くなります。
.SS "MT の \fBfork()\fR"
.sp
.LP
スレッドのプログラムが \fBfork\fR(2) を呼び出した場合、呼び出し元スレッドのみを複製する \fBfork1\fR(2) が暗黙的に呼び出されます。プロセス全体にわたって未処理の相互排他ロックが存在する場合、アプリケーションは \fBfork()\fR を呼び出す前に、待機してこれらの相互排他ロックを取得するために \fBpthread_atfork\fR(3C) を呼び出すようにしてください。 
.SH スケジューリング
.SS "POSIX スレッド"
.sp
.LP
Solaris は、次の 3 つの POSIX スケジューリングポリシーをサポートしています:
.sp
.ne 2
.mk
.na
\fB\fBSCHED_OTHER\fR\fR
.ad
.RS 15n
.rt  
従来のタイムシェアリングスケジューリングポリシー。これは、タイムシェアリング (TS) スケジューリングクラスに基づいています。
.RE

.sp
.ne 2
.mk
.na
\fB\fBSCHED_FIFO\fR\fR
.ad
.RS 15n
.rt  
先入れ先出しスケジューリングポリシー。このポリシーに従ってスケジュールされたスレッドは、より高い優先度によって横取りされなければ、完了まで続行されます。このようなスレッドは、リアルタイム (RT) スケジューリングクラスに属します。呼び出し元プロセスの実効セットで {\fBPRIV_PROC_PRIOCNTL\fR} 特権が表明されている必要があります。
.RE

.sp
.ne 2
.mk
.na
\fB\fBSCHED_RR\fR\fR
.ad
.RS 15n
.rt  
ラウンドロビンスケジューリングポリシー。このポリシーに従ってスケジュールされたスレッドは、より高い優先度によって横取りされなければ、システムで決定された期間にわたって実行されます。このようなスレッドは、リアルタイム (RT) スケジューリングクラスに属し、呼び出し元プロセスの実効セットで {\fBPRIV_PROC_PRIOCNTL\fR} 特権が表明されている必要があります。
.RE

.sp
.LP
上の POSIX で指定されたスケジューリングポリシーに加えて、Solaris では次のスケジューリングポリシーもサポートされています:
.sp
.ne 2
.mk
.na
\fB\fBSCHED_IA\fR\fR
.ad
.RS 13n
.rt  
スレッドは、\fBpriocntl\fR(2) で説明されている対話型クラス (IA) ポリシーに従ってスケジュールされます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBSCHED_FSS\fR\fR
.ad
.RS 13n
.rt  
スレッドは、\fBpriocntl\fR(2) で説明されている公平配分クラス (FSS) ポリシーに従ってスケジュールされます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBSCHED_FX\fR\fR
.ad
.RS 13n
.rt  
スレッドは、\fBpriocntl\fR(2) で説明されている固定優先度クラス (FX) ポリシーに従ってスケジュールされます。
.RE

.SS "Solaris スレッド"
.sp
.LP
サポートされている唯一のスケジューリングポリシーが、\fBTS\fR スケジューリングクラスに基づいた \fBSCHED_OTHER\fR (タイムシェアリング) です。
.SH エラー
.sp
.LP
マルチスレッドアプリケーションでは、別のスレッドが \fBforkall\fR(2) を呼び出したとき、ブロックしているシステムコールから \fBEINTR\fR が返されることがあります。
.SH 使用法
.SS "\fB-mt\fR コンパイラオプション"
.sp
.LP
\fB-mt\fR コンパイラオプションは、マルチスレッド対応コードのためのコンパイルとリンクを行います。このオプションは -\fBD_REENTRANT\fR でソースファイルをコンパイルし、一連のサポートライブラリを正しく拡張します。
.SH 属性
.sp
.LP
属性についての詳細は、マニュアルページの \fBattributes\fR(5) を参照してください。
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
属性タイプ属性値
_
MT レベルMT-安全、Fork 1-安全
.TE

.SH 関連項目
.sp
.LP
\fBcrle\fR(1), \fBfork\fR(2), \fBpriocntl\fR(2), \fBlibpthread\fR(3LIB), \fBlibrt\fR(3LIB), \fBlibthread\fR(3LIB), \fBpthread_atfork\fR(3C), \fBpthread_create\fR(3C), \fBattributes\fR(5), \fBprivileges\fR(5), \fBstandards\fR(5) 
.sp
.LP
\fI『Oracle Solaris 11.3 Linkers and Libraries         Guide』\fR
