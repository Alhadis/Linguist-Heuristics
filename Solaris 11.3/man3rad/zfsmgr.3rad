'\" t
.\"     Title: zfsmgr
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.75.2 <http://docbook.sf.net/>
.\"      Date: 08/20/2015
.\"    Manual: RAD Module Definitions
.\"    Source: SunOS 5.11
.\"  Language: English
.\"
.TH "ZFSMGR" "3rad" "08/20/2015" "SunOS 5.11" "RAD Module Definitions"
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
zfsmgr
.SH "SYNOPSIS"
.SS "interface ZfsDataset"
.sp
.nf
.fi
.sp
.nf
ZfsDataset\ \&create_filesystem(string\ \&name,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&ZfsProp[]\ \&props,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&ZfsOpOption[]\ \&options);
.fi
.sp
.nf
ZfsSnapshot\ \&create_snapshot(string\ \&name,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&ZfsProp[]\ \&props,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&ZfsOpOption[]\ \&options);
.fi
.sp
.nf
destroy_snapshot(string\ \&name,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&ZfsOpOption[]\ \&options);
.fi
.sp
.nf
rename_snapshot(string\ \&old_name,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&string\ \&new_name,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&ZfsOpOption[]\ \&options);
.fi
.sp
.nf
string[]\ \&get_filesystems(boolean\ \&recursive);
.fi
.sp
.nf
string[]\ \&get_snapshots(boolean\ \&recursive);
.fi
.sp
.nf
destroy(ZfsOpOption[]\ \&options);
.fi
.sp
.nf
rename(string\ \&new_name,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&ZfsOpOption[]\ \&options);
.fi
.sp
.nf
mount(string[]\ \&mount_options,
.
\ \&\ \&\ \&\ \&\ \&\ \&ZfsOpOption[]\ \&options);
.fi
.sp
.nf
unmount(ZfsOpOption[]\ \&options);
.fi
.sp
.nf
rollback(string\ \&snapshot_name,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&ZfsOpOption[]\ \&options);
.fi
.sp
.nf
promote();
.fi
.sp
.nf
set_props(ZfsProp[]\ \&props);
.fi
.sp
.nf
ZfsPropDetail[]\ \&get_props(ZfsPropRequest[]\ \&props);
.fi
.sp
.nf
inherit(ZfsProp[]\ \&props,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&ZfsOpOption[]\ \&options);
.fi
.sp
.nf
SendSocketInfo\ \&get_send_socket(string\ \&name,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&SocketType\ \&socket_type,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&boolean\ \&verify_token,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&ZfsOpOption[]\ \&options);
.fi
.sp
.nf
SendStreamInfo\ \&get_send_stream_info(string\ \&name,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&ZfsOpOption[]\ \&options);
.fi
.sp
.nf
RecvSocketInfo\ \&get_receive_socket(string\ \&name,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&SocketType\ \&socket_type,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&ZfsRecvNameOptions\ \&name_options,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&boolean\ \&verify_token,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&ZfsOpOption[]\ \&options,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&ZfsProp[]\ \&props);
.fi
.SS "interface ZfsSnapshot"
.sp
.nf
.fi
.sp
.nf
ZfsDataset\ \&clone(string\ \&clone_name,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&ZfsProp[]\ \&props,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&ZfsOpOption[]\ \&options);
.fi
.sp
.nf
string[]\ \&get_clones();
.fi
.sp
.nf
ZfsPropDetail[]\ \&get_props(ZfsPropRequest[]\ \&props);
.fi
.sp
.nf
set_props(ZfsProp[]\ \&props);
.fi
.sp
.nf
inherit(ZfsProp[]\ \&props);
.fi
.SS "interface Zpool"
.sp
.nf
.fi
.sp
.nf
ZpoolVdev[]\ \&get_vdevs();
.fi
.sp
.nf
set_props(ZfsProp[]\ \&props);
.fi
.sp
.nf
ZfsPropDetail[]\ \&get_props(ZfsPropRequest[]\ \&props);
.fi
.sp
.nf
ZfsDataset\ \&get_dataset_ref();
.fi
.SS "interface ZfsUtil"
.sp
.nf
.fi
.sp
.nf
boolean\ \&valid_zfs_name(string\ \&name,
.
\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&\ \&boolean\ \&is_snapname);
.fi
.SH "DESCRIPTION"
.PP
\fBapi com\&.oracle\&.solaris\&.rad\&.zfsmgr\fR
.PP
This API provides functionality for management of ZFS storage pools, ZFS datasets and ZFS snapshots\&.
.PP
The following sample Python clients illustrate some simple interactions with the module\&.
.PP
\fBExample\ \&1.\ \&Retrieve the list of zpools on the system. Print out the name and size of each zpool.\fR
.sp
.if n \{\
.RS 4
.\}
.nf
import rad\&.bindings\&.com\&.oracle\&.solaris\&.rad\&.zfsmgr_1 as zfsmgr
import rad\&.connect as radcon

with radcon\&.connect_unix() as rc:
    prop0 = zfsmgr\&.ZfsPropRequest(name="name")

    # get the integer value for size
    prop1 = zfsmgr\&.ZfsPropRequest(name="size", integer_val=True)

    pools = rc\&.list_objects(zfsmgr\&.Zpool())

    for pool in pools:
        pobj = rc\&.get_object(pool)
        pvalues = pobj\&.get_props([prop0, prop1])

        for pv in pvalues:
            print "%s:%s\et%s\en" % (pv\&.name, pv\&.value, str(pv\&.source))
	
.fi
.if n \{\
.RE
.\}
.PP
\fBExample\ \&2.\ \&List all ZFS filesystems in 'rpool', including all descendants.\fR
.sp
.if n \{\
.RS 4
.\}
.nf
import rad\&.bindings\&.com\&.oracle\&.solaris\&.rad\&.zfsmgr_1 as zfsmgr
import rad\&.client as radc
import rad\&.connect as radcon

with radcon\&.connect_unix() as rc:
    name_pattern = radc\&.ADRGlobPattern({"name" : "rpool"})
    rpool_ds_obj = rc\&.get_object(zfsmgr\&.ZfsDataset(), name_pattern)
    all_children = rpool_ds_obj\&.get_filesystems(recursive=True)
    for c in all_children:
            print str(c)
	
.fi
.if n \{\
.RE
.\}
.PP
\fBExample\ \&3.\ \&Destroy a ZFS filesystem called 'rpool/p1'. The 'rpool/p1' filesystem does not have any descendant datasets.\fR
.sp
.if n \{\
.RS 4
.\}
.nf
import rad\&.bindings\&.com\&.oracle\&.solaris\&.rad\&.zfsmgr_1 as zfsmgr
import rad\&.client as radc
import rad\&.connect as radcon

with radcon\&.connect_unix() as rc:
    name_pattern = radc\&.ADRGlobPattern({"name" : "rpool/p1"})
    ds_obj = rc\&.get_object(zfsmgr\&.ZfsDataset(), name_pattern)
    ds_obj\&.destroy()
	
.fi
.if n \{\
.RE
.\}
.PP
\fBExample\ \&4.\ \&Destroy a ZFS filesystem called 'rpool/p2' with descendant datasets. The recurse_filesystems option is specified so that the descendant datasets are destroyed as well.\fR
.sp
.if n \{\
.RS 4
.\}
.nf
import rad\&.bindings\&.com\&.oracle\&.solaris\&.rad\&.zfsmgr_1 as zfsmgr
import rad\&.client as radc
import rad\&.connect as radcon

with radcon\&.connect_unix() as rc:
    name_pattern = radc\&.ADRGlobPattern({"name" : "rpool/p2"})
    zfs_obj = rc\&.get_object(zfsmgr\&.ZfsDataset(), name_pattern)
    zfs_obj\&.destroy(options=[zfsmgr\&.ZfsOpOption\&.recurse_filesystems])
	
.fi
.if n \{\
.RE
.\}
.PP
\fBExample\ \&5.\ \&Create ZFS filesystems 'rpool/p1' and 'rpool/p1/p2'. Create a snapshot called 'snap1' for the 'rpool/p1' dataset and all of its nested datasets.\fR
.sp
.if n \{\
.RS 4
.\}
.nf
import rad\&.bindings\&.com\&.oracle\&.solaris\&.rad\&.zfsmgr_1 as zfsmgr
import rad\&.client as radc
import rad\&.connect as radcon

with radcon\&.connect_unix() as rc:
    name_pattern = radc\&.ADRGlobPattern({"name" : "rpool"})
    rpool_obj = rc\&.get_object(zfsmgr\&.ZfsDataset(), name_pattern)

    p1_obj = rpool_obj\&.create_filesystem(name="rpool/p1")
    p2_obj = rpool_obj\&.create_filesystem(name="rpool/p1/p2")

    my_snap = p1_obj\&.create_snapshot(name="rpool/p1@snap1",
        options=[zfsmgr\&.ZfsOpOption\&.recurse_filesystems]);
	
.fi
.if n \{\
.RE
.\}
.PP
\fBExample\ \&6.\ \&Do a zfs send of rpool/p1@snap, and a zfs receive to create dataset space/recv_ds. An event handler is defined and registered for both zfs send and zfs receive events so we will be notified of the result of operations.\fR
.sp
.if n \{\
.RS 4
.\}
.nf
import socket

import rad\&.bindings\&.com\&.oracle\&.solaris\&.rad\&.zfsmgr_1 as zfsmgr
import rad\&.client as radc
import rad\&.connect as radcon

#
# This is the event handler that will get called for both the
# "zfs_send_status" and "zfs_recv_status" events\&.
#
def handler(event, payload, user):
    print "Event: %s" % str(event)
    print "Operation: %s" % str(payload\&.operation)
    print "Return Code: %s" % str(payload\&.return_code)
    if (payload\&.return_code != 0):
        print "libzfs_errcode: %s" % str(payload\&.libzfs_errcode)
        print "libzfs_errstr: %s" % str(payload\&.libzfs_errstr)

with radcon\&.connect_unix() as rc:

    # get a handle to the "rpool/p1" filesystem
    p1_ds_obj = rc\&.get_object(zfsmgr\&.ZfsDataset(),
        radc\&.ADRGlobPattern({"name" : "rpool/p1"}))

    # get a handle to the "space" filesystem
    space_ds_obj = rc\&.get_object(zfsmgr\&.ZfsDataset(),
        radc\&.ADRGlobPattern({"name" : "space"}))

    # register to listen to events from those two objects
    rc\&.subscribe(p1_ds_obj, "zfs_send_status", handler);
    rc\&.subscribe(space_ds_obj, "zfs_recv_status", handler);

    local_host = socket\&.gethostname()

    # Create a send stream for the rpool/p1@snap snapshot\&. The 
    # data will be sent to the INET socket created by the
    # get_send_socket() call\&.
    send_sock_info = p1_ds_obj\&.get_send_socket(
        name="rpool/p1@snap", socket_type=zfsmgr\&.SocketType\&.AF_INET)
    send_sock = socket\&.socket(socket\&.AF_INET, socket\&.SOCK_STREAM)
    send_sock\&.connect((local_host, int(send_sock_info\&.socket)))

    # Create a new filesystem called space/recv_ds using data from the 
    # read from the INET socket that\'s created by the
    # get_receive_socket() call\&.
    recv_sock_info = space_ds_obj\&.get_receive_socket(
        name="space/recv_ds", socket_type=zfsmgr\&.SocketType\&.AF_INET,
        name_options=zfsmgr\&.ZfsRecvNameOptions\&.use_provided_name)
    recv_sock = socket\&.socket(socket\&.AF_INET, socket\&.SOCK_STREAM)
    recv_sock\&.connect((local_host, int(recv_sock_info\&.socket)))

    buf_size = 1048576 # 1mb
    while True:
        # read the data from the send stream
        buf = send_sock\&.recv(buf_size)
        if not buf:
            break
        # write the data to the receive steam
        recv_sock\&.send(buf)

    recv_sock\&.close()
    send_sock\&.close()

	
.fi
.if n \{\
.RE
.\}
.SH "INTERFACES"
.SS "interface ZfsDataset"
.PP
This object represents a ZFS dataset and contains interfaces for managing ZFS datasets\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBZfsDataset Methods\fR
.RS 4
.PP
\fBZfsDataset\fR
\fBcreate_filesystem\fR(\fBstring\fR\ \&\fIname\fR, \fBZfsProp\fR\fB[]\fR\ \&\fIprops\fR, \fBZfsOpOption\fR\fB[]\fR\ \&\fIoptions\fR)
.RS 4
.PP
Create a ZFS filesystem with the name and properties given\&. It will be mounted according to the mountpoint property inherited from the parent unless a mountpoint is specified in props\&. Upon successful return, the ZfsDataset object may be used directly for ZfsDataset related operations\&.
.PP
\fBArguments:\fR
.PP
\fIname\fR
\(em Name of the new filesystem\&. The filesystem to be created must be a descendant of this ZFS filesystem\&. Intermediate descendants will be created if they do not exist and the create_parent option is specified in options\&.
.PP
\fIprops\fR
(\fInullable\fR) \(em Optional list of name\-value pairs of properties to set\&.
.PP
\fIoptions\fR
(\fInullable\fR) \(em A list of one or more values from the ZfsOpOptions enum\&. This is an optional argument\&. For this operation, the following options are allowed:
.RS 4
.sp
.if n \{\
.RS 4
.\}
.nf
create_parent: create all non\-existing parent datasets\&.
	Equivalent to: zfs create \-p
		
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fBResult:\fR
.PP
\fBZfsDataset\fR
\(em A ZfsDataset object representing the ZFS filesystem that was just created\&.
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.PP
\fBZfsSnapshot\fR
\fBcreate_snapshot\fR(\fBstring\fR\ \&\fIname\fR, \fBZfsProp\fR\fB[]\fR\ \&\fIprops\fR, \fBZfsOpOption\fR\fB[]\fR\ \&\fIoptions\fR)
.RS 4
.PP
Create a snapshot of this ZFS dataset\&.
.PP
\fBArguments:\fR
.PP
\fIname\fR
\(em Name of the snapshot to be created\&.
.PP
\fIprops\fR
(\fInullable\fR) \(em Optional list of name\-value pairs of properties to set\&.
.PP
\fIoptions\fR
(\fInullable\fR) \(em A list of one or more values from the ZfsOpOptions enum\&. This is an optional argument\&. For this operation, the following options are allowed:
.RS 4
.sp
.if n \{\
.RS 4
.\}
.nf
recurse_filesystems: generate snapshots of all child
	datasets\&.  Snapshots will take the name of their
	original dataset, suffixed by "@" and the
	snapshot suffix provided by the "name" argument\&.
	Equivalent to: zfs snapshot \-r
		
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fBResult:\fR
.PP
\fBZfsSnapshot\fR
\(em A ZfsSnapshot object representing the ZFS snapshot created by this call\&.
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.PP
\fBdestroy_snapshot\fR(\fBstring\fR\ \&\fIname\fR, \fBZfsOpOption\fR\fB[]\fR\ \&\fIoptions\fR)
.RS 4
.PP
Destroy the specified snapshot\&.
.PP
\fBArguments:\fR
.PP
\fIname\fR
\(em Name of the snapshot to be destroyed\&.
.PP
\fIoptions\fR
(\fInullable\fR) \(em A list of one or more values from the ZfsOpOptions enum\&. This is an optional argument\&. For this operation, the following options are allowed:
.RS 4
.sp
.if n \{\
.RS 4
.\}
.nf
defer: defer snapshot deletion\&.
	Equivalent to: zfs destroy \-d
recurse_filesystems: destroy all snapshots with
	this name in the descendant filesystems\&.
	Equivalent to: zfs destroy \-r
recurse_dependents: recursively destroy dependents
	Equivalent to: zfs destroy \-R
		
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.PP
\fBrename_snapshot\fR(\fBstring\fR\ \&\fIold_name\fR, \fBstring\fR\ \&\fInew_name\fR, \fBZfsOpOption\fR\fB[]\fR\ \&\fIoptions\fR)
.RS 4
.PP
Rename the specified snapshot\&.
.PP
\fBArguments:\fR
.PP
\fIold_name\fR
\(em Name of the snapshot to be renamed
.PP
\fInew_name\fR
\(em New name for the snapshot
.PP
\fIoptions\fR
(\fInullable\fR) \(em A list of one or more values from the ZfsOpOptions enum\&. This is an optional argument\&. For this operation, the following options are allowed:
.RS 4
.sp
.if n \{\
.RS 4
.\}
.nf
recurse_filesystems: recursively rename the snapshots of
	all descendant datasets\&.
	Equivalent to: zfs rename \-r
		
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.PP
\fBstring[]\fR
\fBget_filesystems\fR(\fBboolean\fR\ \&\fIrecursive\fR)
.RS 4
.PP
Get a list of this dataset\'s descendant ZFS filesystems\&.
.PP
\fBArguments:\fR
.PP
\fIrecursive\fR
(\fInullable\fR) \(em Optional\&. Default is False, which only returns the first level descendant of the filesystem\&. Set this to True to get all descendant filesystems of this ZFS filesystem\&.
.PP
\fBResult:\fR
.PP
\fBstring[]\fR
\(em List of string names of descendant ZFS filesystems\&.
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.PP
\fBstring[]\fR
\fBget_snapshots\fR(\fBboolean\fR\ \&\fIrecursive\fR)
.RS 4
.PP
Get a list of this dataset\'s snapshots\&.
.PP
\fBArguments:\fR
.PP
\fIrecursive\fR
(\fInullable\fR) \(em Optional\&. Default is False, which only returns snapshots of the filesystem\&. Set this to True to get snapshots from all descendant filesystems of this ZFS filesystem\&.
.PP
\fBResult:\fR
.PP
\fBstring[]\fR
\(em List of string names of this dataset\'s snapshots\&.
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.PP
\fBdestroy\fR(\fBZfsOpOption\fR\fB[]\fR\ \&\fIoptions\fR)
.RS 4
.PP
Destroy this ZFS dataset\&. The handle to this dataset will be invalid upon successful return\&.
.PP
\fBArguments:\fR
.PP
\fIoptions\fR
(\fInullable\fR) \(em A list of one or more values from the ZfsOpOptions enum\&. This is an optional argument\&. For this operation, the following options are allowed:
.RS 4
.sp
.if n \{\
.RS 4
.\}
.nf
force_unmount: force unmount of any filesystems\&.
	Equivalent to: zfs destroy \-f
recurse_filesystems: destroy descendant filesystems\&.
	Equivalent to: zfs destroy \-r
recurse_dependents: recursively destroy dependents\&.
	Equivalent to: zfs destroy \-R
		
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.PP
\fBrename\fR(\fBstring\fR\ \&\fInew_name\fR, \fBZfsOpOption\fR\fB[]\fR\ \&\fIoptions\fR)
.RS 4
.PP
Rename this ZFS dataset\&.
.PP
\fBArguments:\fR
.PP
\fInew_name\fR
\(em String containing the new name\&.
.PP
\fIoptions\fR
(\fInullable\fR) \(em A list of one or more values from the ZfsOpOptions enum\&. This is an optional argument\&. For this operation, the following options are allowed:
.RS 4
.sp
.if n \{\
.RS 4
.\}
.nf
create_parent: create all non\-existing parent datasets\&.
	Equivalent to: zfs rename \-p
		
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.PP
\fBmount\fR(\fBstring[]\fR\ \&\fImount_options\fR, \fBZfsOpOption\fR\fB[]\fR\ \&\fIoptions\fR)
.RS 4
.PP
Mount this ZFS dataset\&.
.PP
\fBArguments:\fR
.PP
\fImount_options\fR
(\fInullable\fR) \(em Optional list of of mount options to use for the duration of the mount\&. All mount options allowed for the zfs(1M) mount command can be specified\&. Each option should be specified as a separate string in the list\&.
.PP
\fIoptions\fR
(\fInullable\fR) \(em A list of one or more values from the ZfsOpOptions enum\&. This is an optional argument\&. For this operation, the following options are allowed:
.RS 4
.sp
.if n \{\
.RS 4
.\}
.nf
overlay_mount: perform an overlay mount
	Equivalent to: zfs mount \-O
		
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.PP
\fBunmount\fR(\fBZfsOpOption\fR\fB[]\fR\ \&\fIoptions\fR)
.RS 4
.PP
Unmount this ZFS dataset\&.
.PP
\fBArguments:\fR
.PP
\fIoptions\fR
(\fInullable\fR) \(em A list of one or more values from the ZfsOpOptions enum\&. This is an optional argument\&. For this operation, the following options are allowed:
.RS 4
.sp
.if n \{\
.RS 4
.\}
.nf
force_unmount: force unmount, even if in use\&.
	Equivalent to: zfs unmount \-f
		
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.PP
\fBrollback\fR(\fBstring\fR\ \&\fIsnapshot_name\fR, \fBZfsOpOption\fR\fB[]\fR\ \&\fIoptions\fR)
.RS 4
.PP
Roll this dataset back to the named snapshot\&.
.PP
\fBArguments:\fR
.PP
\fIsnapshot_name\fR
\(em Name of the snapshot to roll back to\&.
.PP
\fIoptions\fR
(\fInullable\fR) \(em A list of one or more values from the ZfsOpOptions enum\&. This is an optional argument\&. For this operation, the following options are allowed:
.RS 4
.sp
.if n \{\
.RS 4
.\}
.nf
force_unmount: force unmount of any filesystems\&.
	Equivalent to: zfs rollback \-f
allow_destroy_snapshots: allow destroying snapshots more
	recent than this one\&.
	Equivalent to: zfs rollback \-r
allow_destroy_clones: allow recursively destroying
	snapshots more recent than this one, plus
	any clones of those snapshots\&.
	Equivalent to: zfs rollback \-R
		
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.PP
\fBpromote\fR()
.RS 4
.PP
Promote this ZFS dataset\&. Dataset must be a clone\&.
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.PP
\fBset_props\fR(\fBZfsProp\fR\fB[]\fR\ \&\fIprops\fR)
.RS 4
.PP
Set ZFS dataset properties\&.
.PP
\fBArguments:\fR
.PP
\fIprops\fR
\(em List of properties to set\&.
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
\(em The ZfsRADError contains information about the first property that can not be set\&. No subsequent properties in the list will be set after the first failure\&.
.RE
.PP
\fBZfsPropDetail\fR\fB[]\fR
\fBget_props\fR(\fBZfsPropRequest\fR\fB[]\fR\ \&\fIprops\fR)
.RS 4
.PP
Get ZFS dataset property information\&.
.PP
\fBArguments:\fR
.PP
\fIprops\fR
\(em List of properties to get\&.
.PP
\fBResult:\fR
.PP
\fBZfsPropDetail\fR\fB[]\fR
\(em List of ZfsPropDetail objects, one for each property requested in the get_props() function call\&. The ZfsPropDetail object contains name, value, source and error fields\&. Their values are set based on the result of getting each property\&. If the property was successfully retrieved, then the name, value and source will have appropriate values and error will be None\&. If the property is valid, but does not have a value, then the name field is set to the name of the requested property, and all other fields will be None\&. If the property was not successfully retrieved, the name field is set to the name of the requested property, and the error field will be set with details on the error\&.
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
\(em Returns any error not specific to getting property values\&. Errors related to getting a specific property value are included in the property detail structure that is returned\&.
.RE
.PP
\fBinherit\fR(\fBZfsProp\fR\fB[]\fR\ \&\fIprops\fR, \fBZfsOpOption\fR\fB[]\fR\ \&\fIoptions\fR)
.RS 4
.PP
Clears the specified properties, causing them to be inherited from an ancestor\&. If no ancestor has the property set, then the default value is used\&.
.PP
\fBArguments:\fR
.PP
\fIprops\fR
\(em List of properties to clear\&. Only the name field of the ZfsProp structure is used\&.
.PP
\fIoptions\fR
(\fInullable\fR) \(em A list of one or more values from the ZfsOpOptions enum\&. This is an optional argument\&. For this operation, the following options are allowed:
.RS 4
.sp
.if n \{\
.RS 4
.\}
.nf
recurse_filesystems: recursively inherits the
	given properties for all children
	Equivalent to: zfs inherit \-r
revert_received: Reverts to the received property
	value, if any\&.  
	Equivalent to: zfs inherit \-S
		
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.PP
\fBSendSocketInfo\fR
\fBget_send_socket\fR(\fBstring\fR\ \&\fIname\fR, \fBSocketType\fR\ \&\fIsocket_type\fR, \fBboolean\fR\ \&\fIverify_token\fR, \fBZfsOpOption\fR\fB[]\fR\ \&\fIoptions\fR)
.RS 4
.PP
Open a socket for sending the stream representation of the specified ZfsSnapshot\&. This is similar to the "zfs send" command\&. Only functionality provided by \-r, \-R, \-C and \-p from the "zfs send" command is supported\&. Incremental streams are not supported\&.
.PP
\fBArguments:\fR
.PP
\fIname\fR
\(em Name of the snapshot to be sent\&.
.PP
\fIsocket_type\fR
\(em The type of socket to create
.PP
\fIverify_token\fR
(\fInullable\fR) \(em Specify whether token verification is required before data is sent\&. This is an optional argument\&. If not specified, it defaults to False, which means a client can connect to the port and start receiving the zfs send stream\'s data without sending the generated token returned in this call\&.
.PP
\fIoptions\fR
(\fInullable\fR) \(em A list of one or more values from the ZfsOpOptions enum\&. This is an optional argument\&. For this operation, the following options are allowed:
.RS 4
.sp
.if n \{\
.RS 4
.\}
.nf
recurse_filesystems: Generates a recursive stream 
	package\&.  A recursive stream package contains
	a series of full and/or incremental streams\&. 
	When received,  all properties and descendant file 
	systems are preserved\&.
	Equivalent to: zfs send \-r
self_contained: Creates a self\-contained stream\&.
	Valid only with the recurse_filesystems option\&.
	Equivalent to: zfs send \-C
send_props: Sends properties\&.
	Equivalent to: zfs send \-p
recurse_dependents: Generates a replication stream package
	that replicates the specified filesystem and
	all descendant filesystems\&.
	Equivalent to: zfs send \-R
		
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fBResult:\fR
.PP
\fBSendSocketInfo\fR
\(em SendSocketInfo structure containing information about the send stream, and the socket to use for the connection
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.PP
\fBSendStreamInfo\fR
\fBget_send_stream_info\fR(\fBstring\fR\ \&\fIname\fR, \fBZfsOpOption\fR\fB[]\fR\ \&\fIoptions\fR)
.RS 4
.PP
Get information about the ZFS stream that would be generated with the options provided without actually creating the stream\&.
.PP
\fBArguments:\fR
.PP
\fIname\fR
\(em Name of the snapshot to get send information from
.PP
\fIoptions\fR
(\fInullable\fR) \(em A list of one or more values from the ZfsOpOptions enum\&. This is an optional argument\&. For this operation, the following options are allowed:
.RS 4
.sp
.if n \{\
.RS 4
.\}
.nf
recurse_filesystems: Generates a recursive stream 
	package\&.  A recursive stream package contains
	a series of full and/or incremental streams\&. 
	When received,  all properties and descendant file 
	systems are preserved\&.
	Equivalent to: zfs send \-r
self_contained: Creates a self\-contained stream\&.
	Valid only with the recurse_filesystems option\&.
	Equivalent to: zfs send \-C
send_props: Sends properties\&.
	Equivalent to: zfs send \-p
recurse_dependents: Generates a replication stream package
	that replicates the specified filesystem and
	all descendant filesystems\&.
	Equivalent to: zfs send \-R
		
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fBResult:\fR
.PP
\fBSendStreamInfo\fR
\(em SendStreamInfo structure containing information about the snapshots that would be sent as well as the estimated size of the stream\&.
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.PP
\fBRecvSocketInfo\fR
\fBget_receive_socket\fR(\fBstring\fR\ \&\fIname\fR, \fBSocketType\fR\ \&\fIsocket_type\fR, \fBZfsRecvNameOptions\fR\ \&\fIname_options\fR, \fBboolean\fR\ \&\fIverify_token\fR, \fBZfsOpOption\fR\fB[]\fR\ \&\fIoptions\fR, \fBZfsProp\fR\fB[]\fR\ \&\fIprops\fR)
.RS 4
.PP
Open a socket to receive the data for creating a ZfsSnapshot or a ZfsDataset\&. Depending on the options specified, and whether the provided stream is a full stream or an incremental stream, the dataset will be modified differently\&. If the incoming stream is a full stream, and the specified dataset does not exist, the incoming stream will be received into a newly created dataset that is a descendant of this dataset\&. Otherwise, the incoming stream will modify this dataset based on user specified options\&.
.PP
\fBArguments:\fR
.PP
\fIname\fR
\(em Name of ZFS dataset or snapshot to create from the received stream of data\&.
.RS 4
.PP
The provided dataset name or the top level dataset of the provided name must match the name of this dataset\&.
.RE
.PP
\fIsocket_type\fR
\(em Type of socket to create\&.
.PP
\fIname_options\fR
\(em Specifies how the final name used for the ZfsSnapshot or ZfsDataset should be derived\&.
.PP
\fIverify_token\fR
(\fInullable\fR) \(em Specify whether token verification is required before data is received\&. This is an optional argument\&. If not specified, it defaults to False, which means a client can connect to the port and start sending the data to the zfs receive stream without first sending the generated token returned in this call\&.
.PP
\fIoptions\fR
(\fInullable\fR) \(em A list of one or more values from the ZfsOpOptions enum\&. This is an optional argument\&. For this operation, the following options are allowed:
.RS 4
.sp
.if n \{\
.RS 4
.\}
.nf
force_rollback: Forces a rollback of the filesystem 
	to the most recent snapshot before performing
	the receive operation\&.
	Equivalent to: zfs receive \-F
do_not_mount: File system that is associated with
	the received stream is not mounted\&.
	Equivalent to: zfs receive \-u
		
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fIprops\fR
(\fInullable\fR) \(em Optional list of name\-value pairs of properties to set\&. If a "name" property is included, it must match the "name" argument\&.
.PP
\fBResult:\fR
.PP
\fBRecvSocketInfo\fR
\(em SocketInfo structure with information for socket to use for the connection\&.
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBZfsDataset Events\fR
.RS 4
.PP
\fBZfsSendRecvStatus\fR\ \&\fBzfs_send_status\fR
.PP
\fBZfsSendRecvStatus\fR\ \&\fBzfs_recv_status\fR
.RE
.SS "interface ZfsSnapshot"
.PP
This object represents a ZFS snapshot and contains interfaces for managing ZFS snapshots\&. This object does not provide an interface for creating snapshots\&. Snapshot creation should be done by calling ZfsDataset\'s create_snapshot() interface\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBZfsSnapshot Methods\fR
.RS 4
.PP
\fBZfsDataset\fR
\fBclone\fR(\fBstring\fR\ \&\fIclone_name\fR, \fBZfsProp\fR\fB[]\fR\ \&\fIprops\fR, \fBZfsOpOption\fR\fB[]\fR\ \&\fIoptions\fR)
.RS 4
.PP
Clone a dataset from this snapshot\&.
.PP
\fBArguments:\fR
.PP
\fIclone_name\fR
\(em Name of the new dataset\&.
.PP
\fIprops\fR
(\fInullable\fR) \(em Optional list of name\-value pairs of properties to set in the clone\&. If a "name" property is included, it must match the "name" argument\&. Equivalent to: zfs clone \-o
.PP
\fIoptions\fR
(\fInullable\fR) \(em A list of one or more values from the ZfsOpOptions enum\&. This is an optional argument\&. For this operation, the following option is allowed:
.RS 4
.sp
.if n \{\
.RS 4
.\}
.nf
create_parent: create all non\-existing parent datasets
	of the clone\&.  Equivalent to: zfs clone \-p
		
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fBResult:\fR
.PP
\fBZfsDataset\fR
\(em A ZfsDataset object representing the ZFS dataset created from cloning this snapshot\&.
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.PP
\fBstring[]\fR
\fBget_clones\fR()
.RS 4
.PP
Get all the datasets that are clones of this snapshot\&.
.PP
\fBResult:\fR
.PP
\fBstring[]\fR
\(em List of clone dataset names\&.
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.PP
\fBZfsPropDetail\fR\fB[]\fR
\fBget_props\fR(\fBZfsPropRequest\fR\fB[]\fR\ \&\fIprops\fR)
.RS 4
.PP
Get ZFS snapshot property information\&.
.PP
\fBArguments:\fR
.PP
\fIprops\fR
\(em List of properties to get\&.
.PP
\fBResult:\fR
.PP
\fBZfsPropDetail\fR\fB[]\fR
\(em List of ZfsPropDetail objects, one for each property requested in the get_props() function call\&. The ZfsPropDetail object contains name, value, source and error fields\&. Their values are set based on the result of getting each property\&. If the property was successfully retrieved, then the name, value and source will have appropriate values and error will be None\&. If the property is valid, but does not have a value, then the name field is set to the name of the requested property, and all other fields will be None\&. If the property was not successfully retrieved, the name field is set to the name of the requested property, and the error field will be set with details on the error\&.
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
\(em Returns any error not specific to getting property values\&. Errors related to getting a specific property value are included in the property detail structure that is returned\&.
.RE
.PP
\fBset_props\fR(\fBZfsProp\fR\fB[]\fR\ \&\fIprops\fR)
.RS 4
.PP
Set ZFS snapshot properties\&.
.PP
\fBArguments:\fR
.PP
\fIprops\fR
\(em List of properties to set\&.
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
\(em The ZfsRADError contains information about the first property that can not be set\&. No subsequent properties in the list will be set after the first failure\&.
.RE
.PP
\fBinherit\fR(\fBZfsProp\fR\fB[]\fR\ \&\fIprops\fR)
.RS 4
.PP
Clears the specified properties, causing them to be inherited from an ancestor\&. If no ancestor has the property set, then the default value is used\&.
.PP
\fBArguments:\fR
.PP
\fIprops\fR
\(em List of properties to clear\&. Only the name field of the ZfsProp structure is used\&.
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.RE
.SS "interface Zpool"
.PP
Zpools are assumed to already exist on the system\&. Thus, the Zpool interfaces limit zpool operations to listing vdev configuration and getting/setting zpool properties\&. Note that there is no get_filesystems() method\&. The root dataset\'s get_filesystems() method should be used to get all filesystems in a zpool\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBZpool Methods\fR
.RS 4
.PP
\fBZpoolVdev\fR\fB[]\fR
\fBget_vdevs\fR()
.RS 4
.PP
Return the vdev configuration of this zpool\&.
.PP
\fBResult:\fR
.PP
\fBZpoolVdev\fR\fB[]\fR
\(em A list of ZpoolVdev structs\&.
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.PP
\fBset_props\fR(\fBZfsProp\fR\fB[]\fR\ \&\fIprops\fR)
.RS 4
.PP
Set Zpool properties\&.
.PP
\fBArguments:\fR
.PP
\fIprops\fR
\(em List of properties to set\&.
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
\(em The ZfsRADError contains information about the first property that can not be set\&. No subsequent properties in the list will be set after the first failure\&.
.RE
.PP
\fBZfsPropDetail\fR\fB[]\fR
\fBget_props\fR(\fBZfsPropRequest\fR\fB[]\fR\ \&\fIprops\fR)
.RS 4
.PP
Get Zpool property information\&.
.PP
\fBArguments:\fR
.PP
\fIprops\fR
\(em List of properties to get\&.
.PP
\fBResult:\fR
.PP
\fBZfsPropDetail\fR\fB[]\fR
\(em List of ZfsPropDetail objects, one for each property requested in the get_props() function call\&. The ZfsPropDetail object contains name, value, source and error fields\&. Their values are set based on the result of getting each property\&. If the property was successfully retrieved, then the name, value and source will have appropriate values and error will be None\&. If the property is valid, but does not have a value, then the name field is set to the name of the requested property, and all other fields will be None\&. If the property was not successfully retrieved, the name field is set to the name of the requested property, and the error field will be set with details on the error\&.
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
\(em Returns any error not specific to getting property values\&. Errors related to getting a specific property value are included in the property detail structure that is returned\&.
.RE
.PP
\fBZfsDataset\fR
\fBget_dataset_ref\fR()
.RS 4
.PP
Return a reference to a ZfsDataset object representing this zpool\&.
.PP
\fBResult:\fR
.PP
\fBZfsDataset\fR
\(em A ZfsDataset object representing this zpool\&.
.PP
\fBError:\fR
.PP
\fBZfsRADError\fR
.RE
.RE
.SS "interface ZfsUtil"
.PP
This is a singleton instance providing ZFS functionality that is unrelated to Zpool, ZfsDataset or ZfsSnapshot\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBZfsUtil Methods\fR
.RS 4
.PP
\fBboolean\fR
\fBvalid_zfs_name\fR(\fBstring\fR\ \&\fIname\fR, \fBboolean\fR\ \&\fIis_snapname\fR)
.RS 4
.PP
Check whether the specified string can be used as a ZFS name
.PP
\fBArguments:\fR
.PP
\fIname\fR
.PP
\fIis_snapname\fR
(\fInullable\fR) \(em Optional\&. Specify whether the name to be verified is a snapshot name or not\&. If not specified, the provided name is assumed to be a dataset name\&.
.PP
\fBResult:\fR
.PP
\fBboolean\fR
\(em True will be returned if the given name can be used as a ZFS name\&. False will be returned otherwise\&.
.RE
.RE
.SH "ENUMERATED TYPES"
.PP
\fBenum PropSrc\fR
\(em The source for ZFS/Zpool property value\&.
.RS 4
.PP
src_local
(0) \(em property source: local
.PP
src_default
(1) \(em property source: default
.PP
src_temporary
(2) \(em property source: temporary
.PP
src_received
(3) \(em property source: received
.PP
src_inherited
(4) \(em property source: inherited
.PP
src_none
(5) \(em property source: none
.RE
.PP
\fBenum ZfsOpOption\fR
\(em Options for ZfsDataset/Zpool/ZfsSnapshot operations\&.
.RS 4
.PP
These options do not apply to all operations\&. See the actual API for a description of which options are allowed\&.
.RE
.RS 4
.PP
create_parent
(0) \(em create all non\-existing parent datasets
.PP
recurse_filesystems
(1) \(em perform the specified operation recursively on all descendants of the given filesystems\&. Similar to \-r in zfs(1M)
.PP
recurse_dependents
(2) \(em perform the specified operation recursively on all dependents of the given filesystems\&. Similar to \-R in zfs(1M)
.PP
defer
(3) \(em defer deletion of the given snapshot
.PP
overlay_mount
(4) \(em perform an overlay mount
.PP
force_unmount
(5) \(em force unmount of any mounted filesystems
.PP
force_rollback
(6) \(em force rollback of a filesystem
.PP
do_not_mount
(7) \(em do not mount the filesystem that is associated with the received stream
.PP
send_props
(8) \(em send the properties in the "zfs send" stream
.PP
self_contained
(9) \(em create a self\-contained "zfs send" stream
.PP
revert_received
(10) \(em revert to the received property value, if any
.PP
allow_destroy_snapshots
(11) \(em allow destruction of snapshots in a rollback operation
.PP
allow_destroy_clones
(12) \(em allow destruction of clones in a rollback operation
.RE
.PP
\fBenum ZfsRecvNameOptions\fR
\(em Options to control how the name of the ZfsSnapshot or ZfsDataset from the
get_receive_socket
function is generated\&.
.RS 4
.PP
use_provided_name
(0) \(em Use the snapshot or dataset name exactly as provided\&.
.PP
use_all_but_pool_name
(1) \(em All but the pool name of the sent snapshot path is appended to the string provided in the name argument\&. Equivalent to the \-d option in the zfs receive subcommand\&.
.PP
use_tail_only
(2) \(em Only the tail of the sent snapshot path is appended to the string provided in the name argument\&. Equivalent to the \-e option in the zfs receive subcommand\&.
.RE
.PP
\fBenum ZfsRADErrType\fR
\(em Error types
.RS 4
.PP
libzfs_err
(0) \(em Errors from libzfs calls made by the ZFS RAD module
.PP
zfsrad_err
(1) \(em Errors from the ZFS RAD module
.PP
operation_err
(2) \(em Errors from the requested operation
.RE
.PP
\fBenum SocketType\fR
\(em Socket types that can be created for zfs send/receive\&.
.RS 4
.PP
AF_UNIX
(0) \(em Unix domain socket
.PP
AF_INET
(1) \(em networking socket
.RE
.SH "STRUCTURE TYPES"
.PP
\fBstruct ZfsRADError\fR
\(em Contains information about an error that occurred in the ZFS RAD module\&.
.RS 4
.PP
The err_type field indicates the type of error\&. Certain fields in this object are only used for certain error types\&. See each field for details\&.
.RE
.RS 4
.PP
\fBFields:\fR
.PP
\fBZfsRADErrType\fR\ \&\fIerr_type\fR
.RS 4
.PP
Contains information about the type of error
.RE
.PP
\fBinteger\fR\ \&\fIlibzfs_errcode\fR
.RS 4
.PP
libzfs Error code (enumerated type)\&. This is only used for "libzfs_err" type\&.
.RE
.PP
\fBstring\fR\ \&\fIlibzfs_errstr\fR
(\fInullable\fR)
.RS 4
.PP
Error string corresponding to libzfs error code\&. This is only used for "libzfs_err" type\&.
.RE
.PP
\fBstring\fR\ \&\fIinfo\fR
(\fInullable\fR)
.RS 4
.PP
For "zfsrad_err" error type, this field contains detailed information about the error\&. For "libzfs_err", and "operation_err" error type, this field might contain additional information about the condition under which the error occurred\&.
.RE
.PP
\fBstring\fR\ \&\fIlocation\fR
(\fInullable\fR)
.RS 4
.PP
Returns the function where the error occurred\&.
.RE
.RE
.PP
\fBstruct ZfsProp\fR
\(em Structure for specifying ZFS property information\&.
.RS 4
.PP
\fBFields:\fR
.PP
\fBstring\fR\ \&\fIname\fR
.RS 4
.PP
Property name
.RE
.PP
\fBstring\fR\ \&\fIvalue\fR
.RS 4
.PP
Property value
.RE
.RE
.PP
\fBstruct ZfsPropDetail\fR
\(em Structure for returning ZFS property information by the get_props() functions\&.
.RS 4
.PP
\fBFields:\fR
.PP
\fBstring\fR\ \&\fIname\fR
.RS 4
.PP
Property name
.RE
.PP
\fBstring\fR\ \&\fIvalue\fR
(\fInullable\fR)
.RS 4
.PP
Property value \- If the property is valid, but there is no value defined for the property, the value will be None\&.
.RE
.PP
\fBPropSrc\fR\ \&\fIsource\fR
.RS 4
.PP
The source of the property (similar to what is returned by the get subcommand for zfs(1M))\&.
.RE
.PP
\fBZfsRADError\fR\ \&\fIerror\fR
(\fInullable\fR)
.RS 4
.PP
If this is not set, it means the value retrieved by the get_prop() function is successful\&. If there is any problem with retrieving the property, this will contain the error information\&.
.RE
.RE
.PP
\fBstruct ZfsPropRequest\fR
\(em Structure used for requesting ZFS property information for the get_props() functions\&.
.RS 4
.PP
\fBFields:\fR
.PP
\fBstring\fR\ \&\fIname\fR
.RS 4
.PP
Property name
.RE
.PP
\fBboolean\fR\ \&\fIpersistent\fR
(\fInullable\fR)
.RS 4
.PP
Specify whether the get_props() request should return the persistent value of the property or not\&. This is an optional argument\&. If not specified, this defaults to False, and the effective value of the property will be returned\&. If this is set to True, the "received" field for this property request may not have the value of True\&.
.RE
.PP
\fBboolean\fR\ \&\fIreceived\fR
(\fInullable\fR)
.RS 4
.PP
Specify whether the get_props() request should return the received value of the property or not\&. This is an optional argument\&. If not specified, this defaults to False, and the effective value of the property will be returned\&. If this is set to True, the "persistent" field for this property request may not have the value of True\&.
.RE
.PP
\fBboolean\fR\ \&\fIinteger_val\fR
(\fInullable\fR)
.RS 4
.PP
Specify whether the get property request should return the requested property\'s value in integer format\&. This is an optional argument\&. If not specified, this defaults to False, and the returned value will be in string format\&.
.RE
.RE
.PP
\fBstruct SendStreamInfo\fR
\(em Contains information about the stream that will be generated\&.
.RS 4
.PP
\fBFields:\fR
.PP
\fBstring\fR\ \&\fIsize\fR
.RS 4
.PP
Estimated size of the stream to be generated\&. The data type is a string instead of a integer because the size might be bigger than a 32 bit integer\&.
.RE
.PP
\fBstring[]\fR\ \&\fIsnapshot_info\fR
.RS 4
.PP
List of information about the send stream\&.
.RE
.RE
.PP
\fBstruct SendSocketInfo\fR
\(em Contains information about the socket to be used for the ZFS stream\&.
.RS 4
.PP
\fBFields:\fR
.PP
\fBstring\fR\ \&\fItoken\fR
(\fInullable\fR)
.RS 4
.PP
Token used to confirm that the connection is valid\&.
.RE
.PP
\fBstring\fR\ \&\fIsocket\fR
.RS 4
.PP
If the requested socket type is a UNIX domain socket, then this will be the path to the socket file\&. If the requested socket type is an INET socket, then the value will be the connection port number\&.
.RE
.PP
\fBSendStreamInfo\fR\ \&\fIstream_info\fR
.RS 4
.PP
Information about the send stream\&.
.RE
.RE
.PP
\fBstruct RecvSocketInfo\fR
\(em Contains information about the socket to be used for the ZFS stream\&.
.RS 4
.PP
\fBFields:\fR
.PP
\fBstring\fR\ \&\fItoken\fR
(\fInullable\fR)
.RS 4
.PP
Token used to confirm that the connection is valid\&.
.RE
.PP
\fBstring\fR\ \&\fIsocket\fR
.RS 4
.PP
If the requested socket type is a UNIX domain socket, then this will be the path to the socket file\&. If the requested socket type is an INET socket, then the value will be the connection port number\&.
.RE
.RE
.PP
\fBstruct ZpoolVdev\fR
\(em Zpool Vdev configuration information\&.
.RS 4
.PP
\fBFields:\fR
.PP
\fBstring\fR\ \&\fItype\fR
.RS 4
.PP
Type of the Vdev\&. Only types "mirror", "disk" and "file" are supported at this time\&.
.RE
.PP
\fBstring[]\fR\ \&\fIdevices\fR
.RS 4
.PP
A list of devices making up this Vdev
.RE
.RE
.PP
\fBstruct ZfsSendRecvStatus\fR
\(em Return status of the send/receive operation\&.
.RS 4
.PP
\fBFields:\fR
.PP
\fBstring\fR\ \&\fIoperation\fR
.RS 4
.PP
Indicates whether this is a "send" or "receive" operation\&.
.RE
.PP
\fBinteger\fR\ \&\fIreturn_code\fR
.RS 4
.PP
The return code from the zfs_send() or zfs_receive() call\&.
.RE
.PP
\fBinteger\fR\ \&\fIlibzfs_errcode\fR
.RS 4
.PP
libzfs\&.so error code as defined in /usr/include/libzfs\&.h\&. This is only used if there is an error\&.
.RE
.PP
\fBstring\fR\ \&\fIlibzfs_errstr\fR
(\fInullable\fR)
.RS 4
.PP
Error string corresponding to libzfs error code\&. This is only used if there is an error\&.
.RE
.PP
\fBstring\fR\ \&\fIinfo\fR
(\fInullable\fR)
.RS 4
.PP
Optional field for additional information for the client\&.
.RE
.RE
.PP
\fBVersion:\fR
(1\&.0)
