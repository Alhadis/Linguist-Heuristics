'\" te
.TH TIFFRGBAImage 3tiff "05 Apr 2004" "" ""
.SH "NAME"
TIFFRGBAImage, TIFFRGBAImageBegin, TIFFRGBAImageEnd, TIFFRGBAImageGet, TIFFRGBAImageOK, TIFFRGBAImageOriented \- read and decode an image into a raster
.SH "SYNOPSIS"
.sp
.nf
\f(CW#include <tiffio\&.h>
typedef unsigned char TIFFRGBValue;
typedef struct _TIFFRGBAImage TIFFRGBAImage;
int TIFFRGBAImageOK(TIFF* tif, char emsg[1024]);
int TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int stopOnError, char emsg[1024]);
int TIFFRGBAImageGet(TIFFRGBAImage* img, uint32* raster, uint32 width, uint32 height);
void TIFFRGBAImageEnd(TIFFRGBAImage* img);\fR
.fi
.sp
.SH ""
.PP
The routines described here provide a high-level interface through which
TIFF images may be read into memory\&. Images may be strip- or tile-based and
have a variety of different characteristics: bits/sample, samples/pixel, photometric,
and so on\&. Decoding state is encapsulated in a \fBTIFFRGBAImage\fR
structure, which makes it possible to capture state for multiple images and
quickly switch between them\&. The target raster format can be customized to
the needs of a particular application by installing custom routines that manipulate
image data according to application requirements\&.
.PP
The default usage of these routines is as follows:
.br
.sp
1.
.mk
.in +4
.rt
Use \fBTIFFRGBAImageOK\fR to check whether an
image can be processed\&.
.sp
.in -4
.br
.sp
2.
.mk
.in +4
.rt
Use \fBTIFFRGBAImageBegin\fR to construct a decoder
state block\&.
.sp
.in -4
.br
.sp
3.
.mk
.in +4
.rt
Use \fBTIFFRGBAImageGet\fR to read and decode
an image into a target raster\&.
.sp
.in -4
.br
.sp
4.
.mk
.in +4
.rt
Use \fBTIFFRGBAImageEnd\fR to release resources\&.
.sp
.in -4
.PP
\fBTIFFRGBAImageGet\fR can be called multiple times to
decode an image using different state parameters\&. If multiple images are
to be displayed and there is not enough space for each of the decoded rasters,
multiple state blocks can be managed and then calls can be made to \fBTIFFRGBAImageGet\fR as needed to display an image\&.
.PP
The generated raster is assumed to be an array of \fIwidth\fR times \fIheight\fR 32-bit entries, where \fIwidth\fR must be less than or equal to the width of the image,
and \fIheight\fR may be any non-zero size\&. If the raster
dimensions are smaller than the image, the image data is cropped to the raster
bounds\&. If the raster height is greater than that of the image, then the image
data is placed in the lower part of the raster\&. Note that the raster is assumed
to be organized such that the pixel at location (\fIx,y\fR)
is \fIraster[y*width+x]\fR, with the raster origin in
the bottom-left corner\&.
.SH "EXTENDED DESCRIPTION"
.PP
Raster pixels are 8-bit packed red, green, blue, alpha samples\&. The
macros \fBTIFFGetR\fR, \fBTIFFGetG\fR, \fBTIFFGetB\fR, and \fBTIFFGetA\fR should be used to access
individual samples\&. Images without Associated Alpha matting information have
a constant Alpha of 1\&.0 (255)\&.
.PP
\fBTIFFRGBAImageGet\fR converts non-8-bit images by scaling
sample values\&. Palette, grayscale, bilevel, CMYK, and YCbCr images are converted
to RGB transparently\&. Raster pixels are returned uncorrected by any colorimetry
information present in the directory\&.
.PP
The parameter \fBstopOnError\fR specifies how to act if
an error is encountered while reading the image\&. If \fBstopOnError\fR
is non-zero, then an error terminates the operation\&. Otherwise, \fBTIFFRGBAImageGet\fR continues to process data until all of the possible
data in the image has been requested\&.
.SS "Alternate Raster Formats"
.PP
To use the core support for reading and processing TIFF images, but
write the resulting raster data in a different format, you need only override
the "put methods" used to store raster data\&. These methods are
defined in the \fBTIFFRGBAImage\fR structure and initially set
up by \fBTIFFRGBAImageBegin\fR to point to routines that pack
raster data in the default ABGR pixel format\&. 
.PP
Two different routines are used according to the physical organization
of the image data in the file:
.sp
.in +2
\(bu
.mk
.in +3
.rt
PlanarConfiguration=1 (packed samples)
.sp
.in -3
\(bu
.mk
.in +3
.rt
PlanarConfiguration=2 (separated samples)\&. 
.sp
.in -3
.in -2
.PP
Note that this mechanism can be used to transform the data before storing
the data in the raster\&. For example, you can convert data to colormap indices
for display on a colormap display\&.
.SS "Simultaneous Raster Store and Display"
.PP
An image can be displayed as the image is being into memory by overriding
the put methods as described above to support alternate raster formats\&. Simply
keep a reference to the default put methods set up by \fBTIFFRGBAImageBegin\fR and then invoke these methods before or after each display operation\&.
For example, the \fBtiffgt(1)\fR utility uses the following put
method to update the display as the raster is being filled:
.sp
.nf
\f(CWstatic void
putContigAndDraw(TIFFRGBAImage* img, uint32* raster,
    uint32 x, uint32 y, uint32 w, uint32 h,
    int32 fromskew, int32 toskew,
    unsigned char* cp)
{
    (*putContig)(img, raster, x, y, w, h, fromskew, toskew, cp);
    if (x+w == width) {
     w = width;
     if (img->orientation == ORIENTATION_TOPLEFT)
         lrectwrite(0, y-(h-1), w-1, y, raster-x-(h-1)*w);
     else
         lrectwrite(0, y, w-1, y+h-1, raster);
    }
}
\fR
.fi
.sp
.PP
The original routine provided by the library is saved in the variable \fBputContig\fR\&.
.SS "Supporting Additional TIFF Formats"
.PP
The \fBTIFFRGBAImage\fR routines support the most commonly
encountered flavors of TIFF\&. You can extend this support by overriding the "get
method" invoked by \fBTIFFRGBAImageGet\fR to read TIFF
image data\&. Details of how to do this can be quite involved, it is best to
make a copy of an existing get method and modify to suit the needs of an application\&.
.SS "Diagnostics"
.PP
All error messages are directed to the \fBTIFFError(3tiff)\fR
routine\&.
.sp
.ne 2
.mk
\fBSorry, can not handle %d-bit pictures\&.\fR
.sp .6
.in +4
The image has a \fBBitsPerSample\fR value other than 1,
2, 4, 8, or 16\&.
.sp
.sp 1
.in -4
.sp
.ne 2
.mk
\fBSorry, can not handle %d-channel images\&.\fR
.sp .6
.in +4
The image has a \fBSamplesPerPixel\fR value other than
1, 3, or 4\&.
.sp
.sp 1
.in -4
.sp
.ne 2
.mk
\fBMissing needed "PhotometricInterpretation" tag\&.\fR
.sp .6
.in +4
The image does not have a tag that describes how to display
the data\&.
.sp
.sp 1
.in -4
.sp
.ne 2
.mk
\fBNo "PhotometricInterpretation" tag, assuming RGB\&.\fR
.sp .6
.in +4
The image does not have a tag that describes how to display
the data, but is assumed to be RGB because the image has 3 or 4 samples/pixel\&.
.sp
.sp 1
.in -4
.sp
.ne 2
.mk
\fBNo "PhotometricInterpretation" tag, assuming min-is-black\&.\fR
.sp .6
.in +4
The image does not have a tag that describes how to
display the data, but is assumed to be a grayscale or bilevel image because
the image has 1 sample/pixel\&.
.sp
.sp 1
.in -4
.sp
.ne 2
.mk
\fBNo space for photometric conversion table\&.\fR
.sp .6
.in +4
There is insufficient memory for a table needed to convert image samples
to 8-bit RGB\&.
.sp
.sp 1
.in -4
.sp
.ne 2
.mk
\fBMissing required "Colormap" tag\&.\fR
.sp .6
.in +4
A Palette image does not have a required \fBColormap\fR tag\&.
.sp
.sp 1
.in -4
.sp
.ne 2
.mk
\fBNo space for tile buffer\&.\fR
.sp .6
.in +4
There
is insufficient memory to allocate an i/o buffer\&.
.sp
.sp 1
.in -4
.sp
.ne 2
.mk
\fBNo space for strip buffer\&.\fR
.sp .6
.in +4
There
is insufficient memory to allocate an i/o buffer\&.
.sp
.sp 1
.in -4
.sp
.ne 2
.mk
\fBCan not handle format\&.\fR
.sp .6
.in +4
The image
has a format (combination of \fBBitsPerSample\fR, \fBSamplesPerPixel\fR, and \fBPhotometricInterpretation\fR) that \fBTIFFReadRGBAImage\fR cannot process\&.
.sp
.sp 1
.in -4
.sp
.ne 2
.mk
\fBNo space for B&W mapping table\&.\fR
.sp .6
.in +4
There is insufficient memory to allocate a table needed to map grayscale data
to RGB\&.
.sp
.sp 1
.in -4
.sp
.ne 2
.mk
\fBNo space for Palette mapping table\&.\fR
.sp .6
.in +4
There is insufficient memory to allocate a table needed to map data to 8-bit
RGB\&.
.sp
.sp 1
.in -4
.SH ""
.PP
All routines return 1 if the operation was successful\&. Otherwise, 0
is returned if an error was encountered and \fBstopOnError\fR
is zero\&.
.SH ""
.PP
See \fBattributes\fR(5)
for descriptions of the following attributes:
.sp
.TS
tab() allbox;
cw(2.750000i)| cw(2.750000i)
lw(2.750000i)| lw(2.750000i).
ATTRIBUTE TYPEATTRIBUTE VALUE
Availabilityimage/library/libtiff
Interface stabilityUncommitted
.TE
.sp
.SH ""
.PP
\fBlibtiff\fR(3), \fBTIFFOpen\fR(3tiff), \fBTIFFReadRGBAImage\fR(3tiff), \fBTIFFReadRGBAStrip\fR(3tiff), \fBTIFFReadRGBATile\fR(3tiff)
.SH ""
.PP
Samples must be either 1, 2, 4, 8, or 16 bits\&. Colorimetric samples/pixel
must be either 1, 3, or 4 (that is, \fBSamplesPerPixel\fR minus \fBExtraSamples\fR)\&.
.PP
Palette image colormaps that appear to be incorrectly written as 8-bit
values are automatically scaled to 16-bits\&.
.PP
Orientations other than bottom-left or top-left are not processed correctly\&.
.PP
This man page was originally written by Sam Leffler\&. Updated by Breda
McColgan, Sun Microsystems Inc\&., 2004\&.
...\" created by instant / solbook-to-man, Thu 20 Mar 2014, 02:30
...\" LSARC 2003/085 libtiff, libjpeg, and libpng
